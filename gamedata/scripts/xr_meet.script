----------------------------------------------------------------------------------------------------------------------
--	Схема встречи двух сталкеров
--	автор: Диденко Руслан (Stohe)
--	TODO:
----------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------
--Evaluators
----------------------------------------------------------------------------------------------------------------------
--' Возвращает есть ли у нас контакт с другим сталкером
class "evaluator_contact" (property_evaluator)
function evaluator_contact:__init(name, storage) super (nil, name)
	self.a = storage
end
function evaluator_contact:evaluate()
	if self.a.meet_set ~= true then return false end
	if self.a.meet_only_at_path == true and not db.storage[self.object:id()].move_mgr:arrived_to_first_waypoint() then
		return false
	end

	if db.actor then
		if not db.actor:alive() then
			return false
		end

		if xr_wounded.is_wounded(self.object) then
			return false
		end

		self.a.meet_manager:update()

		if self.mgr == nil then
			self.mgr = self.object:motivation_action_manager()
		end
		if self.mgr:evaluator(stalker_ids.property_enemy):evaluate() then
			self.object:disable_talk()
			return false
		end
		--printf("eva [%s]", tostring(self.a.meet_manager.state))
        return tostring(self.a.meet_manager.state) ~= "nil"
	else
		return false
	end
end

----------------------------------------------------------------------------------------------------------------------
--Actions
----------------------------------------------------------------------------------------------------------------------
--' Приглашение к тороговле
class "action_meet_wait" (action_base)
function action_meet_wait:__init (npc_name,action_name, storage, char_ini) super (nil, action_name)
	self.char_ini = char_ini
	self.a = storage
end
function action_meet_wait:initialize()
	action_base.initialize(self)
	self.object:set_desired_position()
	self.object:set_desired_direction()
	-- кешируемые данные
	self.sound = "nil"

	self.start_wait_time = nil
	self.last_sound_played = false

	self.was_dialog = false
end
function action_meet_wait:execute ()
	action_base.execute(self)
	local meet_manager = self.a.meet_manager

	local victim = nil
	if meet_manager.victim == "actor" then
		victim = db.actor
	elseif tostring(meet_manager.victim) == "nil" then
		victim = nil
	else
		local sim = _G.sim
		if sim then
			victim = sim:story_object(victim)
		end
	end
    if meet_manager.state ~= "quest_npc" then
	    if meet_manager.emerg_state == true then
	        state_mgr.set_state(self.object, meet_manager.state, nil, nil, {look_object = victim}, {animation = true})
	    else
	        state_mgr.set_state(self.object, meet_manager.state, nil, nil, {look_object = victim}, nil)
	    end
	end

	--' Если мы уже были в диалоге с персонажем - фразы отыгрывать не надо
    if self.was_dialog == true then
        return
    else
        if self.object:is_talking() then
            self.was_dialog = true
        end
    end

    if meet_manager.sound ~= "nil" then
        if self.start_wait_time == nil then
            self.start_wait_time = time_global()

            --' Здороваемся.
            if isWeapon(db.actor:active_item()) and
               self.object:relation(db.actor) ~= game_object.friend
            then
                if self.a.sound_start_wpn ~= "nil" then
                    xr_sound.set_sound_play(self.object:id(), self.a.sound_start_wpn)
                end
            else
                if self.a.sound_start ~= "nil" then
                    xr_sound.set_sound_play(self.object:id(), self.a.sound_start)
                end
            end
        end

        local idle_time = time_global() - self.start_wait_time
        if idle_time < 5000 then
            return
        elseif idle_time > 20000 then
            if self.last_sound_played == true then
                return
            end
            if self.a.sound_stop ~= "nil" then
                xr_sound.set_sound_play(self.object:id(), self.a.sound_stop)
            end
            self.last_sound_played = true
        else
            --' Отыгрываем звук
            if meet_manager.sound ~= "nil" then
                xr_sound.set_sound_play(self.object:id(), meet_manager.sound)
            end
        end
    else
        self.start_wait_time = nil
        self.last_sound_played = false
    end
end
function action_meet_wait:finalize ()
	action_base.finalize(self)
end

class "Cmeet_manager"
function Cmeet_manager:__init(npc, storage)
	self.npc = npc
	self.a = storage
	self.emerg_state = false
	self.startdialog = nil
end
function Cmeet_manager:update()
	-- стартовый диалог
	if self.a.meet_dialog ~= nil then
		local tmp = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_dialog)
		if self.startdialog ~= tmp then
			self.startdialog = tmp
			--printf("*DIALOGS %s* SET [%s]", self.npc:name(), tostring(tmp))
			if tmp == nil or tmp == "nil" then
				-- восстановление начального
				--printf("RESTORE")
				self.npc:restore_default_start_dialog()
			else
				--printf("SET %s", tmp)
				-- установка нового
				self.npc:set_start_dialog(tmp)
				if self.npc:is_talking() then
					db.actor:run_talk_dialog(self.npc, self.a.allow_break)
				end
			end
		end
	end

	self:process_use()
	if self.a.precond == "usability" and not self.npc:is_talking() then
		self.state = "nil"
		self.sound = "nil"
	    if self.a.quest_npc then
	        self.was_dialog = false
	        self.hello = false
		end
		return
	end
	if (self.a.precond == "visibility" and 
	   not (self.npc:see(db.actor) and npc_in_actor_frustrum(self.npc)) 
	   and not self.npc:is_talking()) 
	   or (db.actor:is_talking() and not self.npc:is_talking())
	then
		--printf("NIL %s %s", tostring(self.npc:see(db.actor)), tostring(npc_in_actor_frustrum(self.npc)))
		self.state = "nil"
		self.sound = "nil"
	    if self.a.quest_npc then
	        self.was_dialog = false
	        self.hello = false
		end
		return
	end

	if self.npc:is_talking() then
		self.dist = 0
	else
		self.dist = self.npc:position():distance_to(db.actor:position())
	end

	self.victim = self:process_victim()

	self.state_zone,self.sound_zone = self:process_zone()
	if self.state_zone ~= "nil" then
		if self.victim == "nil" then
			self.victim = "actor"
		end
		self.state,self.sound = self.state_zone,self.sound_zone
	else
		self.state,self.sound = self:process_meet()
	end
	local npc_id = self.npc:id()
    if self.a.quest_npc and self:get_key_from_distance(self.a.meet_state) then
        if self.was_dialog == true then
--[[
            local b = false
            if pda.trade_closed then
                pda.trade_closed = false
                b = true
            elseif pda.upgrade_closed then
                pda.upgrade_closed = false
                b = true
            elseif pda.dialog_closed then
                pda.dialog_closed = false
                b = true
            end
            if self.a.sound_stop ~= "nil" and self.a.sound_stop ~= "meet_general_stop" and b and xr_sound.sound_table[npc_id] == nil then
]]
            if self.a.sound_stop ~= "nil" and self.a.sound_stop ~= "meet_general_stop" and pda.dialog_closed and xr_sound.sound_table[npc_id] == nil then
                xr_sound.set_sound_play(npc_id, self.a.sound_stop)
            end
            return
        else
            if self.npc:is_talking() then
                self.was_dialog = true
            end
            if not self.hello then
                self.hello = true
                if not self.npc:is_talking() and self.a.sound_start ~= "nil" and self.a.sound_start ~= "meet_general_start" and xr_sound.sound_table[npc_id] == nil then
                    xr_sound.set_sound_play(npc_id, self.a.sound_start)
                end
            end
        end
    end
	-- Если актер говорит, и говорит не с нами, то мы не должны говорить звуков.
	--if db.actor:is_talking() then
	--	self.sound = "nil"
	--end
	--printf("MEET [%s], state: [%s], sound: [%s]", self.npc:name(), tostring(self.state), tostring(self.sound))
end
function Cmeet_manager:process_zone()
	if self.a.zone == nil then return "nil","nil" end
	local key
	key = self:get_key_from_zone(self.a.zone)
	if key ~= nil then
		local r1,r2
		if self.a.zone[key].state then
			r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.zone[key].state)
			self.emerg_state = true
		end
		if self.a.zone[key].sound then
			r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.zone[key].sound)
		end
		return tostring(r1), tostring(r2)
	end
	return "nil","nil"
end
function Cmeet_manager:process_meet()
	local key
	local is_talking = self.npc:is_talking()
	if isWeapon(db.actor:active_item())	and
       self.npc:relation(db.actor) ~= game_object.friend
    then
		key = self:get_key_from_distance(self.a.meet_state_wpn)
		if key ~= nil then
			local r1,r2
			if self.a.meet_state_wpn[key].state then
				r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state_wpn[key].state)
				self.emerg_state = true
			end
			if is_talking then
				r2 = nil
			else
				if self.a.meet_state_wpn[key].sound then
					r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state_wpn[key].sound)
				end
			end
			return tostring(r1), tostring(r2)
		end
	else
		key = self:get_key_from_distance(self.a.meet_state)
		if key ~= nil then
			local r1,r2
			if self.a.meet_state[key].state then
				r1 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state[key].state)
				self.emerg_state = false
			end
			if is_talking then
				r2 = nil
			else
				if self.a.meet_state[key].sound then
					r2 = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.meet_state[key].sound)
				end
			end
			return tostring(r1), tostring(r2)
		end
	end
	return "nil","nil"
end
function Cmeet_manager:process_victim()
	local key
	if isWeapon(db.actor:active_item())	then
		key = self:get_key_from_distance(self.a.victim_wpn)
		if key ~= nil then
			return tostring(xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.victim_wpn[key].state))
		end
	else
		key = self:get_key_from_distance(self.a.victim)
		if key ~= nil then
			return tostring(xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.victim[key].state))
		end
	end
	return "nil"
end
function Cmeet_manager:get_key_from_distance(t)
	local key
	for k,v in pairs(t) do
		if v.dist >= self.dist then
			key = k
		else
			return key
		end
	end
	return key
end
function Cmeet_manager:get_key_from_zone(t)
	for k,v in pairs(t) do
		if utils.npc_in_zone(db.actor, db.zone_by_name[v.zone]) then
			return k
		end
	end
	return nil
end
function Cmeet_manager:process_use()
	local is_talking = self.npc:is_talking()
--	printf("MM1 %s %s", self.npc:name(), tostring(is_talking))
	-- запрещаем юзать спящих
	if xr_sleeper.is_npc_asleep(self.npc) then
		self.npc:disable_talk()
		self.disable_talk_weapon = false
		if is_talking then
			self.npc:stop_talk()
		end
		return
	end
	local t
	if isWeapon(db.actor:active_item())	and
       self.npc:relation(db.actor) ~= game_object.friend
    then
		t = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.use_wpn)
		if t == "false" then
			self.disable_talk_weapon = true
		end
	else
		t = xr_logic.pick_section_from_condlist(db.actor, self.npc, self.a.use)
		self.disable_talk_weapon = false
	end
	-- проверка по дистанции
--	printf("MM2 %s %s", self.npc:name(), tostring(t))
	if db.storage[self.npc:id()].robbery_zone_id ~= nil then return end
--[[
	if (is_talking and self.npc:position():distance_to_sqr(db.actor:position()) > 9) and
		t ~= "self"
	then
		--printf("MM3 %s stop talk", self.npc:name())
		self.npc:stop_talk()
	end
]]--
	if t == "true" then
		self.npc:enable_talk()
		if is_talking then
			--printf("MM3 %s -> %s", self.npc:name(), tostring(self.a.allow_break))
			db.actor:allow_break_talk_dialog(self.a.allow_break)
		end
	elseif t == "false" then
		self.npc:disable_talk()
		if is_talking then
			self.npc:stop_talk()
		end
	elseif t == "self" then
		if not is_talking then
--			printf("MM3 %s start talk", self.npc:name())
			self.npc:enable_talk()
			db.actor:run_talk_dialog(self.npc, not(self.a.allow_break))
		end
	end
end

----------------------------------------------------------------------------------------------------------------------
-- binder
----------------------------------------------------------------------------------------------------------------------
function add_to_binder(object, char_ini, scheme, section, st)
	local operators		= {}
	local properties	= {}

	local manager = object:motivation_action_manager()

	properties["contact"]		= xr_evaluators_id.stohe_meet_base + 1
	properties["wounded"]		= xr_evaluators_id.sidor_wounded_base
	properties["abuse"]			= xr_evaluators_id.abuse_base

	operators["contact"]		= xr_actions_id.stohe_meet_base + 1
	operators["state_mgr_to_idle_alife"]	= xr_actions_id.state_mgr + 2

	-- Evaluators
	manager:add_evaluator (properties["contact"], 		evaluator_contact("meet_contact", st))

	-- Actions
	local action = action_meet_wait (object:name(),"action_process_meet", st, char_ini)
	action:add_precondition		(world_property(stalker_ids.property_alive, true))
	action:add_precondition		(world_property(stalker_ids.property_enemy,	false))
	action:add_precondition		(world_property(stalker_ids.property_danger,false))
	action:add_precondition		(world_property(stalker_ids.property_anomaly,false))
	action:add_precondition(world_property(xr_evaluators_id.smartcover_action + 3, false))
	action:add_precondition		(world_property(properties["contact"], 		true))
	action:add_precondition		(world_property(properties["wounded"], 		false))
	action:add_precondition		(world_property(properties["abuse"],		false))
	action:add_effect (world_property(properties["contact"], 			false))
	manager:add_action (operators["contact"], action)

	action = manager:action (xr_actions_id.alife)
	action:add_precondition		(world_property(properties["contact"],		false))

	action = manager:action (operators["state_mgr_to_idle_alife"])
	action:add_precondition		(world_property(properties["contact"],		false))

	st.meet_manager = Cmeet_manager(object, st)
end



------------
-- Вызывается только в начале на чтении логики, создает экшены, эвалуаторы и производит
-- первичную настройку.
function set_meet(npc, ini, scheme, section)
	local st = xr_logic.assign_storage_and_bind(npc, ini, scheme, section)
end
-- Вызывается на переключении на новую секцию. Производит вычитывание настроек из текущей секции.
function reset_meet(npc, scheme, st, section)
	local meet_section
--	printf("[%s]", utils.to_str(st.section_logic))
	if scheme == nil or scheme == "nil" then
		meet_section = utils.cfg_get_string(st.ini, st.section_logic, "meet", npc, false, "")
	else
		meet_section = utils.cfg_get_string(st.ini, section, "meet", npc, false, "")
	end
	if meet_section == "default_meet" then
		if scheme == "kamp" then
			init_meet(npc, st.ini, nil, st.meet, scheme)
		else
			init_meet(npc, st.ini, nil, st.meet, nil)
		end
	else
		init_meet(npc, st.ini, meet_section, st.meet, scheme)
	end
end
local function parse_zone_data(s)
--	printf("parse_zone_data [%s]", utils.to_str(s))
	local t = {}

    if s then
		for name in string.gfind( s, "(%|*[^%|]+%|[^%|]+)%p*" ) do
--			printf("[%s]", utils.to_str(name))
			local dat = {	zone = nil,
							state = nil,
							sound = nil}

			local t_pos = string.find( name, "|", 1, true )
			local s_pos = string.find( name, "@", 1, true )

			local zone = string.sub( name, 1, t_pos - 1 )
			local state
			local sound

			if s_pos then
				state	= string.sub( name, t_pos + 1,
											s_pos - 1 )
				sound	= string.sub( name, s_pos + 1)
			else
				state	= string.sub( name, t_pos + 1)
			end

--			printf("	[%s]=[%s][%s]", utils.to_str(zone), utils.to_str(state), utils.to_str(sound))

			dat.zone = zone
			if state then
				dat.state = xr_logic.parse_condlist(nil, nil, nil, state)
			end
			if sound then
				dat.sound = xr_logic.parse_condlist(nil, nil, nil, sound)
			end
			table.insert(t, dat)
		end
	end

    return t
end
function init_meet(npc, ini, section, st, scheme)
	--printf("MEET SECTION [%s][%s]", tostring(section), tostring(scheme))

	if tostring(section) == st.meet_section and
	   tostring(section) ~= "nil"
	then
		return
	end

	st.meet_section = utils.tostring(section)

	-- Устанавливаем дефолты
	local def = {}
	local npc_community = npc:character_community()
	if tostring(scheme) == "nil" then
		def.meet_state		= "5|wait@meet_general_wait"
		def.meet_state_wpn	= "5|threat@meet_weapon_wait"
		def.victim			= "5|actor"
		def.victim_wpn		= "5|actor"
		def.sound_start		= "meet_general_start"
		def.sound_start_wpn = "meet_weapon_start"
		def.sound_stop		= "meet_general_stop"
		def.use				= "true"
		def.use_wpn			= "false"
		def.precond			= "visibility"
		def.abuse			= "true"
		def.quest_npc		= "false"
	elseif tostring(scheme) == "kamp" then
		def.meet_state		= "2|wait"
		def.meet_state_wpn	= ""
		def.victim			= "2|actor"
		def.victim_wpn		= ""
		def.sound_start		= "nil"
		def.sound_start_wpn = "nil"
		def.sound_stop		= "nil"
		def.use				= "{=_kamp_talk}true,false"
		def.use_wpn			= "false"
		def.precond			= "usability"
		def.abuse			= "false"
		def.quest_npc		= "false"
	elseif npc_community == "army" or
			npc_community == "monolith" or
			npc_community == "killer" or
			npc_community == "bandit" or
			npc_community == "zombied" then
		def.meet_state		= ""
		def.meet_state_wpn	= ""
		def.victim			= ""
		def.victim_wpn		= ""
		def.sound_start		= "nil"
		def.sound_start_wpn = "nil"
		def.sound_stop		= "nil"
		def.use				= "false"
		def.use_wpn			= "false"
		def.precond			= "visibility"
		def.abuse			= "false"
		def.quest_npc		= "false"
	else
		def.meet_state		= "2|wait@meet_general_wait"
		def.meet_state_wpn	= "2|threat@meet_weapon_wait"
		def.victim			= "2|actor"
		def.victim_wpn		= "2|actor"
		def.sound_start		= "meet_general_start"
		def.sound_start_wpn = "meet_weapon_start"
		def.sound_stop		= "meet_general_stop"
		def.use				= "true"
		def.use_wpn			= "false"
		def.precond			= "visibility"
		def.abuse			= "true"
		def.quest_npc		= "false"
	end


	if tostring(section) == "nil" then
		-- Загружаем дефолты!
		st.meet_state		= parse_data(npc, def.meet_state)
		st.meet_state_wpn	= parse_data(npc, def.meet_state_wpn)
		st.victim			= parse_data(npc, def.victim)
		st.victim_wpn		= parse_data(npc, def.victim_wpn)
		st.sound_start		= def.sound_start
		st.sound_start_wpn  = def.sound_start_wpn
		st.sound_stop		= def.sound_stop
		st.use				= xr_logic.parse_condlist(nil, nil, nil, def.use)
		st.use_wpn			= xr_logic.parse_condlist(nil, nil, nil, def.use_wpn)
		st.meet_dialog		= xr_logic.parse_condlist(nil, nil, nil, "")
		st.zone				= parse_zone_data("")
		st.precond			= def.precond
		st.abuse			= def.abuse
		st.trade_enable		= utils.cfg_get_bool(ini, section, "trade_enable", npc, false, true)
		st.allow_break		= true
		st.quest_npc		= false
	elseif tostring(section) == "no_meet" then
		st.meet_state		= parse_data(npc, "")
		st.meet_state_wpn	= parse_data(npc, "")
		st.victim			= parse_data(npc, "")
		st.victim_wpn		= parse_data(npc, "")
		st.sound_start		= "nil"
		st.sound_start_wpn  = "nil"
		st.sound_stop		= "nil"
		st.use				= xr_logic.parse_condlist(nil, nil, nil, "false")
		st.use_wpn			= xr_logic.parse_condlist(nil, nil, nil, "false")
		st.meet_dialog		= xr_logic.parse_condlist(nil, nil, nil, "")
		st.zone				= parse_zone_data("")
		st.precond			= "usability"
		st.abuse			= "false"
		st.trade_enable		= utils.cfg_get_bool(ini, section, "trade_enable", npc, false, false)
		st.allow_break		= true
		st.quest_npc		= false
	else
		st.meet_state		= parse_data(npc, utils.cfg_get_string(ini, section, "meet_state", npc, false, "", def.meet_state))
		st.meet_state_wpn	= parse_data(npc, utils.cfg_get_string(ini, section, "meet_state_wpn", npc, false, "", def.meet_state_wpn))
		st.victim			= parse_data(npc, utils.cfg_get_string(ini, section, "victim", npc, false, "", def.victim))
		st.victim_wpn		= parse_data(npc, utils.cfg_get_string(ini, section, "victim_wpn", npc, false, "", def.victim_wpn))
		st.sound_start		= utils.cfg_get_string(ini, section, "sound_start", npc, false, "", def.sound_start)
		st.sound_start_wpn	= utils.cfg_get_string(ini, section, "sound_start_wpn", npc, false, "", def.sound_start_wpn)
		st.sound_stop		= utils.cfg_get_string(ini, section, "sound_stop", npc, false, "", def.sound_stop)
		st.use				= xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(ini, section, "use", npc, false, "", def.use))
		st.use_wpn			= xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(ini, section, "use_wpn", npc, false, "", def.use_wpn))
		st.meet_dialog		= xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(ini, section, "meet_dialog", npc, false, "", ""))
		st.zone				= parse_zone_data(utils.cfg_get_string(ini, section, "zone", npc, false, ""))
		st.precond			= utils.cfg_get_string(ini, section, "precond", npc, false, "", def.precond)
		st.abuse			= utils.cfg_get_string(ini, section, "abuse", npc, false, "", def.abuse)
		st.meet_only_at_path = utils.cfg_get_bool(ini, section, "meet_only_at_path", npc, false, false)
		st.trade_enable		= utils.cfg_get_bool(ini, section, "trade_enable", npc, false, true)
		st.allow_break		= utils.cfg_get_bool(ini, section, "allow_break", npc, false, true)
		st.quest_npc		= utils.cfg_get_bool(ini, section, "quest_npc", npc, false, false)
	end

	--print_table(st)

	-- Проверяем включать ли обижание на заюзывание
	if st.abuse == "true" then
		xr_abuse.enable_abuse(npc)
	else
		xr_abuse.disable_abuse(npc)
	end

	if(st.trade_enable) then
		npc:enable_trade()
	else
		npc:disable_trade()
	end
	-- флажок, что функция хотя бы раз вызывалась
	st.meet_set = true
end

function parse_data(npc,s)
	local t = {}

    if s then
		for name in string.gfind( s, "(%|*%d+%|[^%|]+)%p*" ) do
--			printf("[%s]", utils.to_str(name))
			local dat = {	dist = nil,
							state = nil,
							sound = nil}

			local t_pos = string.find( name, "|", 1, true )
			local s_pos = string.find( name, "@", 1, true )

			local dist = string.sub( name, 1, t_pos - 1 )
			local state
			local sound

			if s_pos then
				state	= string.sub( name, t_pos + 1,
											s_pos - 1 )
				sound	= string.sub( name, s_pos + 1)
			else
				state	= string.sub( name, t_pos + 1)
			end

--			printf("	[%s]=[%s][%s]", utils.to_str(dist), utils.to_str(state), utils.to_str(sound))

			dat.dist = tonumber(dist)
			if state then
				dat.state = xr_logic.parse_condlist(nil, nil, nil, state)
			end
			if sound then
				dat.sound = xr_logic.parse_condlist(nil, nil, nil, sound)
			end
			table.insert(t, dat)
		end
	end
    return t
end

function parse_syn_data(npc,s)
--	printf("parse_syn_data [%s]", utils.to_str(s))
	local t = {}
    if s then
		for name in string.gfind( s, "(%|*[^%|]+%|*)%p*" ) do
			local dat = {	zone = nil,
							state = nil,
							sound = nil}
--			printf("[%s]", utils.to_str(name))

			local t_pos = string.find( name, "@", 1, true )
			local s_pos = string.find( name, "|", 1, true )

			local state = string.sub( name, 1, t_pos - 1 )
			local sound
			if s_pos then
				sound = string.sub( name, t_pos + 1, s_pos -1)
			else
				sound = string.sub( name, t_pos + 1)
			end

			dat.state = state
			dat.sound = sound
			table.insert(t, dat)
		end
	end

    return t
end

-- ДИАЛОГИ ПОКА НЕ ТРОГАЕМ!!!
--' Считывание доступных диалогов игрока.
function set_actor_dialogs(npc, ini, name, dialog_section)
	--printf("*ACTOR_DIALOGS*")
	if dialog_section == nil then return end
	--printf("*ACTOR_DIALOGS*: set_actor_dialogs: npc_name='%s' section='%s'", npc:name(), dialog_section)

	local actor_dialogs_string = utils.cfg_get_string(ini, dialog_section, "id", npc, false, "")
	if actor_dialogs_string ~= nil then
		--printf("*ACTOR_DIALOGS*: actor_dialogs=%s", actor_dialogs_string)
		--' Создаем в массиве запись где будут храниться считанные диалоги.
		db.storage[npc:id()].actor_dialogs = parse_names(actor_dialogs_string)
	else
		--printf("*ACTOR_DIALOGS*: actor_dialogs=nil")
	end

	local actor_disable = utils.cfg_get_string(ini, dialog_section, "disable", npc, false, "")
	if actor_disable ~= nil then
		--printf("*ACTOR_DIALOGS*: actor_disable=%s", actor_disable)
		--' Создаем в массиве запись где будут храниться считанные диалоги.
		db.storage[npc:id()].actor_disable = parse_names(actor_disable)
	else
		--printf("*ACTOR_DIALOGS*: actor_disable=nil")
	end
end
--' ВНИМАНИЕ: Эта функция вызывается и для сталкеров, и для монстров!
function dialog_manager_reset(npc, stype)
	if stype == modules.stype_mobile then
		--printf("*DIALOGS*: dialog_manager_reset: npc:name='%s'", npc:name())
		--' Смена стартового диалога
		local overrides = xr_logic.generic_scheme_overrides(npc)
		if overrides ~= nil then
			if overrides.meet_dialog then
				--printf("*DIALOGS_MOB*: Set start dialog %s", overrides.meet_dialog)
				npc:set_start_dialog(overrides.meet_dialog)
			else
				--printf("*DIALOGS_MOB*: Restore start dialog")
				npc:restore_default_start_dialog()
			end
		else
			--printf("*DIALOGS_MOB*: SCHEME HAS NO OVERRIDES: Restore start dialog")
			npc:restore_default_start_dialog()
		end
	end
end
function disable_scheme(npc, scheme)
	db.storage[npc:id()].actor_dialogs = nil
	db.storage[npc:id()].actor_disable = nil
end

--- Находится ли чувак в данный момент в состоянии мита
function is_meet(npc)
	local manager = npc:motivation_action_manager()
	if manager and manager:initialized() then
		local id = manager:current_action_id()
		if id == xr_actions_id.stohe_meet_base + 1 then
			return true
		end
	end
	return false
end
-- Функция проверяет не мешает ли персонажу говорить с нами оружие
function cannot_talk_by_weapon(npc)
	local st = db.storage[npc:id()].meet
	if st then
		if not isWeapon(db.actor:active_item())	then
			return false
		end
		if st.use then
			local t = xr_logic.pick_section_from_condlist(db.actor, npc, st.use)
			if t == "false" then
				return false
			end
		end
		if st.use_wpn then
			local t = xr_logic.pick_section_from_condlist(db.actor, npc, st.use_wpn)
			if t == "false" then
				return true
			end
		end
	end
	return false
end