local sim = _G.sim

local get_game_time = game.get_game_time
local trans         = game.translate_string

local math_ceil     = math.ceil
local math_floor    = math.floor
local math_random   = math.random

local table_insert  = table.insert

local task_types =
{
	storyline     = 0,
	additional    = 1,
	insignificant = 2
}

local valid_values =
{
	complete        = true,
	fail            = true,
	reversed        = true,
	reversed_silent = true
}

local status_by_id =
{
	[0] = "normal",
	[1] = "selected",
	[2] = "completed",
	[3] = "fail",
	[4] = "reversed",
	[5] = "reversed_silent"
}

local id_by_status =
{
	normal          = 0,
	selected        = 1,
	completed       = 2,
	fail            = 3,
	reversed        = 4,
	reversed_silent = 5
}

local id_by_community =
{
	csky          = 1,
	stalker       = 2,
	bandit        = 3,
	freedom       = 4,
	dolg          = 5,
	ecolog        = 6,
	killer        = 7,
	renegade      = 8,
	army          = 9,
	zombied       = 10,
	monolith      = 11,
	monster       = 12,
	none          = 13,
	actor         = 14,
	actor_csky    = 15,
	actor_stalker = 16,
	actor_bandit  = 17,
	actor_freedom = 18,
	actor_dolg    = 19,
	trader        = 20,
	["nil"]       = 21
}

local community_by_id =
{
	[1]  = "csky",
	[2]  = "stalker",
	[3]  = "bandit",
	[4]  = "freedom",
	[5]  = "dolg",
	[6]  = "ecolog",
	[7]  = "killer",
	[8]  = "renegade",
	[9]  = "army",
	[10] = "zombied",
	[11] = "monolith",
	[12] = "monster",
	[13] = "none",
	[14] = "actor",
	[15] = "actor_csky",
	[16] = "actor_stalker",
	[17] = "actor_bandit",
	[18] = "actor_freedom",
	[19] = "actor_dolg",
	[20] = "trader",
	[21] = "nil"
}

------------------------------------------------------------------------------------------------

class "CGeneralTask"

------------------------------------------------------------------------------------------------

function CGeneralTask:__init(task_ini, id, type)

	local get_string                       = utils.cfg_get_string
	local get_bool                         = utils.cfg_get_bool
	local get_number                       = utils.cfg_get_number
	local parse_condlist                   = xr_logic.parse_condlist

	self.task_ini                          = task_ini
	self.type                              = type
	self.task_type                         = task_types[get_string(task_ini, id, "task_type", nil, false, "", "additional")]
	self.base_id                           = id
	self.id                                = id
	self.name                              = get_string(task_ini, id, "name", nil, false, "", tostring(id))
	self.icon                              = "ui_pda2_mtask_overlay"
	self.spot                              = get_string(task_ini, id, "spot", nil, false, "", nil)
	self.faction_target                    = get_string(task_ini, id, "faction", nil, false, "", nil)
	self.base_prior                        = get_number(task_ini, id, "prior", nil, false, 0)
	self.prior                             = self.base_prior
	self.text                              = trans(get_string(task_ini, id, "text", nil, false, "", "NO_TEXT")) -- SRP: wrapped in trans()
	self.description                       = get_string(task_ini, id, "description", nil, false, "", "NO_TEXT")
	self.board                             = sim_board.get_sim_board()
	self.auto_name                         = get_bool(task_ini, id, "auto_name", nil, false, true)
	self.auto_faction                      = get_bool(task_ini, id, "auto_faction", nil, false, false)
	self.entity_id                         = nil
	self.support_attack                    = get_bool(task_ini, id, "support_attack", nil, false, true)
	self.play_regard                       = get_string(task_ini, id, "play_regard", nil, false, "", "")

	local i = 0
	local T = {}
	local section = "condlist_0"

	self.condlist = T

	while task_ini:line_exist(id, section) do
		T[i] = parse_condlist(nil, nil, nil, task_ini:r_string(id, section))
		i = i + 1
		section = "condlist_"..i
	end

	self.on_init                           = parse_condlist(nil, nil, nil, get_string(task_ini, id, "on_init", nil, false, "", ""))
	self.on_complete                       = parse_condlist(nil, nil, nil, get_string(task_ini, id, "on_complete", nil, false, "", ""))
	self.on_reversed                       = parse_condlist(nil, nil, nil, get_string(task_ini, id, "on_reversed", nil, false, "", ""))
	self.on_fail                           = parse_condlist(nil, nil, nil, get_string(task_ini, id, "on_fail", nil, false, "", ""))

	self.reward_money                      = parse_condlist(nil, nil, nil, get_string(task_ini, id, "reward_money", nil, false, "", ""))
	self.reward_item                       = parse_condlist(nil, nil, nil, get_string(task_ini, id, "reward_item", nil, false, "", ""))
	self.immediate_reward                  = get_bool(task_ini, id, "immediate_reward", nil, false, false)

	self.community_relation_delta_fail     = get_number(task_ini, id, "community_relation_delta_fail", nil, false, 0)
	self.community_relation_delta_complete = get_number(task_ini, id, "community_relation_delta_complete", nil, false, 0)

	self.status                            = "normal"
	self.actor_helped                      = false
	self.check_time                        = 0
end

function CGeneralTask:give_task(community)

	self.actor_come = false
	self.actor_ignore = false
	self.community = community

	local str = community
	if str == "bandit" then
		str = "ui_st_name_bandit"
	elseif str == "csky" then
		str = "ui_st_name_csky"
	elseif str == "dolg" then
		str = "ui_st_name_dolg"
	elseif str == "freedom" then
		str = "ui_st_name_freedom"
	elseif str == "stalker" then
		str = "ui_st_name_stalker"
	end

	self.community_name = trans(str)

	local t = CGameTask()
	local type = self.type

	if self.auto_name then
		local title = ""
		if (type == "eliminate_smart") or (type == "capture_smart") or (type == "defend_smart") or (type == "defend_smart_delay") then
			local sname = smart_names.get_smart_terrain_name(self.board.smarts[self.target].smrt)
--			if sname == nil then -- sname is always a string
--				sname = self.board.smarts[self.target].smrt:name()
--			end
			title = trans(self.name)..": "..sname
		elseif (type == "recover_item") then
			local item_inv_name = trans(system_ini():r_string(self.requested_item, "inv_name"))
			title = trans("sim_recover_item").." "..item_inv_name
		elseif (type == "find_upgrade") then
			title = trans("sim_find_upgrade").."."
		elseif (type == "bring_item") then
			title = "sim_bring_item"
		else
			title = trans(self.name)
		end
		t:set_title(title)
	else
		t:set_title(self.name)
	end

	if (type == "eliminate_smart") or (type == "capture_smart") or (type == "defend_smart") or (type == "defend_smart_delay") then
		task_manager.get_task_manager().tasks_by_smarts[self.target] = self
	end

	t:set_id(tostring(self.entity_id))
	t:set_type(self.task_type)
	t:set_priority(self.prior)
	t:set_icon_name(self.icon)

	if (type == "take_reward") then
		t:set_description("")
	else
		if self.auto_faction then
			t:set_description(self.community_name..".\\n"..self.text)
		else
			t:set_description(self.text)
		end
	end

	t:add_complete_func("task_manager.task_complete")
	t:add_fail_func("task_manager.task_fail")

	local act = db.actor

	xr_logic.pick_section_from_condlist(act, act, self.on_init)

	local time = 0
	if self.wait_time ~= nil then
		time = self.wait_time
	end

	if self.spot == nil then
		if (type == "storyline") then
			if (self.task_type == task_types.storyline) then
				self.spot = "primary_task_location"
			else
				self.spot = "secondary_task_location"
			end
		else
			if (self.task_type == task_types.storyline) then
				self.spot = "primary_task_location"
			else
				if time == 0 then
					if (type == "find_upgrade") then
						self.spot = "secondary_task_location_complex_"..self.requested_item
					else
						self.spot = "secondary_task_location_complex_"..type
					end
				else
					self.spot = "secondary_task_location_complex_timer"
				end
			end
		end
	end

	if self.target ~= nil then
		t:set_map_location(self.spot)
		t:set_map_object_id(self.target)
		if (type == "defend_smart") or (type == "defend_smart_delay") then
			level.map_add_object_spot(self.target, "ui_pda_long_blink_point_location", "")
		else
			if (type ~= "storyline") and (self.task_type ~= task_types.storyline) then
				level.map_add_object_spot(self.target, "ui_pda_short_blink_point_location", "")
			end
		end
	end

	self.status = "selected"
	self.inited_time = get_game_time()
	task_manager.get_task_manager().task_info[tostring(self.entity_id)] = self
	act:give_task(t, time * 10, false, time)
	self.t = t
	xr_statistic.inc_recieved_quests_counter()
end

function CGeneralTask:check_task(tm)

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local act = db.actor

	for k, condlist in pairs (self.condlist) do
		local status = xr_logic.pick_section_from_condlist(act, act, condlist)
		if status ~= nil then
			if valid_values[status] ~= true then
				abort("[task_objects.CGeneralTask:check_task]: Invalid task status '%s' for task '%s'.", tostring(status), tostring(self.name))
			end
			self.last_check_task = status
			return
		end
	end
end

function CGeneralTask:actor_hit(faction_name)
	if faction_name ~= self.community then
		self.actor_helped = true
	end
end

function CGeneralTask:actor_comed()
end

function CGeneralTask:init_reward()

	local act = db.actor

	xr_logic.pick_section_from_condlist(act, act, self.on_complete)

	if self.community == nil then -- moved this below on_complete effect check to ensure effects happen even if task given by no faction
		return
	end

	local tm = task_manager.get_task_manager()
	local is_reward = false

	local money = xr_logic.pick_section_from_condlist(act, act, self.reward_money)
	local items = xr_logic.pick_section_from_condlist(act, act, self.reward_item)

	if not self.immediate_reward then

		if tm.rewards[self.community] == nil then
			tm.rewards[self.community] = {}
		end

		if money ~= nil then

			if type(money) == "table" then
				abort("[task_objects.CGeneralTask:init_reward]: init_reward:task_id = "..tostring(self.id))
			end

			table_insert(tm.rewards[self.community], {money = tonumber(money)})

			is_reward = true
		end

		if items ~= nil then

			for k, v in pairs (utils.parse_names(items)) do
				table_insert(tm.rewards[self.community], {item = v})
			end

			is_reward = true
		end
	else
--		local npc = inventory_upgrades.victim

		if money ~= nil then

			if type(money) == "table" then
				abort("[task_objects.CGeneralTask:init_reward]: init_reward:task_id = "..tostring(self.id))
			end

			dialogs.relocate_money(nil, tonumber(money), "in")
		end

		if items ~= nil then

			local ancillary_item_table = {}

			for k, v in pairs (utils.parse_names(items)) do
				if ancillary_item_table[v] == nil then
					ancillary_item_table[v] = 1
				else
					ancillary_item_table[v] = ancillary_item_table[v] + 1
				end
			end

			for k, v in pairs (ancillary_item_table) do
				dialogs.relocate_item_section(nil, k, "in", v)
			end
		end
	end

	if is_reward == false then
		return
	end

	local rewarder_id = tm.rewarders[self.community]

	if rewarder_id == nil then
		return
	end

	local reward_task = tm:select_task("take_reward", rewarder_id, self.community)

	if reward_task.status == "normal" then
		reward_task:give_task(self.community)
	end

	reward_task:change_description(tm)
end

function CGeneralTask:reverse_task()
	self.last_check_task = "reversed"
end

function CGeneralTask:deactivate_task(_task)

	if self.last_check_task == "fail" then
		local act = db.actor
		xr_logic.pick_section_from_condlist(act, act, self.on_fail) -- missing by default but referenced in tm_military.ltx
		news_manager.send_task(act, "fail", _task)
	elseif self.last_check_task == "reversed" then
		local act = db.actor
		xr_logic.pick_section_from_condlist(act, act, self.on_reversed)
		news_manager.send_task(act, "reversed", _task)
--	elseif self.last_check_task == "reversed_silent" then
--		local act = db.actor
--		xr_logic.pick_section_from_condlist(act, act, self.on_reversed)
	end

	self.last_check_task = nil
	self.status = "normal"
end

function CGeneralTask:save(package)

	set_save_marker(package, "save", false, "CGeneralTask")

	if self.entity_id == nil then
		package:w_u16(-1)
	else
		package:w_u16(self.entity_id)
	end

	package:w_u8(self.prior)
	package:w_u8(id_by_status[self.status])
	package:w_bool(self.actor_helped)
--[[
	if self.community ~= nil then
		package:w_stringZ(self.community)
	else
		package:w_stringZ("nil")
	end
]]
	if self.community ~= nil then
		local community_id = id_by_community[tostring(self.community)]
		if community_id ~= nil then
			package:w_u8(community_id)
		else
			abort("[task_objects.CGeneralTask:save]: No registered faction identifier exists for faction with name: '%s'. If a save file was created, it is corrupt.", tostring(self.community))
		end
	else
		package:w_u8(0)
	end

	package:w_bool(self.actor_come == true)
--	package:w_bool(self.actor_ignore == true)

	utils.w_CTime(package, self.inited_time)

	set_save_marker(package, "save", true, "CGeneralTask")
end

function CGeneralTask:load(reader)

	set_save_marker(reader, "load", false, "CGeneralTask")

	local entity_id = reader:r_u16()

	if entity_id == 65535 then
		self.entity_id = nil
	else
		self.entity_id = entity_id
	end

	self.prior = reader:r_u8()
	self.status = status_by_id[reader:r_u8()]
	self.actor_helped = reader:r_bool()
--[[
	local str = reader:r_stringZ()

	if str ~= "nil" then
		self.community = str
	end

	if str == "bandit" then
		str = "ui_st_name_bandit"
	elseif str == "csky" then
		str = "ui_st_name_csky"
	elseif str == "dolg" then
		str = "ui_st_name_dolg"
	elseif str == "freedom" then
		str = "ui_st_name_freedom"
	elseif str == "stalker" then
		str = "ui_st_name_stalker"
	end
]]
	local str = reader:r_u8()

	if str ~= 0 then
		self.community = community_by_id[str]
	else
		self.community = "nil"
	end

	local str = self.community

	if str == "csky" then
		str = "ui_st_name_csky"
	elseif str == "stalker" then
		str = "ui_st_name_stalker"
	elseif str == "freedom" then
		str = "ui_st_name_freedom"
	elseif str == "dolg" then
		str = "ui_st_name_dolg"
	elseif str == "bandit" then
		str = "ui_st_name_bandit"
	end

	self.community_name = trans(str)

	self.actor_come = reader:r_bool()
--	self.actor_ignore = reader:r_bool()

	self.inited_time = utils.r_CTime(reader)

	set_save_marker(reader, "load", true, "CGeneralTask")
end

------------------------------------------------------------------------------------------------

class "CEliminateSmartTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CEliminateSmartTask:__init(task_ini, id, type) super (task_ini, id, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "true"))
--	self.src_obj = nil
--	self.faction = nil
end

function CEliminateSmartTask:check_target(smart, faction) -- called 1st (not on load)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

	return xr_logic.pick_section_from_condlist(db.actor, smart, self.target_cond) == "true"
end

function CEliminateSmartTask:get_inited_task(smart, faction, entity_id) -- called 2nd (not on load)
	local task = CEliminateSmartTask(self.task_ini, self.base_id, self.type) -- calls CGeneralTask:__init() and CEliminateSmartTask:__init()
	task:init_task(smart, faction)
	task.entity_id = entity_id
	return task
end

function CEliminateSmartTask:init_task(smart, faction) -- called 4th (not on load)
	self.target = smart.id
	-- self.target_obj = smart -- smart to eliminate
	self.id	= self.id .. "_" .. smart.id
	self.community = faction
	-- self.name = smart:name()
	self.prior = self.base_prior
end

function CEliminateSmartTask:give_task(community) -- called 5th (not on load)
	task_objects.CGeneralTask.give_task(self, community)
end

function CEliminateSmartTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local target_owner = self.board.smarts[self.target].smrt.player_name

	if target_owner == "none" or target_owner == self.community then
		if self.actor_helped then
			self.last_check_task = "complete"
--[[
			local act = db.actor	-- there are no such sounds defined, so this code won't do anything
			if act then
				if self.play_regard == "" then
					xr_sound.set_sound_play(act:id(), "alife_general_help_"..self.community, self.community, self.target)
				elseif self.play_regard ~= "nil" then
					xr_sound.set_sound_play(act:id(), self.play_regard, self.community, self.target)
				end
			end
]]
		else
			self.last_check_task = "reversed"
		end
	end
end

function CEliminateSmartTask:reverse_task()
	self.last_check_task = "reversed"
end

function CEliminateSmartTask:deactivate_task(_task) -- called 7th

	task_objects.CGeneralTask.deactivate_task(self, _task)
--[[
	task_manager.get_task_manager():unregister_faction_task(self.community, self)

	if self.src_obj ~= nil then
		local squad_obj = self.board.squads[self.src_obj]
		if squad_obj ~= nil then
			for k, v in pairs (squad_obj.random_tasks) do
				if v == self.entity_id then
					squad_obj.random_tasks[k] = nil
				end
			end
		end
	end

	local faction = self.faction
]]
	local faction = self.board.players[self.community]
	if faction ~= nil then
		if faction.random_tasks ~= nil then
			faction.random_tasks[self.target] = nil
		end
	end
end

function CEliminateSmartTask:save(package)

	set_save_marker(package, "save", false, "CEliminateSmartTask")

	task_objects.CGeneralTask.save(self, package)

	package:w_u16(self.target)
--[[
	package:w_stringZ(tostring(self.src_obj))

	if self.faction ~= nil then
		package:w_stringZ(tostring(self.faction.player_name))
	else
		package:w_stringZ("nil")
	end

	local faction = self.faction
	if faction ~= nil then
		local community_id = id_by_community[tostring(faction.player_name)]
		if community_id ~= nil then
			package:w_u8(community_id)
		else
			abort("[task_objects.CEliminateSmartTask:save]: No registered faction identifier exists for task-giver faction with name: '%s'. If a save file was created, it is corrupt.", tostring(faction.player_name))
		end
	else
		package:w_u8(0)
	end
]]
	set_save_marker(package, "save", true, "CEliminateSmartTask")
end

function CEliminateSmartTask:load(reader) -- called 0.5th (only on load)

	set_save_marker(reader, "load", false, "CEliminateSmartTask")

	task_objects.CGeneralTask.load(self, reader)

	self.target = reader:r_u16()

	self.id	= self.id.."_"..self.target
--[[
	self.src_obj = reader:r_stringZ()

	if self.src_obj == "nil" then
		self.src_obj = nil
	end

	local faction = reader:r_stringZ()
	if faction ~= "nil" then
		local board = sim_board.get_sim_board()
		if board.players[faction] ~= nil then
			self.faction = board.players[faction]
		else
			self.faction = {}
			self.faction.player_name = faction
		end
	end

	local faction_id = reader:r_u8()
	if faction_id ~= 0 and faction_id ~= 21 then
		local faction_name = community_by_id[faction_id]
		if faction_name == nil then
			abort("[task_objects.CEliminateSmartTask:load]: Tried to load an unregistered faction name identifier: '%s'. Your save file is corrupt.", tostring(faction_id))
		end
		local faction = self.board.players[faction_name]
		if faction ~= nil then
			self.faction = faction
		else
			self.faction = {}
			self.faction.player_name = faction_name
		end
	end
]]
	set_save_marker(reader, "load", true, "CEliminateSmartTask")
end

------------------------------------------------------------------------------------------------

class "CCaptureSmartTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CCaptureSmartTask:__init(task_ini, id, type) super (task_ini, id, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "true"))
	self.counter_attack = utils.cfg_get_bool(task_ini, id, "counter_attack", nil, false, true)
	self.src_obj = nil
--	self.faction = nil
end

function CCaptureSmartTask:check_target(smart, faction) -- called 1st (not on load)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

	return xr_logic.pick_section_from_condlist(db.actor, smart, self.target_cond) == "true"
end

function CCaptureSmartTask:get_inited_task(smart, faction, entity_id) -- called 2nd (not on load)
	local task = CCaptureSmartTask(self.task_ini, self.base_id, self.type) -- calls CGeneralTask:__init() and CCaptureSmartTask:__init()
	task:init_task(smart, faction)
	task.entity_id = entity_id
	return task
end

function CCaptureSmartTask:init_task(smart, faction) -- called 4th (not on load)
	self.target = smart.id
	-- self.target_obj = smart -- smart to capture
	self.id	= self.id .. "_" .. smart.id
	self.community = faction
	-- self.name = smart:name()
	self.prior = self.base_prior
end

function CCaptureSmartTask:give_task(community) -- called 5th (not on load)

	if self.src_obj ~= nil then
		local squad = self.board.squads[self.src_obj]
		if squad ~= nil then
			squad:give_squad_task(self.target)
		end
	end

	task_objects.CGeneralTask.give_task(self, community)

	bind_stalker.task_update = false

	self.state = "capture"
	self.ally_squad_id = nil -- SRP fix
	self.counter_squad = nil
	self.counter_attack_community = self.board.smarts[self.target].smrt.player_name
	self.counter_sound_started = false
	self.last_called_time = get_game_time() -- SRP fix
end

function CCaptureSmartTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		if self.last_check_task == "fail" then
			self.board.smarts[self.target].smrt.combat_manager.combat_quest = "nil"
		end
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	self:check_title(self.state == "counter_attack")

	local target_obj = self.board.smarts[self.target].smrt
--[[
	if self.last_check_task == "fail" then
		target_obj.combat_manager.combat_quest = "nil"
		return
	end
]]
	if target_obj.player_name == self.community then
		if self.state == "counter_attack" then
			if not target_obj.combat_manager:point_under_attack() then
				if self.actor_helped then

					self.last_check_task = "complete"
					target_obj.combat_manager.combat_quest = "nil"

					for k, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
						if self.play_regard == "" then
							xr_sound.set_sound_play(ally_squad.commander_id, "alife_defence_actor_help", self.community, self.target)
						elseif self.play_regard ~= "nil" then
							xr_sound.set_sound_play(ally_squad.commander_id, self.play_regard, self.community, self.target)
						end
						break
					end
					return
				else
					self.last_check_task = "reversed"
					target_obj.combat_manager.combat_quest = "nil"
--[[
					for k, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
						if self.play_regard == "" then
							xr_sound.set_sound_play(ally_squad.commander_id, "alife_point_captured", self.community, self.target)
						elseif self.play_regard ~= "nil" then
							xr_sound.set_sound_play(ally_squad.commander_id, self.play_regard, self.community, self.target)
						end
						break
					end
]]
				end
			end
		else
			if self.counter_attack == true then
				if self.counter_attack_community ~= nil and self.counter_attack_community ~= "none" then
					if self.board.players[self.counter_attack_community].brain.use_counter_attack == true then

						if self.ally_squad_id == nil then -- SRP fix
							for k, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
								self.ally_squad_id = ally_squad.squad_id -- SRP fix
								break
							end
						end

						if self.counter_sound_started ~= true then
							local ally_squad = self.board.squads[self.ally_squad_id] -- SRP fix
							if ally_squad then -- SRP fix
								ally_squad.sound_manager:set_storyteller(ally_squad.commander_id)
								ally_squad.sound_manager:set_story("squad_"..self.counter_attack_community.."_counter_attack")
							end
							self.counter_sound_started = true
							self.last_called_time = get_game_time() -- SRP fix
							return
						end

						if get_game_time():diffSec(self.last_called_time) <= 150 then -- SRP fix
							local ally_squad = self.ally_squad_id and self.board.squads[self.ally_squad_id] -- SRP fix
							if ally_squad then -- SRP fix
								if not ally_squad.sound_manager:is_finished() then
									return
								end
							end
						end

						for neighbor_smart_id in pairs (self.board:get_nearest_smarts(target_obj)) do
							for neighbor_squad_id, neighbor_squad in pairs (self.board.smarts[neighbor_smart_id].squads) do
								if self.counter_attack_community == neighbor_squad.player_id then
									local neighbor_script_target = neighbor_squad:get_script_target()
									if not neighbor_script_target or neighbor_script_target == target_obj.id then -- SRP fix
										local ally_squad = self.ally_squad_id and self.board.squads[self.ally_squad_id] -- SRP fix
										if ally_squad then -- SRP fix
											ally_squad.sound_manager:set_story("squad_"..self.counter_attack_community.."_counter_launched")
										end
										neighbor_squad.current_action = sim_squad_generic.sim_attack_point(neighbor_squad, target_obj.id, true)
										neighbor_squad.current_action:make()
										self.state = "counter_attack"
										self.counter_squad = neighbor_squad_id
										return
									end
								end
							end
						end
					end
				end
			end

			if self.actor_helped then

				self.last_check_task = "complete"
				target_obj.combat_manager.combat_quest = "nil"

				for k, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
					if self.play_regard == "" then
						xr_sound.set_sound_play(ally_squad.commander_id, "alife_defence_actor_help", self.community, self.target)
					elseif self.play_regard ~= "nil" then
						xr_sound.set_sound_play(ally_squad.commander_id, self.play_regard, self.community, self.target)
					end
					break
				end
			else
				self.last_check_task = "reversed"
				target_obj.combat_manager.combat_quest = "nil"
--[[
				for k, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
					if self.play_regard == "" then
						xr_sound.set_sound_play(ally_squad.commander_id, "alife_point_captured", self.community, self.target)
					elseif self.play_regard ~= "nil" then
						xr_sound.set_sound_play(ally_squad.commander_id, self.play_regard, self.community, self.target)
					end
					break
				end
]]
			end
		end
	end
end

function CCaptureSmartTask:check_title(is_counterattack)

	local t = self.t

	if t == nil then
		local actor = db.actor
		t = actor and actor:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CCaptureSmartTask:check_title]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	local target_obj = self.board.smarts[self.target].smrt

	if is_counterattack == true then
		local sname = smart_names.get_smart_terrain_name(target_obj)
		local title = trans("sim_repeal_counterattack").." ("..sname..")"
		t:set_title(title)
		return
	end

	if target_obj.player_name == "none" then
		if self.board:actor_near_smart(target_obj) then
			local sname = smart_names.get_smart_terrain_name(target_obj)
			local title = trans("sim_capture_wait_smart").." ("..sname..")"
			t:set_title(title)
			return
		end
	end
end

function CCaptureSmartTask:reverse_task()
	self.last_check_task = "reversed"
	self.board.smarts[self.target].smrt.combat_manager.combat_quest = "nil"
end

function CCaptureSmartTask:deactivate_task(_task) -- called 7th

	task_objects.CGeneralTask.deactivate_task(self, _task)
	local mgr = self.board.smarts[self.target].smrt.combat_manager -- SRP
	mgr.combat_quest = "nil"                                       -- SRP
	mgr.task = nil                                                 -- SRP
--	task_manager.get_task_manager():unregister_faction_task(self.community, self)

	if self.src_obj ~= nil then
		local squad_obj = self.board.squads[self.src_obj]
		if squad_obj ~= nil then
			for k, v in pairs (squad_obj.random_tasks) do
				if v == self.entity_id then
					squad_obj.random_tasks[k] = nil
				end
			end
		end
	end
--[[
	if self.faction ~= nil then
		self.faction.random_tasks = {} -- ??? WTF ???
	end
]]
	local faction = self.board.players[self.community]
	if faction ~= nil then
		if faction.random_tasks ~= nil then
			faction.random_tasks[self.target] = nil
		end
	end
end

function CCaptureSmartTask:save(package)

	set_save_marker(package, "save", false, "CCaptureSmartTask")

	task_objects.CGeneralTask.save(self, package)

	package:w_u16(self.target)
--[[
	if self.state == nil then
		package:w_stringZ("nil")
	else
		package:w_stringZ(self.state)
	end

	if self.counter_attack_community == nil then
		package:w_stringZ("nil")
	else
		package:w_stringZ(self.counter_attack_community)
	end
]]
	local self_state = self.state
	if self_state == nil then
		package:w_u8(0)
	elseif self_state == "capture" then
		package:w_u8(1)
	elseif self_state == "counter_attack" then
		package:w_u8(2)
	else
		abort("[task_objects.CCaptureSmartTask:save]: Tried to save an identifier for an invalid task state: '%s'. If a save file was created, it is corrupt.", tostring(self_state))
	end

	local counter_community = self.counter_attack_community
	if counter_community == nil then
		package:w_u8(0)
	else
		local community_id = id_by_community[tostring(counter_community)]
		if community_id ~= nil then
			package:w_u8(community_id)
		else
			abort("[task_objects.CCaptureSmartTask:save]: No registered faction identifier exists for counter-attack faction with name: '%s'. If a save file was created, it is corrupt.", tostring(counter_community))
		end
	end
--[[
	if self.counter_sound_started ~= nil then
		package:w_bool(self.counter_sound_started)
	else
		package:w_bool(false)
	end
]]
	package:w_bool(self.counter_sound_started == true)

	package:w_stringZ(tostring(self.ally_squad_id)) -- SRP fix

	package:w_stringZ(tostring(self.counter_squad))

	package:w_stringZ(tostring(self.src_obj))
--[[
	if self.faction ~= nil then
		package:w_stringZ(tostring(self.faction.player_name))
	else
		package:w_stringZ("nil")
	end

	local faction = self.faction
	if faction ~= nil then
		local community_id = id_by_community[tostring(faction.player_name)]
		if community_id ~= nil then
			package:w_u8(community_id)
		else
			abort("[task_objects.CCaptureSmartTask:save]: No registered faction identifier exists for task-giver faction with name: '%s'. If a save file was created, it is corrupt.", tostring(faction.player_name))
		end
	else
		package:w_u8(0)
	end
]]
	utils.w_CTime(package, self.last_called_time) -- SRP fix

	set_save_marker(package, "save", true, "CCaptureSmartTask")
end

function CCaptureSmartTask:load(reader) -- called 0.5th (only on load)

	set_save_marker(reader, "load", false, "CCaptureSmartTask")

	task_objects.CGeneralTask.load(self, reader)

	self.target = reader:r_u16()

	self.id	= self.id.."_"..self.target
--[[
	local string = reader:r_stringZ()
	if string == "nil" then
		self.state = nil
	else
		self.state = string
	end

	string = reader:r_stringZ()
	if string == "nil" then
		self.counter_attack_community = nil
	else
		self.counter_attack_community = string
	end
]]
	local self_state_id = reader:r_u8()
	if self_state_id == 0 then
		self.state = nil
	elseif self_state_id == 1 then
		self.state = "capture"
	elseif self_state_id == 2 then
		self.state = "counter_attack"
	else
		abort("[task_objects.CCaptureSmartTask:load]: Tried to load an invalid task state identifier: '%s'. Your save file is corrupt.", tostring(self_state_id))
	end

	local counter_id = reader:r_u8()
	if counter_id ~= 0 then
		local community_name = community_by_id[counter_id]
		if community_name ~= nil then
			self.counter_attack_community = community_name
		else
			abort("[task_objects.CCaptureSmartTask:load]: Tried to load an unregistered counter-attack faction identifier: '%s'. Your save file is corrupt.", tostring(counter_id))
		end
	end

	self.counter_sound_started = reader:r_bool()

	self.ally_squad_id = reader:r_stringZ() -- SRP fix
	if self.ally_squad_id == "nil" then
		self.ally_squad_id = nil
	end

	self.counter_squad = reader:r_stringZ()
	if self.counter_squad == "nil" then
		self.counter_squad = nil
	end

	self.src_obj = reader:r_stringZ()
	if self.src_obj == "nil" then
		self.src_obj = nil
	end
--[[
	local faction = reader:r_stringZ()

	if faction ~= "nil" then
		local board = sim_board.get_sim_board()
		if board.players[faction] ~= nil then
			self.faction = board.players[faction]
		else
			self.faction = {}
			self.faction.player_name = faction
		end
	end

	local faction_id = reader:r_u8()

	if faction_id ~= 0 and faction_id ~= 21 then
		local faction_name = community_by_id[faction_id]
		if faction_name == nil then
			abort("[task_objects.CCaptureSmartTask:load]: Tried to load an unregistered faction name identifier: '%s'. Your save file is corrupt.", tostring(faction_id))
		end
		local faction = self.board.players[faction_name]
		if faction ~= nil then
			self.faction = faction
		else
			self.faction = {}
			self.faction.player_name = faction_name
		end
	end
]]
	self.last_called_time = utils.r_CTime(reader) -- SRP fix

	set_save_marker(reader, "load", true, "CCaptureSmartTask")
end

------------------------------------------------------------------------------------------------

class "CDefendSmartTask" (task_objects.CGeneralTask) -- 'Help' task

------------------------------------------------------------------------------------------------

function CDefendSmartTask:__init(task_ini, id, type) super (task_ini, id, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "true"))
	local time = utils.cfg_get_number(task_ini, id, "wait_time", nil, false, 15)
	self.wait_time = (time ~= -1) and (60 * time) or nil
--[[
	if time == -1 then
		self.wait_time = nil
	else
		self.wait_time = 60 * time
	end
]]
end

function CDefendSmartTask:check_target(smart, faction) -- called 1st (not on load)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

	return xr_logic.pick_section_from_condlist(db.actor, smart, self.target_cond) == "true"
end

function CDefendSmartTask:get_inited_task(smart, faction, entity_id) -- called 2nd (not on load)
	local task = CDefendSmartTask(self.task_ini, self.base_id, self.type) -- calls CGeneralTask:__init() and CDefendSmartTask:__init()
	task:init_task(smart, faction)
	task.entity_id = entity_id
	return task
end

function CDefendSmartTask:init_task(smart, faction) -- called 4th (not on load)
	self.target = smart.id
	-- self.target_obj = smart -- smart to defend
	self.community = faction
	-- self.name = smart:name()
	-- self.id = self.id .. "_" .. smart.id
	self.prior = self.base_prior
end

function CDefendSmartTask:give_task(community) -- called 5th (not on load)

	task_objects.CGeneralTask.give_task(self, community)

	local enemy_squad = self.board.squads[self.src_squad_id]
	if enemy_squad == nil then
		self.last_called_time = get_game_time()
		return
	end

	if self.play_regard == "" then
		for k, defender_squad in pairs (self.board.smarts[self.target].squads) do
			defender_squad:issue_order("defend_sos_"..enemy_squad.player_id)
			break
		end
	end

	self.last_called_time = get_game_time()
end

function CDefendSmartTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local target_obj = self.board.smarts[self.target].smrt

--	if target_obj.player_name == "none" then
	if target_obj.player_name ~= self.community then
		if self.actor_come or get_game_time():diffSec(self.inited_time) > self.wait_time then
			self.last_check_task = "fail"
		else
			self.last_check_task = "reversed"
		end
		target_obj.combat_manager.combat_quest = "nil"
		return
	end

	if not target_obj.combat_manager:point_under_attack() then
		if self.actor_helped then
			if self.play_regard == "" then
				for k, defender_squad in pairs (self.board.smarts[self.target].squads) do
					defender_squad:issue_order("defend_actor_help")
					break
				end
			end
			self.last_check_task = "complete"
			target_obj.combat_manager.combat_quest = "nil"
		else
			self.last_check_task = "reversed"
			target_obj.combat_manager.combat_quest = "nil"
		end
		return
	end

	if self.actor_come ~= true then
		if self.actor_helped then
			self:actor_comed(target_obj.combat_manager)
		else
			local game_time = get_game_time()
			if self.wait_time ~= nil and game_time:diffSec(self.inited_time) > self.wait_time then
				self:actor_ignored(target_obj.combat_manager)
				self.last_called_time = game_time
			elseif game_time:diffSec(self.last_called_time) > 50 then
				if self.play_regard == "" then
					for k, defender_squad in pairs (self.board.smarts[self.target].squads) do
						defender_squad:issue_order("defend_wait")
						break
					end
				end
				self.last_called_time = game_time
			end
		end
	end
end

function CDefendSmartTask:actor_comed(target_obj_combat_manager)
	if self.actor_come ~= true then
		self.actor_come = true
		if self.play_regard == "" then
--			if get_game_time():diffSec(self.inited_time) >= 30 then -- thank for coming iff actor showed up at least 3 real seconds after the task was initiated (currently disabled)
				for k, defender_squad in pairs (self.board.smarts[self.target].squads) do
					defender_squad:issue_order("defend_actor_come")
					break
				end
--			end
		end
		target_obj_combat_manager:request_squad_stage(nil, "combat")
	end
end

function CDefendSmartTask:actor_ignored(target_obj_combat_manager)
	if self.actor_ignore ~= true then
		self.actor_ignore = true
--[[
		if self.play_regard == "" then
			for k, defender_squad in pairs (self.board.smarts[self.target].squads) do -- GSC didn't include ignore sounds so this code won't do anything
				defender_squad:issue_order("defend_actor_ignore")
				break
			end
		end
]]
		target_obj_combat_manager:request_squad_stage(nil, "combat")
	end
end

function CDefendSmartTask:reverse_task()
	self.last_check_task = "reversed"
	self.board.smarts[self.target].smrt.combat_manager.combat_quest = "nil"
end

function CDefendSmartTask:deactivate_task(_task) -- called 7th
	task_objects.CGeneralTask.deactivate_task(self, _task)
	local mgr = self.board.smarts[self.target].smrt.combat_manager
	mgr.combat_quest = "nil"
	mgr.task = nil
--	task_manager.get_task_manager():unregister_faction_task(self.community, self)
end

function CDefendSmartTask:save(package)
	set_save_marker(package, "save", false, "CDefendSmartTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	utils.w_CTime(package, self.last_called_time)
	set_save_marker(package, "save", true, "CDefendSmartTask")
end

function CDefendSmartTask:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CDefendSmartTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	self.last_called_time = utils.r_CTime(reader)
	set_save_marker(reader, "load", true, "CDefendSmartTask")
end

------------------------------------------------------------------------------------------------

class "CDefendSmartTaskDelay" (task_objects.CGeneralTask) -- 'Defend the camp' task

------------------------------------------------------------------------------------------------

function CDefendSmartTaskDelay:__init(task_ini, id, type) super (task_ini, id, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "true"))
	local time = utils.cfg_get_number(task_ini, id, "wait_time", nil, false, 15)
	self.wait_time = (time ~= -1) and (60 * time) or nil
--[[
	if time == -1 then
		self.wait_time = nil
	else
		self.wait_time = 60 * time
	end
]]
end

function CDefendSmartTaskDelay:check_target(smart, faction) -- called 1st (not on load)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

	return xr_logic.pick_section_from_condlist(db.actor, smart, self.target_cond) == "true"
end

function CDefendSmartTaskDelay:get_inited_task(smart, faction, entity_id) -- called 2nd (not on load)
	local task = CDefendSmartTaskDelay(self.task_ini, self.base_id, self.type) -- calls CGeneralTask:__init() and CDefendSmartTaskDelay:__init()
	task:init_task(smart, faction)
	task.entity_id = entity_id
	return task
end

function CDefendSmartTaskDelay:init_task(smart, faction) -- called 4th (not on load)
	self.target = smart.id
	-- self.target_obj = smart -- smart to defend
	self.community = faction
	-- self.name = smart:name()
	-- self.id = self.id .. "_" .. smart.id
	self.prior = self.base_prior
end

function CDefendSmartTaskDelay:give_task(community) -- called 5th (not on load)

	task_objects.CGeneralTask.give_task(self, community)

	-- SRP:
	local enemy_squad = self.board.squads[self.src_squad_id]
	if enemy_squad == nil then
		self.last_called_time = get_game_time()
		return
	end

	if self.play_regard == "" then
--		if sim_combat.actor_come_to_point(self.board.smarts[self.target]) == false then -- shout for help on delayed defend tasks iff actor not already on smart when task initiated (currently disabled)
			for k, defender_squad in pairs (self.board.smarts[self.target].squads) do
				defender_squad:issue_order("defend_sos_"..enemy_squad.player_id)
				break
			end
--			self.last_called_time = get_game_time()
--		end
	end

	self.last_called_time = get_game_time()
end

function CDefendSmartTaskDelay:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local target_obj = self.board.smarts[self.target].smrt

	if target_obj.player_name ~= self.community then
		if self.actor_come or get_game_time():diffSec(self.inited_time) > self.wait_time then
			self.last_check_task = "fail"
		else
			self.last_check_task = "reversed"
		end
		target_obj.combat_manager.combat_quest = "nil"
		local enemy_squad = self.board.squads[self.src_squad_id]
		if enemy_squad then
			enemy_squad.delayed_attack_task = nil
		end
		return
	end

	local enemy_squad = self.board.squads[self.src_squad_id]

	if enemy_squad == nil then
		if self.actor_helped then
			if self.play_regard == "" then
				for k, defender_squad in pairs (self.board.smarts[self.target].squads) do
					defender_squad:issue_order("defend_actor_help")
					break
				end
			end
			self.last_check_task = "complete"
			target_obj.combat_manager.combat_quest = "nil"
		else
			self.last_check_task = "reversed"
			target_obj.combat_manager.combat_quest = "nil"
		end
		return
	end

	if self.actor_come ~= true then
		if sim_combat.actor_come_to_point(target_obj) == true then
			self.actor_come = true
			if self.play_regard == "" then
--				if get_game_time():diffSec(self.inited_time) >= 30 then -- thank for coming iff actor showed up at least 3 real seconds after the task was initiated (currently disabled)
					for k, defender_squad in pairs (self.board.smarts[self.target].squads) do
						defender_squad:issue_order("defend_actor_come")
						break
					end
--				end
			end
		else
			if get_game_time():diffSec(self.last_called_time) > 50 then
				if self.play_regard == "" then
					for k, defender_squad in pairs (self.board.smarts[self.target].squads) do
						defender_squad:issue_order("defend_wait")
						break
					end
				end
				self.last_called_time = get_game_time()
			end
		end
	end

	if self.attack_launched ~= true then
		if self.actor_come or get_game_time():diffSec(self.inited_time) > self.wait_time then
			local enemy_action = enemy_squad.current_action
			if enemy_action ~= nil and enemy_action.name == "stay_point" then
				enemy_squad.current_action = sim_squad_generic.sim_attack_point(enemy_squad, self.target, true)
				enemy_squad.current_action:make()
				self.attack_launched = true
			end
		end
	end
--[[
	if self.attack_launched ~= true then
		if self.actor_come or get_game_time():diffSec(self.inited_time) > self.wait_time then
			local source_smart_squads = self.board.smarts[enemy_squad.smart_id].squads
			local attacking_num = 0
			local enemy_player = enemy_squad.player_id
			for k, enemy_squad in pairs (source_smart_squads) do
				if attacking_num < target_obj.squad_capacity then
					if enemy_squad.player_id == enemy_player then
						local enemy_script_target = enemy_squad:get_script_target()
						if not enemy_script_target or enemy_script_target == target_obj.id then -- SRP fix
							if enemy_squad.current_action ~= nil then
								if enemy_squad.current_action.name == "stay_point" then
									enemy_squad.current_action = sim_squad_generic.sim_attack_point(enemy_squad, target_obj.id, true)
									enemy_squad.current_action:make()
									attacking_num = attacking_num + 1
								end
							end
						end
					end
				else
					break
				end
			end
			self.attack_launched = true
		end
	end
]]
end

function CDefendSmartTaskDelay:reverse_task()
	self.last_check_task = "reversed"
	self.board.smarts[self.target].smrt.combat_manager.combat_quest = "nil"
	local enemy_squad = self.board.squads[self.src_squad_id]
	if enemy_squad then
		enemy_squad.delayed_attack_task = nil
	end
end

function CDefendSmartTaskDelay:deactivate_task(_task) -- called 7th
	task_objects.CGeneralTask.deactivate_task(self, _task)
	local mgr = self.board.smarts[self.target].smrt.combat_manager -- SRP
	mgr.combat_quest = "nil"                                       -- SRP
	mgr.task = nil                                                 -- SRP
--	task_manager.get_task_manager():unregister_faction_task(self.community, self)
end

function CDefendSmartTaskDelay:save(package)
	set_save_marker(package, "save", false, "CDefendSmartTaskDelay")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	utils.w_CTime(package, self.last_called_time)
	package:w_stringZ(tostring(self.src_squad_id)) -- SRP
	set_save_marker(package, "save", true, "CDefendSmartTaskDelay")
end

function CDefendSmartTaskDelay:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CDefendSmartTaskDelay")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	self.last_called_time = utils.r_CTime(reader)
	self.src_squad_id = reader:r_stringZ() -- SRP
	set_save_marker(reader, "load", true, "CDefendSmartTaskDelay")
end

------------------------------------------------------------------------------------------------

class "CGetRewardTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CGetRewardTask:__init(task_ini, id, type) super (task_ini, id, type) -- called 0th (on load), 0th and 3rd (otherwise)
end

function CGetRewardTask:check_target(npc_id, faction) -- called 1st (not on load)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

	return true
end

function CGetRewardTask:get_inited_task(npc_id, faction, entity_id) -- called 2nd (not on load)
	local task = CGetRewardTask(self.task_ini, self.base_id, self.type) -- calls CGeneralTask:__init() and CGetRewardTask:__init()
	task:init_task(npc_id)
	task.entity_id = entity_id
	return task
end

function CGetRewardTask:init_task(npc_id) -- called 4th (not on load)
	self.target = npc_id
	self.id	= self.id .. "_" .. npc_id
end

function CGetRewardTask:change_description(tm) -- called 5th

	local amount_money = 0
	local ancillary_item_table = {}

	for k, reward in pairs (tm.rewards[self.community]) do
		if reward.money ~= nil then
			amount_money = amount_money + reward.money
		elseif reward.item ~= nil then
			if ancillary_item_table[reward.item] == nil then
				ancillary_item_table[reward.item] = 1
			else
				ancillary_item_table[reward.item] = ancillary_item_table[reward.item] + 1
			end
		end
	end

	local s = ""

	if amount_money ~= 0 then
--		dbglog("money total: "..amount_money)
		s = s.."\\n>"..tostring(amount_money).." RU"
	end

	local ammo_sections = ammo_section
	local ltx = system_ini()

	for k, v in pairs (ancillary_item_table) do
		local name = trans(ltx:r_string(k, "inv_name"))
		if ammo_sections[k] == true then
			local box_size = ltx:r_s32(k, "box_size")
			s = s.."\\n>"..name.." x"..v*box_size
		else
			if v == 1 then
				s = s.."\\n>"..name
			else
				s = s.."\\n>"..name.." x"..v
			end
		end
	end

	local t = self.t

	if t == nil then
		t = db.actor:get_task(tostring(self.entity_id), true) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CGetRewardTask:change_description]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	self.description = s

	if self.auto_faction then
		t:set_description(self.community_name..".\\n"..s)
	else
		t:set_description(s)
	end
end

function CGetRewardTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local actor = db.actor

	if actor == nil then
		return
	end

	if tm.rewards[self.community] == nil then
		self.last_check_task = "complete"
	end

	if #tm.rewards[self.community] == 0 then
		self.last_check_task = "complete"
	end

	local npc = sim:object(self.target)

	if not npc or not npc:alive() then
		self.last_check_task = "reversed"
		tm.rewards[self.community] = nil
		return
	end

	npc = db.storage[self.target]
	npc = npc and npc.object

	if npc then
		if npc:general_goodwill(actor) <= -1000 then
			self.last_check_task = "reversed"
			tm.rewards[self.community] = nil
			return
		end
	end

	for k, condlist in pairs (self.condlist) do
		local status = xr_logic.pick_section_from_condlist(actor, actor, condlist)
		if status ~= nil then
			if valid_values[status] ~= true then
				abort("[task_objects.CGetRewardTask:check_task]: Invalid task status '%s' for task '%s'.", tostring(status), tostring(self.name))
			end
			self.last_check_task = status
			return
		end
	end
end

function CGetRewardTask:init_reward() -- called 7th
end

function CGetRewardTask:deactivate_task(_task) -- called 8th
	task_objects.CGeneralTask.deactivate_task(self, _task)
end

function CGetRewardTask:save(package)
	set_save_marker(package, "save", false, "CGetRewardTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	set_save_marker(package, "save", true, "CGetRewardTask")
end

function CGetRewardTask:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CGetRewardTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	self.id	= self.id.."_"..self.target
	set_save_marker(reader, "load", true, "CGetRewardTask")
end

------------------------------------------------------------------------------------------------

class "CStorylineTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CStorylineTask:__init(task_ini, id, type) super (task_ini, id, type)
	-- self.target_story_ids = utils.cfg_get_number(task_ini, id, "target_story_ids", nil, true)
	self.target_story_ids = utils.cfg_get_string(task_ini, id, "target_story_ids", nil, true, "")
end

function CStorylineTask:check_target(obj)
	return self.base_id == obj
end

function CStorylineTask:get_inited_task(obj, faction, entity_id)

	local sid = tonumber(self.target_story_ids)
	if sid then
		self.target = id_by_sid(sid)
		if not self.target then
			abort("[task_objects.CStorylineTask:get_inited_task]: Storyline task target with story ID '%s' does not exist.", tostring(self.target_story_ids))
		end
	else
		local gulag = nil
		local param1, param2 = utils.parse_target(self.target_story_ids)
		if param2 then
			gulag = xr_gulag.get_gulag_by_name(param2)
		end

		if gulag ~= nil then
			self.target = gulag:idNPCOnJob(param1)
		else
			abort("[task_objects.CStorylineTask:get_inited_task]: Target job is nil.")
		end
	end
	--[[
	if self.target_story_ids ~= nil then
		self.target = alife():story_object(self.target_story_ids)
	else
		abort("Target story id is nil.")
	end

	if self.target == nil then
		abort("Target for storyline task doesnt exist. Story id [%s]", tostring(self.target_story_ids))
	end

	self.target = self.target.id
	]]
	if self.target == nil then
		abort("[task_objects.CStorylineTask:get_inited_task]: Storyline task target with story ID '%s' does not exist.", tostring(self.target_story_ids))
	end

	self.entity_id = entity_id

	return self
end

function CStorylineTask:save(package)
	set_save_marker(package, "save", false, "CStorylineTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u32(self.target)
	set_save_marker(package, "save", true, "CStorylineTask")
end

function CStorylineTask:load(reader)
	set_save_marker(reader, "load", false, "CStorylineTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u32()
	set_save_marker(reader, "load", true, "CStorylineTask")
end

------------------------------------------------------------------------------------------------

class "CBringItemTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CBringItemTask:__init(task_ini, id, type) super (task_ini, id, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "true"))
end

function CBringItemTask:check_target(squad_id, faction) -- called 1st (not on load)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

--	local obj_st = db.storage[commander_id]
--	local squad = obj_st.squad_obj
	local squad = self.board.squads[squad_id]

	if squad == nil then
		return false
	end

--	local t = xr_logic.pick_section_from_condlist(db.actor, obj_st.object, self.target_cond)
	local t = xr_logic.pick_section_from_condlist(db.actor, db.storage[squad.commander_id].object, self.target_cond)

	if t == "true" then
		local inited_time = squad.bring_item_inited_time
		if inited_time then
			if math_floor(get_game_time():diffSec(inited_time)) < 86400 then -- 60*60*24 = seconds in one day
				return false
			end
		end
		return true
	end

	return false
end

function CBringItemTask:get_inited_task(squad_id, faction, entity_id) -- called 2nd (not on load)
	local task = CBringItemTask(self.task_ini, self.base_id, self.type) -- calls CGeneralTask:__init() and CBringItemTask:__init()
	task:init_task(squad_id)
	task.entity_id = entity_id
	return task
end

function CBringItemTask:init_task(squad_id) -- called 4th (not on load)
	local community = "actor"
	local sss = utils.cfg_get_string(self.task_ini, self.base_id, "requested_items", nil, false, "")
	if sss ~= nil then
		local actor_array = {}
		self.items_array = {["actor"] = actor_array}
		for k, item_name in pairs (utils.parse_names(sss)) do
			if actor_array[item_name] == nil then
				actor_array[item_name] =
				{
					chance = 1,
					min_count = 1,
					max_count = 1
				}
			else
				local actor_item_array = actor_array[item_name]
				actor_item_array.min_count = actor_item_array.min_count + 1
				actor_item_array.max_count = actor_item_array.min_count
			end
		end
	else -- never the case in vanilla
		local level_name = level.name()
		if level_name == nil then
			abort("[task_objects.CBringItemTask:init_task]: Level name is nil!")
		end
		local quest_ini = ini_file("misc\\bring_item_task.ltx")
		if not quest_ini:section_exist(level_name) then
			level_name = "default"
		end
--		community = db.storage[commander_id].object:character_community()
		community = self.board.squads[squad_id].player_id
		if not quest_ini:section_exist(community) then
			abort("[task_objects.CBringItemTask:init_task]: No section for community '%s' in misc\\bring_item_task.ltx.", tostring(community))
		end
		local faction_table = {}
		self.items_array = {[community] = faction_table}
		for i = 0, quest_ini:line_count(community) - 1 do
			local result, item_name, chance_and_counts = quest_ini:r_line(community, i, "", "")
			local t = parse_nums(chance_and_counts)
			if t[1] == nil or t[2] == nil then
				abort("[task_objects.CBringItemTask:init_task]: Invalid parameter list '%s' in misc\\bring_item_task.ltx for community '%s' at line '%s'.", tostring(chance_and_counts), tostring(community), tostring(item_name))
			end
			if t[3] == nil then
				t[3] = t[2]
			end
			if quest_ini:line_exist(level_name, item_name) then
				local t2 = parse_nums(quest_ini:r_string(level_name, item_name))
				if t2[1] == nil or t2[2] == nil then
					abort("[task_objects.CBringItemTask:init_task]: Invalid parameter list for item '%s' in section '%s'.", tostring(item_name), tostring(level_name))
				end
				if t2[3] == nil then
					t2[3] = t2[2]
				end
				t[1] = t[1] * t2[1]
				t[2] = t[2] * t2[2]
				t[3] = t[3] * t2[3]
			end
			faction_table[item_name] =
			{
				chance = t[1],
				min_count = t[2],
				max_count = t[3]
			}
		end
	end
	self.ri_counter = 0
	self.requested_items = {}
	self:generate_requested_items(community)
--	self.target = commander_id
	self.target = self.board.squads[squad_id].commander_id
--	self.squad_id = alife():object(commander_id).squad_id
	self.squad_id = squad_id
--	self.npc = nil
--	self.tmp_counter = 0
	self.state = "started"
	-- db.actor:iterate_inventory(set_inventory_item_count, self.requested_items) -- iterate on give task
	self:set_task_text_for_bring_item()
end

function CBringItemTask:generate_requested_items(community)
	local sections_count = math_random(1, 4)
	local cur_sections_count = 0
	while (cur_sections_count == 0) do
		for item_name, count_table in pairs (self.items_array[community]) do
			if cur_sections_count > sections_count then
				break
			end
			local items_count = math_random(count_table.min_count, count_table.max_count)
			for i = 1, items_count do
				if math_random() <= count_table.chance then
					local cnt_table = self.requested_items[item_name]
					if cnt_table ~= nil then
						cnt_table.goal = cnt_table.goal + 1
					else
						self.requested_items[item_name] = {num = 0, goal = 1, xferd = 0}
						cur_sections_count = cur_sections_count + 1
					end
					self.ri_counter = self.ri_counter + 1
				end
			end
		end
	end
end

function CBringItemTask:set_task_text_for_bring_item()
	local s = ""
	local ini = system_ini()
	for item_name, cnt_table in pairs (self.requested_items) do
		local name = trans(ini:r_string(item_name, "inv_name")).." x"..cnt_table.goal
		if cnt_table.goal > cnt_table.num then
			s = s.."- "..name.."\\n"
		else
			s = s.."+ "..name.."\\n"
		end
	end
	self.text = s
end

local function set_inventory_item_count(requested_items, item)
	local sect = item:section()
	for item_name in pairs (requested_items) do
		if item_name == sect then
			local cnt_table = requested_items[item_name]
			cnt_table.num = cnt_table.num + 1
			return
		end
	end
end

function CBringItemTask:give_task(community) -- called 5th (not on load)
	task_objects.CGeneralTask.give_task(self, community)
--	local squad = db.storage[self.target].squad_obj
--	local squad = self.board.squads[self.squad_id]
--	if squad then
--		squad.bring_item_inited_time = self.inited_time
--	end
	self.squad.bring_item_inited_time = self.inited_time -- self.squad set by task_dialogs.give_squad_capture_task()
	db.actor:iterate_inventory(set_inventory_item_count, self.requested_items)
end

function CBringItemTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 250

	local actor = db.actor

	if actor == nil then
		return
	end

	local commander_id = self.squad.commander_id -- self.squad set by task_dialogs.give_squad_capture_task() or CBringItemTask:load(), guaranteed valid
--[[
	-- If tasker squad commander doesn't exist or is dead, cancel.
	-- Update: This is implicitly checked in sim_board:remove_squad().
	local commander = alife():object(commander_id)
	if not commander or not commander:alive() then
		self.last_check_task = "reversed"
		return
	end
]]
	local commander = db.storage[commander_id]
	commander = commander and commander.object

	-- If tasker squad commander is hostile, cancel:
	if commander then
		if commander:general_goodwill(actor) <= -1000 then
			self.last_check_task = "reversed"
			return
		end
	end

	if self:has_requested_items(actor) then
		self.state = "have_item"
	else
		self.state = "started"
	end

	if self.target ~= commander_id then
		self.target = commander_id
		self.t:change_map_location(self.spot, commander_id)
	end
end

function CBringItemTask:has_requested_items(actor)

	local t = self.t

	if t == nil then
		t = actor:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CBringItemTask:has_requested_items]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	local c = 0

	for k, cnt_table in pairs (self.requested_items) do
		c = c + (cnt_table.num < cnt_table.goal and cnt_table.num or cnt_table.goal)
	end

	if self.auto_faction then
		t:set_description(self.community_name..".\\n"..self.text)
	else
		t:set_description(self.text)
	end

	if c < self.ri_counter then
		t:set_title(trans("sim_bring_item").." "..c.." ("..self.ri_counter..")")
		return false
	else
		t:set_title("sim_bring_item_text")
		return true
	end
end

function CBringItemTask:on_item_take(item)
	local cnt_table = self.requested_items[item:section()]
	if cnt_table then
		cnt_table.num = cnt_table.num + 1
	end
--	db.actor:iterate_inventory(set_inventory_item_count, self.requested_items)
	self:set_task_text_for_bring_item()
end

function CBringItemTask:on_item_drop(item)
	local cnt_table = self.requested_items[item:section()]
	if cnt_table then
		cnt_table.num = cnt_table.num - 1
	end
--	db.actor:iterate_inventory(set_inventory_item_count, self.requested_items)
	self:set_task_text_for_bring_item()
end

function CBringItemTask:on_load(actor)
	actor:iterate_inventory(set_inventory_item_count, self.requested_items)
end

local function transfer_non_slotted_items(task, item)
	local item_sect = item:section()
	for item_name, cnt_table in pairs (task.requested_items) do
		if item_sect == item_name then
			if cnt_table.xferd < cnt_table.goal then
				db.actor:transfer_item(item, task.npc)
				cnt_table.xferd = cnt_table.xferd + 1
			end
			return
		end
	end
end

function CBringItemTask:transfer_items_looking_for(npc)
	self.npc = npc
	self.state = "finished"
	db.actor:iterate_inventory(transfer_non_slotted_items, self)
	self.last_check_task = "complete"
end

function CBringItemTask:deactivate_task(_task) -- called 7th
	task_objects.CGeneralTask.deactivate_task(self, _task)
--	task_manager.get_task_manager():unregister_faction_task(self.community, self)
	local squad = self.squad
	if squad then
		squad.random_tasks[4] = nil
	end
end

function CBringItemTask:save(package)

	set_save_marker(package, "save", false, "CBringItemTask")

	task_objects.CGeneralTask.save(self, package)
--[[
	local self_state = self.state

	if self_state == "started" then
		package:w_u8(1)
	elseif self_state == "have_item" then
		package:w_u8(2)
	elseif self_state == "finished" then
		package:w_u8(3)
	else
		abort("[task_objects.CBringItemTask:save]: Tried to save an identifier for an invalid task state: '%s'. If a save file was created, it is corrupt.", tostring(self_state))
	end
]]
	package:w_u8(self.ri_counter)
--[[
	if self.target then
		package:w_u16(self.target)
	else
		package:w_u16(-1)
	end
]]
	if self.squad_id == nil then
		package:w_stringZ("nil")
	else
		package:w_stringZ(self.squad_id)
	end

	local n = 0
	for item_name in pairs (self.requested_items) do
		n = n + 1
	end

	package:w_u8(n)

	for item_name, cnt_table in pairs (self.requested_items) do
		package:w_stringZ(item_name)
		package:w_u8(cnt_table.goal)
	end

	set_save_marker(package, "save", true, "CBringItemTask")
end

function CBringItemTask:load(reader) -- called 0.5th (only on load)

	set_save_marker(reader, "load", false, "CBringItemTask")

	task_objects.CGeneralTask.load(self, reader)
--[[
	local state = reader:r_u8()

	if state == 1 then
		self.state = "started"
	elseif state == 2 then
		self.state = "have_item"
	elseif state == 3 then
		self.state = "finished"
	else
		abort("[task_objects.CBringItemTask:load]: Tried to load an invalid task state identifier: '%s'. Your save file is corrupt.", tostring(state))
	end

	self.npc = nil
]]
	self.ri_counter = reader:r_u8()
--[[
	local n = reader:r_u16()

	if n ~= 65535 then
		self.target = n
	end
]]
	local n = reader:r_stringZ()
	if n ~= "nil" then
		self.squad_id = n
	end

	self.squad = self.board.squads[self.squad_id]

	-- If tasker squad doesn't exist (it always should), cancel:
	if self.squad == nil then
		self.last_check_task = "reversed"
	end

	self.spot = "secondary_task_location_complex_bring_item"

	self.requested_items = {}

	n = reader:r_u8()
	for i = 1, n do
		local item_name = reader:r_stringZ()
		local goal = reader:r_u8()
		self.requested_items[item_name] = {num = 0, goal = goal, xferd = 0}
	end

	set_save_marker(reader, "load", true, "CBringItemTask")
end

------------------------------------------------------------------------------------------------

class "CRecoverItemTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CRecoverItemTask:__init(task_ini, id, type) super (task_ini, id, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "false"))
	local target_npc_or_box_name = utils.cfg_get_string(task_ini, id, "target_npc_or_box_name", nil, true, "")
	self.target_npc_or_box_table = utils.parse_names(target_npc_or_box_name)
	self.requested_item = task_ini:r_string(id, "requested_items")
	self.requested_item_inv_name = trans(system_ini():r_string(self.requested_item, "inv_name")) -- SRP
end

function CRecoverItemTask:check_target(squad_id, faction) -- called 1st (not on load)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

	local squad = self.board.squads[squad_id]

	if squad == nil then
		return false
	end

	local t = xr_logic.pick_section_from_condlist(db.actor, db.storage[squad.commander_id].object, self.target_cond)

	if t == "true" then
		local inited_time = squad.recover_item_inited_time
		if inited_time then
			if math_floor(get_game_time():diffSec(inited_time)) < 86400 then -- 60*60*24 = seconds in one day
				return false
			end
		end
		return true
	end

	return false
end

function CRecoverItemTask:get_inited_task(squad_id, faction, entity_id) -- called 2nd (not on load)
	local task = CRecoverItemTask(self.task_ini, self.base_id, self.type) -- calls CGeneralTask:__init() and CRecoverItemTask:__init()
	task:init_task(squad_id)
	task.entity_id = entity_id
	return task
end

function CRecoverItemTask:init_task(squad_id) -- called 4th (not on load)
	self.squad_id = squad_id
--	self.description = ""
--	self.npc = nil
	self.target = nil
	self.target_obj_id = nil
--	self.presence_requested_item = false
	self.state = "started"
end

function CRecoverItemTask:give_task(community) -- called 5th (not on load)
	self:spawn_recoveritem()
	task_objects.CGeneralTask.give_task(self, community)
--	local squad = self.board.squads[self.squad_id]
--	if squad then
--		squad.recover_item_inited_time = self.inited_time
--	end
	self.squad.recover_item_inited_time = self.inited_time -- self.squad set by task_dialogs.give_squad_capture_task()
end

function CRecoverItemTask:spawn_recoveritem()
--	local sim = alife()
	local index = random_number(1, #self.target_npc_or_box_table)
	local target_npc_or_box = sim:object(self.target_npc_or_box_table[index])
	if target_npc_or_box then
		local container_id = target_npc_or_box.id
		local container_pos = target_npc_or_box.position
		local container_lvx = target_npc_or_box.m_level_vertex_id
		local container_gvx = target_npc_or_box.m_game_vertex_id
		self.target_obj_id = sim:create(self.requested_item, container_pos, container_lvx, container_gvx, container_id).id
		self.target = container_id
	else
		abort("[task_objects.CRecoverItemTask:spawn_recoveritem]: There is no such target npc or box: '%s'.", tostring(self.target_npc_or_box_table[index]))
	end
end

function CRecoverItemTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 250

	local actor = db.actor

	if actor == nil then
		return
	end

	local commander_id = self.squad.commander_id -- self.squad set by task_dialogs.give_squad_capture_task() or CRecoverItemTask:load(), guaranteed valid
--[[
	-- If tasker squad commander doesn't exist or is dead, cancel.
	-- Update: This is implicitly checked in sim_board:remove_squad().
	local commander = alife():object(commander_id)
	if not commander or not commander:alive() then
		self.last_check_task = "reversed"
		return
	end
]]
	local commander = db.storage[commander_id]
	commander = commander and commander.object

	-- If tasker squad commander is hostile, cancel:
	if commander then
		if commander:general_goodwill(actor) <= -1000 then
			self.last_check_task = "reversed"
			return
		end
	end

	if self:has_requested_item(actor) then
		self.state = "have_item"
		if self.target ~= commander_id then
			self.target = commander_id
			self.t:change_map_location(self.spot, commander_id)
		end
	else
		self.state = "started"
		local target_obj_id = self.target_obj_id
		if self.target ~= target_obj_id then
			self.target = target_obj_id
			self.t:change_map_location(self.spot, target_obj_id)
		end
	end
end

function CRecoverItemTask:has_requested_item(actor)

	local t = self.t

	if t == nil then
		t = actor:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CRecoverItemTask:has_requested_item]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	local has_requested_item = false
	local s = ""

	if actor:object(self.requested_item) ~= nil then
		s = "+ "
		has_requested_item = true
	else
		s = "- "
	end

	local description = self.text.."\\n"..s..self.requested_item_inv_name

	if self.auto_faction then
		t:set_description(self.community_name..".\\n"..description)
	else
		t:set_description(description)
	end

	return has_requested_item
end
--[[
local function transfer_recover_item(task, item)
	if item:section() == task.requested_item then
		db.actor:transfer_item(item, task.npc)
		return
	end
end
]]
function CRecoverItemTask:transfer_items_looking_for(npc) -- called 7th
--	self.npc = npc
--	db.actor:iterate_inventory(transfer_recover_item, self)
	dialogs.relocate_item_section(npc, self.requested_item, "out")
	self.state = "finished"
	self.last_check_task = "complete"
end

function CRecoverItemTask:deactivate_task(_task) -- called 8th
	task_objects.CGeneralTask.deactivate_task(self, _task)
--	task_manager.get_task_manager():unregister_faction_task(self.community, self)
	local squad = self.squad
	if squad then
		squad.random_tasks[3] = nil
	end
end

function CRecoverItemTask:save(package)

	set_save_marker(package, "save", false, "CRecoverItemTask")

	task_objects.CGeneralTask.save(self, package)
--[[
	local self_state = self.state

	if self_state == "started" then
		package:w_u8(1)
	elseif self_state == "have_item" then
		package:w_u8(2)
	elseif self_state == "finished" then
		package:w_u8(3)
	else
		abort("[task_objects.CRecoverItemTask:save]: Tried to save an identifier for an invalid task state: '%s'. If a save file was created, it is corrupt.", tostring(self_state))
	end
]]
	if self.squad_id == nil then
		package:w_stringZ("nil")
	else
		package:w_stringZ(self.squad_id)
	end

	if self.target_obj_id == nil then
		package:w_u16(-1)
	else
		package:w_u16(self.target_obj_id)
	end

--	package:w_bool(self.presence_requested_item)

--	package:w_stringZ(self.requested_item) -- read in CRecoverItemTask:__init()

	set_save_marker(package, "save", true, "CRecoverItemTask")
end

function CRecoverItemTask:load(reader) -- called 0.5th (only on load)

	set_save_marker(reader, "load", false, "CRecoverItemTask")

	task_objects.CGeneralTask.load(self, reader)
--[[
	local state = reader:r_u8()

	if state == 1 then
		self.state = "started"
	elseif state == 2 then
		self.state = "have_item"
	elseif state == 3 then
		self.state = "finished"
	else
		abort("[task_objects.CRecoverItemTask:load]: Tried to load an invalid task state identifier: '%s'. Your save file is corrupt.", tostring(state))
	end
]]
	local n = reader:r_stringZ()
	if n ~= "nil" then
		self.squad_id = n
	end

	self.squad = self.board.squads[self.squad_id]

	-- If tasker squad doesn't exist (it always should), cancel:
	if self.squad == nil then
		self.last_check_task = "reversed"
	end

	self.spot = "secondary_task_location_complex_recover_item"

	n = reader:r_u16()
	if n ~= 65535 then
		self.target_obj_id = n
	end

--	self.npc = nil

--	self.presence_requested_item = reader:r_bool()

--	self.requested_item = reader:r_stringZ() -- read in CRecoverItemTask:__init()

	set_save_marker(reader, "load", true, "CRecoverItemTask")
end

------------------------------------------------------------------------------------------------

class "CHideFromSurgeTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CHideFromSurgeTask:__init(task_ini, id, type) super (task_ini, id, type)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "true"))
end

function CHideFromSurgeTask:check_target()
	local act = db.actor
	return xr_logic.pick_section_from_condlist(act, act, self.target_cond) == "true"
end

function CHideFromSurgeTask:get_inited_task(nearest_hide_zone_id, faction, entity_id)
	local task = CHideFromSurgeTask(self.task_ini, self.base_id, self.type)
	task:init_task(nearest_hide_zone_id)
	task.entity_id = entity_id
	return task
end

function CHideFromSurgeTask:init_task(nearest_hide_zone_id)
	self.target = nearest_hide_zone_id
	self.disable_ui = false
	self.kill_em_all = false
	self.effector_started_time = -1
	self.wait_time = 0
	self.blowout_rumble_level = 0
	self.hide_tbl = {}
	local board = self.board
--	local sim = alife()
	local n = 0
	for k, v in pairs (board.smarts) do
		if v.smrt.actor_hides ~= nil then
			for kk, vv in pairs (v.smrt.actor_hides) do
				local obj = sim:object(vv)
				if obj then
					n = n + 1
					self.hide_tbl[n] = obj
				end
			end
		end
	end
end

function CHideFromSurgeTask:check_task(tm)

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 250

	local tbl = self.hide_tbl
	local nearest_cover_dist = 0
	local act = db.actor
	local gg, lid, act_pos = game_graph(), sim:level_id(), act:position()

	if gg:vertex(tbl[1].m_game_vertex_id):level_id() ~= lid then
		nearest_cover_dist = 10000
	else
		nearest_cover_dist = tbl[1].position:distance_to(act_pos)
	end

	local target, dist = tbl[1].id, 0
	for i = 2, #tbl do

		if gg:vertex(tbl[i].m_game_vertex_id):level_id() ~= lid then
			dist = 10000
		else
			dist = tbl[i].position:distance_to(act_pos)
		end

		if dist < nearest_cover_dist then
			nearest_cover_dist = dist
			target = tbl[i].id
		end
	end

	function blowout_hit_with_pp_and_cam_effectors(blowout_hit, cam_effector_id, pp_effector_id)
		xr_sound.set_sound_play(0, blowout_hit) -- 0 = actor ID
		level.add_cam_effector("camera_effects\\shell_shock.anm", cam_effector_id, false, "")
		level.add_pp_effector("snd_shock.ppe", pp_effector_id, false)
		level.set_pp_effector_factor(pp_effector_id, 0, 1.5)
	end

	function end_surge(last_check_task)
		self.last_check_task = last_check_task
		xr_surge_hide.surge_finished = true
		xr_surge_hide.start_surge = false
		xr_surge_hide.phase = 0
		xr_surge_hide.surge_activated = false
	end

	local t = self.t

	if t == nil then
		t = act and act:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CHideFromSurgeTask:check_task]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	if target ~= self.target then
		self.target = target
		t:change_map_location(self.spot, self.target)
	end

	local diff_sec = math_ceil(get_game_time():diffSec(self.inited_time) / level.get_time_factor())
	local surge_time = self.wait_time / 10 - 40

	if diff_sec >= surge_time then
		local _delta = global_time - self.effector_started_time
		if(self.effector_started_time==-1) then
			level.set_weather_fx("fx_surge_day_3")
			level.add_pp_effector("blink.ppe", 200210, false)
			level.add_pp_effector("snd_shock.ppe", 200208, true)
			level.set_pp_effector_factor(200208, 0, 10)
			self.effector_started_time = 0
		elseif(self.effector_started_time==0) then
			self.effector_started_time = global_time
			level.set_pp_effector_factor(200208, 1, 0.0075)
			level.add_cam_effector("camera_effects\\earthquake.anm", 200209, true, "")
			xr_sound.play_sound_looped(0, "surge_earthquake_sound") -- 0 = actor ID
		elseif not(self.disable_ui) and (_delta>=15000) then
			level.set_weather("[default]", false)
			xr_surge_hide.weather_surge = true
			xr_surge_hide.start_surge = false
			local sr = db.storage[self.target]
			if not(sr and sr.object:inside(act_pos)) then
				xr_effects.disable_ui(act)
				level.add_pp_effector("mar_surge.ppe", 200211, false)
			end
			self:kill_unhided_npc()
			self.disable_ui = true
		elseif not(self.kill_em_all) and (_delta>=20000) then
			self.kill_em_all = true
			local sr = db.storage[self.target]
			if not(sr and sr.object:inside(act_pos)) then
				if level.name()=="marsh" or level.name()=="marsh_nvidia" then
					level.remove_pp_effector(200208)
					level.remove_cam_effector(200209)
					xr_sound.stop_sound_looped(0) -- 0 = actor ID
					end_surge("reversed")
				else
					act:kill(act)
					end_surge("fail")
				end
			end
		elseif(_delta>=35000) then
			xr_effects.enable_ui()
			level.remove_pp_effector(200208)
			xr_sound.stop_sound_looped(0) -- 0 = actor ID
			end_surge("complete")
		elseif(_delta>=32500) then
			level.remove_cam_effector(200209)
			level.add_cam_effector("camera_effects\\earthquake.anm", 200209, false, "")
			level.set_pp_effector_factor(200208, 0.001, 0.8)
		end
	elseif(diff_sec==7) and (surge_time>13) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_1", 20080502, 20080402)
	elseif(diff_sec==13) and (surge_time>19) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_2", 20080503, 20080403)
	elseif(diff_sec==19) and (surge_time>31) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_3", 20080504, 20080404)
		level.set_weather_fx("fx_surge_day_2")
	elseif(diff_sec==31) and (surge_time>35) then
		blowout_hit_with_pp_and_cam_effectors("blowout_hit_1", 20080505, 20080405)
	elseif(diff_sec==35) and (surge_time>39) then
		blowout_hit_with_pp_and_cam_effectors("blowout_hit_2", 20080506, 20080406)
	elseif(diff_sec==39) and (surge_time>44) then
		blowout_hit_with_pp_and_cam_effectors("blowout_hit_1", 20080507, 20080407)
	elseif(diff_sec==44) and (surge_time>57) then
		blowout_hit_with_pp_and_cam_effectors("blowout_hit_3", 20080511, 20080411)
		level.add_pp_effector("agr_u_fade.ppe", 20080601, false)
		xr_surge_hide.phase = 4
	elseif(diff_sec==57) and (surge_time>65) then
		xr_surge_hide.phase = 5
	elseif(diff_sec==65) and (surge_time>71) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_1", 20080508, 20080408)
	elseif(diff_sec==71) and (surge_time>77) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_2", 20080509, 20080409)
	elseif(diff_sec==77) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_3", 20080510, 20080410)
	end

	function blowout_hit_with_pp_and_cam_effectors(blowout_hit, cam_effector_id, pp_effector_id)
		xr_sound.set_sound_play(0, blowout_hit) -- 0 = actor ID
		level.add_cam_effector("camera_effects\\shell_shock.anm", cam_effector_id, false, "")
		level.add_pp_effector("snd_shock.ppe", pp_effector_id, false)
		level.set_pp_effector_factor(pp_effector_id, 0, 1.5)
	end

	function end_surge(last_check_task)
		self.last_check_task = last_check_task
		xr_surge_hide.surge_finished = true
		xr_surge_hide.start_surge = false
		xr_surge_hide.phase = 0
		xr_surge_hide.surge_activated = false
	end

	if (self.blowout_rumble_level < 1) and (xr_surge_hide.phase > 1) and (xr_surge_hide.phase < 4 or xr_surge_hide.phase == 5) then
		self.blowout_rumble_level = self.blowout_rumble_level + 0.015
		xr_sound.set_volume_sound_looped(0, "blowout_rumble", self.blowout_rumble_level) -- 0 = actor ID
	elseif self.blowout_rumble_level > 0 and xr_surge_hide.phase == 4 then
		self.blowout_rumble_level = self.blowout_rumble_level - 0.11
		xr_sound.set_volume_sound_looped(0, "blowout_rumble", self.blowout_rumble_level) -- 0 = actor ID
	end

	local stt = db.storage[self.target]
	if stt and stt.object:inside(act_pos) then
		if self.name == "hide_from_surge_name" then
			t:set_title(trans("hide_from_surge_name2"))
		end
	else
		if self.name == "hide_from_surge_name" then
			t:set_title(trans("hide_from_surge_name"))
		end
	end
end

function CHideFromSurgeTask:give_task(community)
	xr_sound.play_sound_looped(0, "blowout_rumble") -- 0 = actor ID
	xr_sound.set_volume_sound_looped(0, "blowout_rumble", self.blowout_rumble_level) -- 0 = actor ID
	task_objects.CGeneralTask.give_task(self, community)
end

function CHideFromSurgeTask:kill_unhided_npc()
	local h = hit()
	h.type = hit.fire_wound
	h.power = 0.9
	h.impulse = 0
	h.direction = vector():set(0, 0, 1)
	h.draftsman = db.actor
	for k, crow in pairs (bind_crow.crow_storage) do
		if crow then
			if crow:alive() then
				crow:hit(h)
			end
		end
	end
	--[[
	local npc
	for k, v in pairs (db.storage) do
		npc = v.object
		if npc then
			if npc:clsid() == clsid.script_stalker then
				if npc:alive() then
					-- if not db.storage[k].active_scheme == "surge_hide" then--and not npc:story_id() then
						npc:kill(npc)
					-- end
				end
			end
		end
	end
	]]
end

function CHideFromSurgeTask:save(package)

	set_save_marker(package, "save", false, "CHideFromSurgeTask")

	task_objects.CGeneralTask.save(self, package)

	if self.target ~= nil then
		package:w_u16(self.target)
	else
		package:w_u16(-1)
	end

	if self.wait_time ~= nil then
		package:w_u16(self.wait_time)
	else
		package:w_u16(-1)
	end

	if self.effector_started_time == -1 or self.effector_started_time == 0 then
		package:w_s16(self.effector_started_time)
	else
		package:w_s16(time_global() - self.effector_started_time)
	end

	set_save_marker(package, "save", true, "CHideFromSurgeTask")
end

function CHideFromSurgeTask:load(reader)

	set_save_marker(reader, "load", false, "CHideFromSurgeTask")

	task_objects.CGeneralTask.load(self, reader)

	local val = reader:r_u16()
	if val ~= 65535 then
		self.target = val
	end

	val = reader:r_u16()
	if val ~= 65535 then
		self.wait_time = val
	end

	self.hide_tbl = {}

--	local sim = alife()
	local n = 0

	for k, v in pairs (self.board.smarts) do
		if v.smrt.actor_hides ~= nil then
			for kk, vv in pairs (v.smrt.actor_hides) do
				n = n + 1
				self.hide_tbl[n] = sim:object(vv)
			end
		end
	end

	local t = reader:r_s16()
	if t == 0 or t == -1 then
		self.effector_started_time = t
	else
		self.effector_started_time = time_global() + t
	end

	self.blowout_rumble_level = 0

	set_save_marker(reader, "load", true, "CHideFromSurgeTask")
end
--[=[
------------------------------------------------------------------------------------------------

class "CEliminateSquadTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CEliminateSquadTask:__init(task_ini, id, type) super (task_ini, id, type)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "true"))
	self.src_obj = nil
end

function CEliminateSquadTask:check_target(squad, faction)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

	return xr_logic.pick_section_from_condlist(db.actor, squad, self.target_cond) == "true"
end

function CEliminateSquadTask:init_task(squad, faction)
	self.target = squad.commander_id
	self.target_obj = squad.squad_id
	self.id	= self.id .. "_" .. squad.squad_id
	self.community = faction
	self.prior = self.base_prior
end

function CEliminateSquadTask:get_inited_task(squad, faction, entity_id)
	local task = CEliminateSquadTask(self.task_ini, self.base_id, self.type)
	task:init_task(squad, faction)
	task.entity_id = entity_id
	return task
end

function CEliminateSquadTask:check_task(tm)

	if self.last_check_task ~= nil then
		return
	end

	if self.board.squads[self.target_obj] == nil then
		self.last_check_task = "complete"
	end
end

function CEliminateSquadTask:give_task(community)
	task_objects.CGeneralTask.give_task(self, community)
end

function CEliminateSquadTask:deactivate_task(_task)
	task_objects.CGeneralTask.deactivate_task(self, _task)
--	task_manager.get_task_manager():unregister_faction_task(self.community, self)
	if self.src_obj ~= nil then
		local squad_obj = self.board.squads[self.src_obj]
		if squad_obj ~= nil then
			for k, v in pairs (squad_obj.random_tasks) do
				if v == self.entity_id then
					squad_obj.random_tasks[k] = nil
				end
			end
		end
	end
end

function CEliminateSquadTask:save(package)
	set_save_marker(package, "save", false, "CEliminateSquadTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	package:w_stringZ(tostring(self.src_obj))
	set_save_marker(package, "save", true, "CEliminateSquadTask")
end

function CEliminateSquadTask:load(reader)
	set_save_marker(reader, "load", false, "CEliminateSquadTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	self.id	= self.id.."_"..self.target
	self.src_obj = reader:r_stringZ()
	if self.src_obj == "nil" then
		self.src_obj = nil
	end
	set_save_marker(reader, "load", true, "CEliminateSquadTask")
end
]=]
------------------------------------------------------------------------------------------------

class "CFindUpgradeTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CFindUpgradeTask:__init(task_ini, id, type) super (task_ini, id, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, id, "target_cond", nil, false, "", "false"))
	self.requested_item = utils.cfg_get_string(task_ini, id, "requested_item", nil, false, "")
	self.requested_item_inv_name = trans(system_ini():r_string(self.requested_item, "inv_name"))
	local cost = utils.cfg_get_number(task_ini, id, "cost", nil, true)
	local sss = utils.cfg_get_string(task_ini, id, "reward_upgr", nil, false, "")
	if sss ~= nil then
--		local char_ini = ini_file("item_upgrades.ltx")
		local sss_table = utils.parse_names(sss)
		local name_item = trans(system_ini():r_string(sss_table[1], "inv_name"))
		local name_apgr = trans(self.name)
		self.item_for_reward = name_item..". "..name_apgr..": "..tostring(cost).." "..trans("st_rubles")
	end
	self.cost = cost
end

function CFindUpgradeTask:check_target(npc, faction) -- called 1st (not on load)

	local TGT = self.faction_target

	if TGT ~= nil then
		if TGT ~= faction then
			return false
		end
	end

	return xr_logic.pick_section_from_condlist(db.actor, db.storage[npc:id()].object, self.target_cond) == "true"
end

function CFindUpgradeTask:get_inited_task(npc, faction, entity_id) -- called 2nd (not on load)
	local task = CFindUpgradeTask(self.task_ini, self.base_id, self.type) -- calls CGeneralTask:__init() and CFindUpgradeTask:__init()
	task:init_task(npc)
	task.entity_id = entity_id
	return task
end
--[[
local function get_inventory_find_upgrade_count(task, item)
	if task.requested_item == item:section() then
		if not task.presence_requested_item then
			task.presence_requested_item = true
			return
		end
	end
end
]]
function CFindUpgradeTask:init_task(npc) -- called 4th (not on load)
	self.target = npc:id()
--	self.description = ""
--	self.npc = nil
--	self.presence_requested_item = false
	self.state = "started"
--	db.actor:iterate_inventory(get_inventory_find_upgrade_count, self)
end

function CFindUpgradeTask:give_task(community) -- called 5th (not on load)
	task_objects.CGeneralTask.give_task(self, community)
end

function CFindUpgradeTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 250

	local actor = db.actor

	if actor == nil then
		return
	end

	local tasker_id = self.target -- self.target set by CFindUpgradeTask:init_task() or CRecoverItemTask:load(), guaranteed valid
	local tasker = sim:object(tasker_id)

	-- If tasker doesn't exist or is dead, cancel:
	if not tasker or not tasker:alive() then
		self.last_check_task = "reversed"
		return
	end

	tasker = db.storage[tasker_id]
	tasker = tasker and tasker.object

	-- If tasker is hostile, cancel:
	if tasker then
		if tasker:general_goodwill(actor) <= -1000 then
			self.last_check_task = "reversed"
			return
		end
	end

	if self:has_requested_item(actor) then
		self.state = "have_item"
	else
		self.state = "started"
	end

	for k, condlist in pairs (self.condlist) do
		local status = xr_logic.pick_section_from_condlist(actor, actor, condlist)
		if status ~= nil then
			if valid_values[status] ~= true then
				abort("[task_objects.CFindUpgradeTask:check_task]: Invalid task status '%s' for task '%s'.", tostring(status), tostring(self.name))
			end
			self.last_check_task = status
			return
		end
	end
end
--[[
function CFindUpgradeTask:finish_task()
	self.last_check_task = "complete"
end
]]
function CFindUpgradeTask:has_requested_item(actor)

	local t = self.t

	if t == nil then
		t = actor:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CFindUpgradeTask:has_requested_item]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	local has_requested_item = false
	local s = ""

	if actor:object(self.requested_item) ~= nil then
		s = "+ "
		has_requested_item = true
	else
		s = "- "
	end

	local description = self.text.."\\n"..s..self.requested_item_inv_name

	if self.auto_faction then
		t:set_description(self.community_name..".\\n"..description)
	else
		t:set_description(description)
	end

	return has_requested_item
end

function CFindUpgradeTask:transfer_items_looking_for(npc) -- called 7th
--	self.npc = npc
	dialogs.relocate_item_section(npc, self.requested_item, "out")
	dialogs.relocate_money(npc, self.cost, "in")
	self.state = "finished"
	self.last_check_task = "complete"
end

function CFindUpgradeTask:deactivate_task(_task) -- called 8th
	task_objects.CGeneralTask.deactivate_task(self, _task)
end

function CFindUpgradeTask:save(package)
	set_save_marker(package, "save", false, "CFindUpgradeTask")
	task_objects.CGeneralTask.save(self, package)
--[[
	local self_state = self.state
	if self_state == "started" then
		package:w_u8(1)
	elseif self_state == "have_item" then
		package:w_u8(2)
	elseif self_state == "finished" then
		package:w_u8(3)
	else
		abort("[task_objects.CFindUpgradeTask:save]: Tried to save an identifier for an invalid task state: '%s'. If a save file was created, it is corrupt.", tostring(self_state))
	end
	package:w_bool(self.presence_requested_item)
	package:w_stringZ(self.requested_item) -- read in CFindUpgradeTask:__init()
]]
	package:w_u16(self.target)
	set_save_marker(package, "save", true, "CFindUpgradeTask")
end

function CFindUpgradeTask:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CFindUpgradeTask")
	task_objects.CGeneralTask.load(self, reader)
--[[
	local state = reader:r_u8()
	if state == 1 then
		self.state = "started"
	elseif state == 2 then
		self.state = "have_item"
	elseif state == 3 then
		self.state = "finished"
	else
		abort("[task_objects.CFindUpgradeTask:load]: Tried to load an invalid task state identifier: '%s'. Your save file is corrupt.", tostring(state))
	end
	self.npc = nil
	self.presence_requested_item = reader:r_bool()
	self.requested_item = reader:r_stringZ() -- read in CFindUpgradeTask:__init()
]]
	self.target = reader:r_u16()
	set_save_marker(reader, "load", true, "CFindUpgradeTask")
end