local sim           = _G.sim
local get_game_time = game.get_game_time
local trans         = game.translate_string

local task_types =
{
	storyline     = 0,
	additional    = 1,
	insignificant = 2,
}

local valid_values =
{
	complete        = true,
	fail            = true,
	reversed        = true,
	reversed_silent = true,
}

local status_by_id =
{
	[0] = "normal",
	[1] = "selected",
	[2] = "completed",
	[3] = "fail",
	[4] = "reversed",
	[5] = "reversed_silent",
}

local id_by_status =
{
	normal          = 0,
	selected        = 1,
	completed       = 2,
	fail            = 3,
	reversed        = 4,
	reversed_silent = 5,
}

local id_by_community =
{
	csky          = 1,
	stalker       = 2,
	bandit        = 3,
	freedom       = 4,
	dolg          = 5,
	ecolog        = 6,
	killer        = 7,
	renegade      = 8,
	army          = 9,
	zombied       = 10,
	monolith      = 11,
	monster       = 12,
	none          = 13,
	actor         = 14,
	actor_csky    = 15,
	actor_stalker = 16,
	actor_bandit  = 17,
	actor_freedom = 18,
	actor_dolg    = 19,
	trader        = 20,
	["nil"]       = 21,
}

local community_by_id =
{
	[1]  = "csky",
	[2]  = "stalker",
	[3]  = "bandit",
	[4]  = "freedom",
	[5]  = "dolg",
	[6]  = "ecolog",
	[7]  = "killer",
	[8]  = "renegade",
	[9]  = "army",
	[10] = "zombied",
	[11] = "monolith",
	[12] = "monster",
	[13] = "none",
	[14] = "actor",
	[15] = "actor_csky",
	[16] = "actor_stalker",
	[17] = "actor_bandit",
	[18] = "actor_freedom",
	[19] = "actor_dolg",
	[20] = "trader",
	[21] = "nil",
}

local community_names =
{
	bandit  = "ui_st_name_bandit",
	csky    = "ui_st_name_csky",
	dolg    = "ui_st_name_dolg",
	freedom = "ui_st_name_freedom",
	stalker = "ui_st_name_stalker",
}

------------------------------------------------------------------------------------------------

class "CGeneralTask"

------------------------------------------------------------------------------------------------

function CGeneralTask:__init(task_ini, section, type)

	local get_string                       = utils.cfg_get_string
	local get_bool                         = utils.cfg_get_bool
	local get_number                       = utils.cfg_get_number
	local parse_condlist                   = xr_logic.parse_condlist

	self.task_ini                          = task_ini
	self.type                              = type
	self.task_type                         = task_types[get_string(task_ini, section, "task_type", nil, false, "", "additional")]
	self.section                           = section
	self.name                              = get_string(task_ini, section, "name", nil, false, "", tostring(section))
	self.icon                              = "ui_pda2_mtask_overlay"
	self.spot                              = get_string(task_ini, section, "spot", nil, false, "", nil)
	self.faction_target                    = get_string(task_ini, section, "faction", nil, false, "", nil)
	self.prior                             = get_number(task_ini, section, "prior", nil, false, 0)
	self.text                              = trans(get_string(task_ini, section, "text", nil, false, "", "NO_TEXT")) -- SRP: wrapped in trans()
	self.description                       = get_string(task_ini, section, "description", nil, false, "", "NO_TEXT")
	self.board                             = sim_board.get_sim_board()
	self.auto_name                         = get_bool(task_ini, section, "auto_name", nil, false, true)
	self.auto_faction                      = get_bool(task_ini, section, "auto_faction", nil, false, false)
	self.entity_id                         = nil
	self.support_attack                    = get_bool(task_ini, section, "support_attack", nil, false, true)
	self.play_regard                       = get_string(task_ini, section, "play_regard", nil, false, "", "")

	local i = 0
	local T = {}
	local param = "condlist_0"

	self.condlist = T

	while task_ini:line_exist(section, param) do
		T[i] = parse_condlist(nil, nil, nil, task_ini:r_string(section, param))
		i = i + 1
		param = "condlist_"..i
	end

	self.on_init                           = parse_condlist(nil, nil, nil, get_string(task_ini, section, "on_init", nil, false, "", ""))
	self.on_complete                       = parse_condlist(nil, nil, nil, get_string(task_ini, section, "on_complete", nil, false, "", ""))
	self.on_reversed                       = parse_condlist(nil, nil, nil, get_string(task_ini, section, "on_reversed", nil, false, "", ""))
	self.on_fail                           = parse_condlist(nil, nil, nil, get_string(task_ini, section, "on_fail", nil, false, "", ""))

	self.reward_money                      = parse_condlist(nil, nil, nil, get_string(task_ini, section, "reward_money", nil, false, "", ""))
	self.reward_item                       = parse_condlist(nil, nil, nil, get_string(task_ini, section, "reward_item", nil, false, "", ""))
	self.immediate_reward                  = get_bool(task_ini, section, "immediate_reward", nil, false, false)

	self.community_relation_delta_fail     = get_number(task_ini, section, "community_relation_delta_fail", nil, false, 0)
	self.community_relation_delta_complete = get_number(task_ini, section, "community_relation_delta_complete", nil, false, 0)

	self.status                            = "normal"
	self.actor_helped                      = false
	self.check_time                        = 0
end

function CGeneralTask:give_task(community)

	self.actor_come = false
	self.actor_ignore = false
	self.community = community
	self.community_name = trans(community_names[community] or community)

	local t = CGameTask()
	local type = self.type

	if self.auto_name then
		local title = ""
		if (type == "eliminate_smart") or (type == "capture_smart") or (type == "defend_smart") or (type == "defend_smart_delay") then
			local sname = smart_names.get_smart_terrain_name(self.board.smarts[self.target].smrt)
			title = trans(self.name)..": "..sname
		elseif (type == "recover_item") then
			local item_inv_name = trans(system_ini():r_string(self.requested_item, "inv_name"))
			title = trans("sim_recover_item").." "..item_inv_name
		elseif (type == "find_upgrade") then
			title = trans("sim_find_upgrade").."."
		elseif (type == "bring_item") then
			title = "sim_bring_item"
		else
			title = trans(self.name)
		end
		t:set_title(title)
	else
		t:set_title(self.name)
	end

	if (type == "eliminate_smart") or (type == "capture_smart") or (type == "defend_smart") or (type == "defend_smart_delay") then
		task_manager.get_task_manager().tasks_by_smarts[self.target] = self
	end

	t:set_id(tostring(self.entity_id))
	t:set_type(self.task_type)
	t:set_priority(self.prior)
	t:set_icon_name(self.icon)

	if (type == "take_reward") then
		t:set_description("")
	else
		if self.auto_faction then
			t:set_description(self.community_name..".\\n"..self.text)
		else
			t:set_description(self.text)
		end
	end

	t:add_complete_func("task_manager.task_complete")
	t:add_fail_func("task_manager.task_fail")

	local actor = db.actor

	xr_logic.pick_section_from_condlist(actor, actor, self.on_init)

	local time = self.wait_time or 0

	if self.spot == nil then
		if (type == "storyline") then
			if (self.task_type == task_types.storyline) then
				self.spot = "primary_task_location"
			else
				self.spot = "secondary_task_location"
			end
		else
			if (self.task_type == task_types.storyline) then
				self.spot = "primary_task_location"
			else
				if time == 0 then
					if (type == "find_upgrade") then
						self.spot = "secondary_task_location_complex_"..self.requested_item
					else
						self.spot = "secondary_task_location_complex_"..type
					end
				else
					self.spot = "secondary_task_location_complex_timer"
				end
			end
		end
	end

	if self.target ~= nil then
		t:set_map_location(self.spot)
		t:set_map_object_id(self.target)
		if (type == "defend_smart") or (type == "defend_smart_delay") then
			level.map_add_object_spot(self.target, "ui_pda_long_blink_point_location", "")
		else
			if (type ~= "storyline") and (self.task_type ~= task_types.storyline) then
				level.map_add_object_spot(self.target, "ui_pda_short_blink_point_location", "")
			end
		end
	end

	self.status = "selected"
	self.inited_time = get_game_time()
	task_manager.get_task_manager().task_info[tostring(self.entity_id)] = self
	actor:give_task(t, time * 10, false, time)
	self.t = t

	if not self.is_task_update then
		xr_statistic.inc_recieved_quests_counter()
	end
end

function CGeneralTask:check_task(tm)

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local actor = db.actor

	for _, condlist in pairs (self.condlist) do
		local status = xr_logic.pick_section_from_condlist(actor, actor, condlist)
		if status ~= nil then
			if not valid_values[status] then
				abort("[task_objects.CGeneralTask:check_task]: Invalid task status '%s' for task '%s'.", tostring(status), tostring(self.name))
			end
			self.last_check_task = status
			break
		end
	end
end

function CGeneralTask:actor_hit(faction_name)
	if faction_name ~= self.community then
		self.actor_helped = true
	end
end

function CGeneralTask:actor_comed()
end

function CGeneralTask:init_reward()

	if self.community == nil then -- moved this below on_complete effect check to ensure effects happen even if task given by no faction
		return
	end

	local tm = task_manager.get_task_manager()
	local is_reward = false
	local actor = db.actor

	local money = xr_logic.pick_section_from_condlist(actor, actor, self.reward_money)
	local items = xr_logic.pick_section_from_condlist(actor, actor, self.reward_item)

	if not self.immediate_reward then

		if tm.rewards[self.community] == nil then
			tm.rewards[self.community] = {}
		end

		if money ~= nil then

			if type(money) == "table" then
				abort("[task_objects.CGeneralTask:init_reward]: init_reward:task_id = "..tostring(self.id))
			end

			table.insert(tm.rewards[self.community], {money = tonumber(money)})

			is_reward = true
		end

		if items ~= nil then

			for k, v in pairs (utils.parse_names(items)) do
				table.insert(tm.rewards[self.community], {item = v})
			end

			is_reward = true
		end
	else
		if money ~= nil then

			if type(money) == "table" then
				abort("[task_objects.CGeneralTask:init_reward]: init_reward:task_id = "..tostring(self.id))
			end

			dialogs.relocate_money(nil, tonumber(money), "in")
		end

		if items ~= nil then

			local ancillary_item_table = {}

			for k, v in pairs (utils.parse_names(items)) do
				if ancillary_item_table[v] == nil then
					ancillary_item_table[v] = 1
				else
					ancillary_item_table[v] = ancillary_item_table[v] + 1
				end
			end

			for k, v in pairs (ancillary_item_table) do
				dialogs.relocate_item_section(nil, k, "in", v)
			end
		end
	end

	if not is_reward then
		return
	end

	local rewarder_id = tm.rewarders[self.community]

	if rewarder_id == nil then
		return
	end

	local reward_task = tm:select_task("take_reward", rewarder_id, self.community)

	if reward_task.status == "normal" then
		reward_task:give_task(self.community)
	end

	reward_task:change_description(tm)
end

function CGeneralTask:deactivate_task()
	self.last_check_task = nil
	self.status = "normal"
end

function CGeneralTask:save(package)

	set_save_marker(package, "save", false, "CGeneralTask")

	package:w_u16(self.entity_id or -1)
	package:w_u8(self.prior)
	package:w_u8(id_by_status[self.status])
	package:w_bool(self.actor_helped)

	if self.community ~= nil then
		local community_id = id_by_community[tostring(self.community)]
		if community_id == nil then
			abort("[task_objects.CGeneralTask:save]: No registered faction identifier exists for faction with name: '%s'. If a save file was created, it is corrupt.", tostring(self.community))
		end
		package:w_u8(community_id)
	else
		package:w_u8(0)
	end

	package:w_bool(self.actor_come == true)
--	package:w_bool(self.actor_ignore == true)

	utils.w_CTime(package, self.inited_time)

	set_save_marker(package, "save", true, "CGeneralTask")
end

function CGeneralTask:load(reader)

	set_save_marker(reader, "load", false, "CGeneralTask")

	local entity_id = reader:r_u16()

	if entity_id == 65535 then
		self.entity_id = nil
	else
		self.entity_id = entity_id
	end

	self.prior = reader:r_u8()
	self.status = status_by_id[reader:r_u8()]
	self.actor_helped = reader:r_bool()

	local faction_id = reader:r_u8()
	local community = faction_id == 0 and "nil" or community_by_id[faction_id]

	if community == nil then
		abort("[task_objects.CGeneralTask:load]: Tried to load an unregistered faction identifier: '%s'. Your save file is corrupt.", tostring(faction_id))
	end

	self.community = community
	self.community_name = trans(community_names[community] or community)
	self.actor_come = reader:r_bool()
--	self.actor_ignore = reader:r_bool()
	self.inited_time = utils.r_CTime(reader)

	set_save_marker(reader, "load", true, "CGeneralTask")
end

------------------------------------------------------------------------------------------------

class "CEliminateSmartTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CEliminateSmartTask:__init(task_ini, section, type) super(task_ini, section, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "true"))
end

function CEliminateSmartTask:check_target(smart, faction) -- called 1st (not on load)
	if self.faction_target and self.faction_target ~= faction then
		return false
	end
	return xr_logic.pick_section_from_condlist(db.actor, smart, self.target_cond) == "true"
end

function CEliminateSmartTask:get_inited_task(smart, entity_id) -- called 2nd (not on load)
	local task = CEliminateSmartTask(self.task_ini, self.section, self.type) -- calls CGeneralTask:__init() and CEliminateSmartTask:__init()
	task:init_task(smart)
	task.entity_id = entity_id
	return task
end

function CEliminateSmartTask:init_task(smart) -- called 4th (not on load)
	self.target = smart.id -- smart to eliminate
end

function CEliminateSmartTask:give_task(community) -- called 5th (not on load)
	task_objects.CGeneralTask.give_task(self, community)
end

function CEliminateSmartTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local target_owner = self.board.smarts[self.target].smrt.player_name

	if target_owner == "none" or target_owner == self.community then
		if self.actor_helped then
			if self.play_regard == "" then
				for _, ally_squad in pairs (self.board.smarts[self.target].squads) do
					ally_squad:issue_order("defend_actor_help")
					break
				end
			end
			self.last_check_task = "complete"
		else
			self.last_check_task = "reversed"
		end
	end
end

function CEliminateSmartTask:deactivate_task() -- called 7th

	if self.last_check_task ~= "reversed_silent" then
		self.board.smarts[self.target].smrt.combat_manager.combat_quest = "nil" -- SRP
	end

	task_objects.CGeneralTask.deactivate_task(self)

	local faction = self.board.players[self.community]

	if faction ~= nil then
		faction.random_tasks[self.target] = nil
	end
end

function CEliminateSmartTask:save(package)
	set_save_marker(package, "save", false, "CEliminateSmartTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	set_save_marker(package, "save", true, "CEliminateSmartTask")
end

function CEliminateSmartTask:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CEliminateSmartTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	set_save_marker(reader, "load", true, "CEliminateSmartTask")
end

------------------------------------------------------------------------------------------------

class "CCaptureSmartTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CCaptureSmartTask:__init(task_ini, section, type) super(task_ini, section, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "true"))
	self.counter_attack = utils.cfg_get_bool(task_ini, section, "counter_attack", nil, false, true)
	self.src_obj = nil
end

function CCaptureSmartTask:check_target(smart, faction) -- called 1st (not on load)
	if self.faction_target and self.faction_target ~= faction then
		return false
	end
	return xr_logic.pick_section_from_condlist(db.actor, smart, self.target_cond) == "true"
end

function CCaptureSmartTask:get_inited_task(smart, entity_id) -- called 2nd (not on load)
	local task = CCaptureSmartTask(self.task_ini, self.section, self.type) -- calls CGeneralTask:__init() and CCaptureSmartTask:__init()
	task:init_task(smart)
	task.entity_id = entity_id
	return task
end

function CCaptureSmartTask:init_task(smart) -- called 4th (not on load)
	self.target = smart.id -- smart to capture
end

function CCaptureSmartTask:give_task(community) -- called 5th (not on load)

	if self.src_obj ~= nil then
		local squad = self.board.squads[self.src_obj]
		if squad ~= nil then
			local current_task = task_manager.get_task_manager().tasks_by_smarts[self.target]
			if current_task ~= nil then
				if current_task.type == "eliminate_smart" then
					self.is_task_update = true
					current_task.last_check_task = "reversed_silent"
				else
					current_task.last_check_task = "reversed"
				end
			end
			squad:clear_current_action()
		end
	end

	task_objects.CGeneralTask.give_task(self, community)

	self.state = "capture"
	self.ally_squad_id = nil -- SRP fix
	self.counter_squad = nil
	self.counter_attack_community = self.board.smarts[self.target].smrt.player_name
	self.counter_sound_started = false
	self.last_called_time = get_game_time() -- SRP fix
	self.title_changed_to_counter_attack = false
	self.title_changed_to_hold_position = false
end

function CCaptureSmartTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	self:check_title(self.state == "counter_attack")

	local target_obj = self.board.smarts[self.target].smrt

	if target_obj.player_name == self.community then
		if self.state == "counter_attack" then
			if not target_obj.combat_manager:point_under_attack() then
				if self.actor_helped then
					if self.play_regard == "" then
						for _, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
							ally_squad:issue_order("defend_actor_help")
							break
						end
					end
					self.last_check_task = "complete"
				else
--[[
					if self.play_regard == "" then
						for _, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
							xr_sound.set_sound_play(ally_squad.commander_id, "alife_point_captured", self.community, self.target)
							break
						end
					end
]]
					self.last_check_task = "reversed"
				end
			end
		else
			if self.counter_attack == true then
				if self.counter_attack_community ~= nil and self.counter_attack_community ~= "none" then
					if self.board.players[self.counter_attack_community].brain.use_counter_attack == true then

						if self.ally_squad_id == nil then -- SRP fix
							for _, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
								self.ally_squad_id = ally_squad.squad_id -- SRP fix
								break
							end
						end

						if self.counter_sound_started ~= true then
							local ally_squad = self.board.squads[self.ally_squad_id] -- SRP fix
							if ally_squad then -- SRP fix
								ally_squad.sound_manager:set_storyteller(ally_squad.commander_id)
								ally_squad.sound_manager:set_story("squad_"..self.counter_attack_community.."_counter_attack")
							end
							self.counter_sound_started = true
							self.last_called_time = get_game_time() -- SRP fix
							return
						end

						if get_game_time():diffSec(self.last_called_time) <= 150 then -- SRP fix
							local ally_squad = self.ally_squad_id and self.board.squads[self.ally_squad_id] -- SRP fix
							if ally_squad then -- SRP fix
								if not ally_squad.sound_manager:is_finished() then
									return
								end
							end
						end

						for neighbor_smart_id in pairs (self.board:get_nearest_smarts(target_obj)) do
							for neighbor_squad_id, neighbor_squad in pairs (self.board.smarts[neighbor_smart_id].squads) do
								if self.counter_attack_community == neighbor_squad.player_id then
									local neighbor_script_target = neighbor_squad:get_script_target()
									if not neighbor_script_target or neighbor_script_target == target_obj.id then -- SRP fix
										local ally_squad = self.ally_squad_id and self.board.squads[self.ally_squad_id] -- SRP fix
										if ally_squad then -- SRP fix
											ally_squad.sound_manager:set_story("squad_"..self.counter_attack_community.."_counter_launched")
										end
										neighbor_squad.current_action = sim_squad_generic.sim_attack_point(neighbor_squad, target_obj.id, true)
										neighbor_squad.current_action:make()
										self.state = "counter_attack"
										self.counter_squad = neighbor_squad_id
										return
									end
								end
							end
						end
					end
				end
			end

			if self.actor_helped then
				if self.play_regard == "" then
					for _, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
						ally_squad:issue_order("defend_actor_help")
						break
					end
				end
				self.last_check_task = "complete"
			else
--[[
				if self.play_regard == "" then
					for _, ally_squad in pairs (self.board.smarts[target_obj.id].squads) do
						xr_sound.set_sound_play(ally_squad.commander_id, "alife_point_captured", self.community, self.target)
						break
					end
				end
]]
				self.last_check_task = "reversed"
			end
		end
	end
end

function CCaptureSmartTask:check_title(is_counterattack)

	local t = self.t

	if t == nil then
		local actor = db.actor
		t = actor and actor:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CCaptureSmartTask:check_title]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	if is_counterattack then
		if not self.title_changed_to_counter_attack then
			local target_obj = self.board.smarts[self.target].smrt
			local sname = smart_names.get_smart_terrain_name(target_obj)
			local title = (string.gsub(trans("sim_repeal_counterattack"), "%p", ""))..": "..sname
			t:set_title(title)
			self.title_changed_to_counter_attack = true
		end
	else
		if not self.title_changed_to_hold_position then
			local target_obj = self.board.smarts[self.target].smrt
			if target_obj.player_name == "none" and self.board:actor_near_smart(target_obj) then
				local sname = smart_names.get_smart_terrain_name(target_obj)
				local title = trans("sim_capture_wait_smart")..": "..sname
				t:set_title(title)
				self.title_changed_to_hold_position = true
			end
		end
	end
end

function CCaptureSmartTask:deactivate_task() -- called 7th

	if self.last_check_task ~= "reversed_silent" then
		self.board.smarts[self.target].smrt.combat_manager.combat_quest = "nil" -- SRP
	end

	task_objects.CGeneralTask.deactivate_task(self)

	if self.src_obj ~= nil then
		local squad_obj = self.board.squads[self.src_obj]
		if squad_obj ~= nil then
			for k, v in pairs (squad_obj.random_tasks) do
				if v == self.entity_id then
					squad_obj.random_tasks[k] = nil
				end
			end
		end
	end

	local faction = self.board.players[self.community]

	if faction ~= nil then
		faction.random_tasks[self.target] = nil
	end
end

function CCaptureSmartTask:save(package)

	set_save_marker(package, "save", false, "CCaptureSmartTask")

	task_objects.CGeneralTask.save(self, package)

	package:w_u16(self.target)

	local state = self.state

	if state == nil then
		package:w_u8(0)
	elseif state == "capture" then
		package:w_u8(1)
	elseif state == "counter_attack" then
		package:w_u8(2)
	else
		abort("[task_objects.CCaptureSmartTask:save]: Tried to save an identifier for an invalid task state: '%s'. If a save file was created, it is corrupt.", tostring(state))
	end

	local counter_community = self.counter_attack_community

	if counter_community == nil then
		package:w_u8(0)
	else
		local community_id = id_by_community[tostring(counter_community)]
		if community_id == nil then
			abort("[task_objects.CCaptureSmartTask:save]: No registered faction identifier exists for counter-attack faction with name: '%s'. If a save file was created, it is corrupt.", tostring(counter_community))
		end
		package:w_u8(community_id)
	end

	package:w_bool(self.counter_sound_started == true)
	package:w_stringZ(tostring(self.ally_squad_id)) -- SRP fix
	package:w_stringZ(tostring(self.counter_squad))
	package:w_stringZ(tostring(self.src_obj))

	utils.w_CTime(package, self.last_called_time) -- SRP fix

	set_save_marker(package, "save", true, "CCaptureSmartTask")
end

function CCaptureSmartTask:load(reader) -- called 0.5th (only on load)

	set_save_marker(reader, "load", false, "CCaptureSmartTask")

	task_objects.CGeneralTask.load(self, reader)

	self.target = reader:r_u16()

	local state_id = reader:r_u8()

	if state_id == 0 then
		self.state = nil
	elseif state_id == 1 then
		self.state = "capture"
	elseif state_id == 2 then
		self.state = "counter_attack"
	else
		abort("[task_objects.CCaptureSmartTask:load]: Tried to load an invalid task state identifier: '%s'. Your save file is corrupt.", tostring(state_id))
	end

	local counter_id = reader:r_u8()

	if counter_id ~= 0 then
		local community = community_by_id[counter_id]
		if community == nil then
			abort("[task_objects.CCaptureSmartTask:load]: Tried to load an unregistered counter-attack faction identifier: '%s'. Your save file is corrupt.", tostring(counter_id))
		end
		self.counter_attack_community = community
	end

	self.counter_sound_started = reader:r_bool()

	self.ally_squad_id = reader:r_stringZ() -- SRP fix
	if self.ally_squad_id == "nil" then
		self.ally_squad_id = nil
	end

	self.counter_squad = reader:r_stringZ()
	if self.counter_squad == "nil" then
		self.counter_squad = nil
	end

	self.src_obj = reader:r_stringZ()
	if self.src_obj == "nil" then
		self.src_obj = nil
	end

	self.last_called_time = utils.r_CTime(reader) -- SRP fix

	set_save_marker(reader, "load", true, "CCaptureSmartTask")
end

------------------------------------------------------------------------------------------------

class "CDefendSmartTask" (task_objects.CGeneralTask) -- 'Help' task

------------------------------------------------------------------------------------------------

function CDefendSmartTask:__init(task_ini, section, type) super(task_ini, section, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "true"))
	local time = utils.cfg_get_number(task_ini, section, "wait_time", nil, false, 15)
	self.wait_time = (time ~= -1) and (60 * time) or nil
end

function CDefendSmartTask:check_target(smart, faction) -- called 1st (not on load)
	if self.faction_target and self.faction_target ~= faction then
		return false
	end
	return xr_logic.pick_section_from_condlist(db.actor, smart, self.target_cond) == "true"
end

function CDefendSmartTask:get_inited_task(smart, entity_id) -- called 2nd (not on load)
	local task = CDefendSmartTask(self.task_ini, self.section, self.type) -- calls CGeneralTask:__init() and CDefendSmartTask:__init()
	task:init_task(smart)
	task.entity_id = entity_id
	return task
end

function CDefendSmartTask:init_task(smart) -- called 4th (not on load)
	self.target = smart.id -- smart to defend
end

function CDefendSmartTask:give_task(community) -- called 5th (not on load)

	task_objects.CGeneralTask.give_task(self, community)

	local enemy_squad = self.board.squads[self.src_squad_id]

	if enemy_squad and self.play_regard == "" then
		for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
			defender_squad:issue_order("defend_sos_"..enemy_squad.player_id)
			break
		end
	end

	self.last_called_time = get_game_time()
end

function CDefendSmartTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local target_obj = self.board.smarts[self.target].smrt

	if target_obj.player_name ~= self.community then
		if self.actor_come or get_game_time():diffSec(self.inited_time) > self.wait_time then
			self.last_check_task = "fail"
		else
			self.last_check_task = "reversed"
		end
		return
	end

	if not target_obj.combat_manager:point_under_attack() then
		if self.actor_helped then
			if self.play_regard == "" then
				for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
					defender_squad:issue_order("defend_actor_help")
					break
				end
			end
			self.last_check_task = "complete"
		else
			self.last_check_task = "reversed"
		end
		return
	end

	if not self.actor_come then
		if self.actor_helped then
			self:actor_comed(target_obj.combat_manager)
		else
			local game_time = get_game_time()
			if self.wait_time ~= nil and game_time:diffSec(self.inited_time) > self.wait_time then
				self:actor_ignored(target_obj.combat_manager)
				self.last_called_time = game_time
			elseif game_time:diffSec(self.last_called_time) > 50 then
				if self.play_regard == "" then
					for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
						defender_squad:issue_order("defend_wait")
						break
					end
				end
				self.last_called_time = game_time
			end
		end
	end
end

function CDefendSmartTask:actor_comed(target_obj_combat_manager)
	if not self.actor_come then
		self.actor_come = true
		if self.play_regard == "" then
			for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
				defender_squad:issue_order("defend_actor_come")
				break
			end
		end
		target_obj_combat_manager:request_squad_stage(nil, "combat")
	end
end

function CDefendSmartTask:actor_ignored(target_obj_combat_manager)
	if not self.actor_ignore then
		self.actor_ignore = true
--[[
		-- GSC didn't include ignore sounds so this code won't do anything:

		if self.play_regard == "" then
			for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
				defender_squad:issue_order("defend_actor_ignore")
				break
			end
		end
]]
		target_obj_combat_manager:request_squad_stage(nil, "combat")
	end
end

function CDefendSmartTask:deactivate_task() -- called 7th
	task_objects.CGeneralTask.deactivate_task(self)
	local mgr = self.board.smarts[self.target].smrt.combat_manager
	mgr.combat_quest = "nil"
	mgr.task = nil
end

function CDefendSmartTask:save(package)
	set_save_marker(package, "save", false, "CDefendSmartTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	utils.w_CTime(package, self.last_called_time)
	set_save_marker(package, "save", true, "CDefendSmartTask")
end

function CDefendSmartTask:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CDefendSmartTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	self.last_called_time = utils.r_CTime(reader)
	set_save_marker(reader, "load", true, "CDefendSmartTask")
end

------------------------------------------------------------------------------------------------

class "CDefendSmartTaskDelay" (task_objects.CGeneralTask) -- 'Defend the camp' task

------------------------------------------------------------------------------------------------

function CDefendSmartTaskDelay:__init(task_ini, section, type) super(task_ini, section, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "true"))
	local time = utils.cfg_get_number(task_ini, section, "wait_time", nil, false, 15)
	self.wait_time = (time ~= -1) and (60 * time) or nil
end

function CDefendSmartTaskDelay:check_target(smart, faction) -- called 1st (not on load)
	if self.faction_target and self.faction_target ~= faction then
		return false
	end
	return xr_logic.pick_section_from_condlist(db.actor, smart, self.target_cond) == "true"
end

function CDefendSmartTaskDelay:get_inited_task(smart, entity_id) -- called 2nd (not on load)
	local task = CDefendSmartTaskDelay(self.task_ini, self.section, self.type) -- calls CGeneralTask:__init() and CDefendSmartTaskDelay:__init()
	task:init_task(smart)
	task.entity_id = entity_id
	return task
end

function CDefendSmartTaskDelay:init_task(smart) -- called 4th (not on load)
	self.target = smart.id -- smart to defend
end

function CDefendSmartTaskDelay:give_task(community) -- called 5th (not on load)

	task_objects.CGeneralTask.give_task(self, community)

	local enemy_squad = self.board.squads[self.src_squad_id]

	if enemy_squad and self.play_regard == "" then
		for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
			defender_squad:issue_order("defend_sos_"..enemy_squad.player_id)
			break
		end
	end

	self.last_called_time = get_game_time()
end

function CDefendSmartTaskDelay:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local target_obj = self.board.smarts[self.target].smrt

	if target_obj.player_name ~= self.community then
		if self.actor_come or get_game_time():diffSec(self.inited_time) > self.wait_time then
			self.last_check_task = "fail"
		else
			self.last_check_task = "reversed"
		end
		return
	end

	local enemy_squad = self.board.squads[self.src_squad_id]

	if enemy_squad == nil then
		if self.actor_helped then
			if self.play_regard == "" then
				for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
					defender_squad:issue_order("defend_actor_help")
					break
				end
			end
			self.last_check_task = "complete"
		else
			self.last_check_task = "reversed"
		end
		return
	end

	if not self.actor_come then
		if sim_combat.actor_come_to_point(target_obj) == true then
			self.actor_come = true
			if self.play_regard == "" then
				for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
					defender_squad:issue_order("defend_actor_come")
					break
				end
			end
		else
			if get_game_time():diffSec(self.last_called_time) > 50 then
				if self.play_regard == "" then
					for _, defender_squad in pairs (self.board.smarts[self.target].squads) do
						defender_squad:issue_order("defend_wait")
						break
					end
				end
				self.last_called_time = get_game_time()
			end
		end
	end

	if self.attack_launched ~= true then
		if self.actor_come or get_game_time():diffSec(self.inited_time) > self.wait_time then
			local enemy_action = enemy_squad.current_action
			if enemy_action ~= nil and enemy_action.name == "stay_point" then
				enemy_squad.current_action = sim_squad_generic.sim_attack_point(enemy_squad, self.target, true)
				enemy_squad.current_action:make()
				self.attack_launched = true
			end
		end
	end
end

function CDefendSmartTaskDelay:deactivate_task() -- called 7th
	task_objects.CGeneralTask.deactivate_task(self)
	self.board.smarts[self.target].smrt.combat_manager.combat_quest = "nil" -- SRP
	local enemy_squad = self.board.squads[self.src_squad_id]
	if enemy_squad then
		enemy_squad.delayed_attack_task = nil
	end
end

function CDefendSmartTaskDelay:save(package)
	set_save_marker(package, "save", false, "CDefendSmartTaskDelay")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	utils.w_CTime(package, self.last_called_time)
	package:w_stringZ(tostring(self.src_squad_id)) -- SRP
	set_save_marker(package, "save", true, "CDefendSmartTaskDelay")
end

function CDefendSmartTaskDelay:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CDefendSmartTaskDelay")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	self.last_called_time = utils.r_CTime(reader)
	self.src_squad_id = reader:r_stringZ() -- SRP
	set_save_marker(reader, "load", true, "CDefendSmartTaskDelay")
end

------------------------------------------------------------------------------------------------

class "CGetRewardTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CGetRewardTask:__init(task_ini, section, type) super(task_ini, section, type) -- called 0th (on load), 0th and 3rd (otherwise)
end

function CGetRewardTask:check_target(npc_id, faction) -- called 1st (not on load)
	if self.faction_target and self.faction_target ~= faction then
		return false
	end
	return true
end

function CGetRewardTask:get_inited_task(npc_id, entity_id) -- called 2nd (not on load)
	local task = CGetRewardTask(self.task_ini, self.section, self.type) -- calls CGeneralTask:__init() and CGetRewardTask:__init()
	task:init_task(npc_id)
	task.entity_id = entity_id
	return task
end

function CGetRewardTask:init_task(npc_id) -- called 4th (not on load)
	self.target = npc_id
end

function CGetRewardTask:change_description(tm) -- called 5th

	local amount_money = 0
	local ancillary_item_table = {}

	for k, reward in pairs (tm.rewards[self.community]) do
		if reward.money ~= nil then
			amount_money = amount_money + reward.money
		elseif reward.item ~= nil then
			if ancillary_item_table[reward.item] == nil then
				ancillary_item_table[reward.item] = 1
			else
				ancillary_item_table[reward.item] = ancillary_item_table[reward.item] + 1
			end
		end
	end

	local s = ""

	if amount_money ~= 0 then
		s = s.."\\n>"..tostring(amount_money).." RU"
	end

	local ammo_sections = ammo_section
	local ltx = system_ini()

	for k, v in pairs (ancillary_item_table) do
		local name = trans(ltx:r_string(k, "inv_name"))
		if ammo_sections[k] == true then
			local box_size = ltx:r_s32(k, "box_size")
			s = s.."\\n>"..name.." x"..v*box_size
		else
			if v == 1 then
				s = s.."\\n>"..name
			else
				s = s.."\\n>"..name.." x"..v
			end
		end
	end

	local t = self.t

	if t == nil then
		t = db.actor:get_task(tostring(self.entity_id), true) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CGetRewardTask:change_description]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	self.description = s

	if self.auto_faction then
		t:set_description(self.community_name..".\\n"..s)
	else
		t:set_description(s)
	end
end

function CGetRewardTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 50

	local actor = db.actor

	if actor == nil then
		return
	end

	if tm.rewards[self.community] == nil then
		self.last_check_task = "complete"
	end

	if #tm.rewards[self.community] == 0 then
		self.last_check_task = "complete"
	end

	local rewarder = sim:object(self.target)

	if not rewarder or not rewarder:alive() then
		self.last_check_task = "reversed"
		tm.rewards[self.community] = nil
		return
	end

	rewarder = db.storage[self.target]
	rewarder = rewarder and rewarder.object

	if rewarder and rewarder:general_goodwill(actor) <= -1000 then
		self.last_check_task = "reversed"
		tm.rewards[self.community] = nil
		return
	end

	for _, condlist in pairs (self.condlist) do
		local status = xr_logic.pick_section_from_condlist(actor, actor, condlist)
		if status ~= nil then
			if not valid_values[status] then
				abort("[task_objects.CGetRewardTask:check_task]: Invalid task status '%s' for task '%s'.", tostring(status), tostring(self.name))
			end
			self.last_check_task = status
			break
		end
	end
end

function CGetRewardTask:init_reward() -- called 7th
end

function CGetRewardTask:deactivate_task() -- called 8th
	task_objects.CGeneralTask.deactivate_task(self)
end

function CGetRewardTask:save(package)
	set_save_marker(package, "save", false, "CGetRewardTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	set_save_marker(package, "save", true, "CGetRewardTask")
end

function CGetRewardTask:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CGetRewardTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	set_save_marker(reader, "load", true, "CGetRewardTask")
end

------------------------------------------------------------------------------------------------

class "CStorylineTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CStorylineTask:__init(task_ini, section, type) super(task_ini, section, type)
	self.target_story_ids = utils.cfg_get_string(task_ini, section, "target_story_ids", nil, true, "")
end

function CStorylineTask:check_target(task_name)
	return self.section == task_name
end

function CStorylineTask:get_inited_task(obj, entity_id)

	local sid = tonumber(self.target_story_ids)

	if sid then
		self.target = id_by_sid(sid)
	else
		local gulag = nil
		local param1, param2 = utils.parse_target(self.target_story_ids)
		if param2 then
			gulag = xr_gulag.get_gulag_by_name(param2)
		end
		if gulag == nil then
			abort("[task_objects.CStorylineTask:get_inited_task]: Target job is nil.")
		end
		self.target = gulag:idNPCOnJob(param1)
	end

	if self.target == nil then
		abort("[task_objects.CStorylineTask:get_inited_task]: Storyline task target with story ID '%s' does not exist.", tostring(self.target_story_ids))
	end

	self.entity_id = entity_id

	return self
end

function CStorylineTask:save(package)
	set_save_marker(package, "save", false, "CStorylineTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u32(self.target)
	set_save_marker(package, "save", true, "CStorylineTask")
end

function CStorylineTask:load(reader)
	set_save_marker(reader, "load", false, "CStorylineTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u32()
	set_save_marker(reader, "load", true, "CStorylineTask")
end

------------------------------------------------------------------------------------------------

class "CBringItemTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CBringItemTask:__init(task_ini, section, type) super(task_ini, section, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "true"))
end

function CBringItemTask:check_target(squad_id, faction) -- called 1st (not on load)

	if self.faction_target and self.faction_target ~= faction then
		return false
	end

	local squad = self.board.squads[squad_id]

	if squad == nil then
		return false
	end

	local t = xr_logic.pick_section_from_condlist(db.actor, db.storage[squad.commander_id].object, self.target_cond)

	if t == "true" then
		local inited_time = squad.bring_item_inited_time
		if inited_time then
			if math.floor(get_game_time():diffSec(inited_time)) < 86400 then -- 60*60*24 = seconds in one day
				return false
			end
		end
		return true
	end

	return false
end

function CBringItemTask:get_inited_task(squad_id, entity_id) -- called 2nd (not on load)
	local task = CBringItemTask(self.task_ini, self.section, self.type) -- calls CGeneralTask:__init() and CBringItemTask:__init()
	task:init_task(squad_id)
	task.entity_id = entity_id
	return task
end

function CBringItemTask:init_task(squad_id) -- called 4th (not on load)
	local community = "actor"
	local sss = utils.cfg_get_string(self.task_ini, self.section, "requested_items", nil, false, "")
	if sss ~= nil then
		local actor_array = {}
		self.items_array = {["actor"] = actor_array}
		for k, item_name in pairs (utils.parse_names(sss)) do
			if actor_array[item_name] == nil then
				actor_array[item_name] =
				{
					chance = 1,
					min_count = 1,
					max_count = 1
				}
			else
				local actor_item_array = actor_array[item_name]
				actor_item_array.min_count = actor_item_array.min_count + 1
				actor_item_array.max_count = actor_item_array.min_count
			end
		end
	else -- never the case in vanilla
		local level_name = level.name()
		if level_name == nil then
			abort("[task_objects.CBringItemTask:init_task]: Level name is nil!")
		end
		local quest_ini = ini_file("misc\\bring_item_task.ltx")
		if not quest_ini:section_exist(level_name) then
			level_name = "default"
		end
		community = self.board.squads[squad_id].player_id
		if not quest_ini:section_exist(community) then
			abort("[task_objects.CBringItemTask:init_task]: No section for community '%s' in misc\\bring_item_task.ltx.", tostring(community))
		end
		local faction_table = {}
		self.items_array = {[community] = faction_table}
		for i = 0, quest_ini:line_count(community) - 1 do
			local _, item_name, chance_and_counts = quest_ini:r_line(community, i, "", "")
			local t = parse_nums(chance_and_counts)
			if t[1] == nil or t[2] == nil then
				abort("[task_objects.CBringItemTask:init_task]: Invalid parameter list '%s' in misc\\bring_item_task.ltx for community '%s' at line '%s'.", tostring(chance_and_counts), tostring(community), tostring(item_name))
			end
			if t[3] == nil then
				t[3] = t[2]
			end
			if quest_ini:line_exist(level_name, item_name) then
				local t2 = parse_nums(quest_ini:r_string(level_name, item_name))
				if t2[1] == nil or t2[2] == nil then
					abort("[task_objects.CBringItemTask:init_task]: Invalid parameter list for item '%s' in section '%s'.", tostring(item_name), tostring(level_name))
				end
				if t2[3] == nil then
					t2[3] = t2[2]
				end
				t[1] = t[1] * t2[1]
				t[2] = t[2] * t2[2]
				t[3] = t[3] * t2[3]
			end
			faction_table[item_name] =
			{
				chance = t[1],
				min_count = t[2],
				max_count = t[3]
			}
		end
	end
	self.ri_counter = 0
	self.requested_items = {}
	self:generate_requested_items(community)
	self.target = self.board.squads[squad_id].commander_id
	self.squad_id = squad_id
	self.state = "started"
end

function CBringItemTask:generate_requested_items(community)
	local math_random = math.random
	local sections_count = math_random(1, 4)
	local cur_sections_count = 0
	while (cur_sections_count == 0) do
		for item_name, count_table in pairs (self.items_array[community]) do
			if cur_sections_count > sections_count then
				break
			end
			local items_count = math_random(count_table.min_count, count_table.max_count)
			for i = 1, items_count do
				if math_random() <= count_table.chance then
					local cnt_table = self.requested_items[item_name]
					if cnt_table ~= nil then
						cnt_table.goal = cnt_table.goal + 1
					else
						self.requested_items[item_name] = {num = 0, goal = 1, xferd = 0}
						cur_sections_count = cur_sections_count + 1
					end
					self.ri_counter = self.ri_counter + 1
				end
			end
		end
	end
end

function CBringItemTask:set_task_text_for_bring_item()
	local s = ""
	local ini = system_ini()
	for item_name, cnt_table in pairs (self.requested_items) do
		local name = trans(ini:r_string(item_name, "inv_name")).." x"..cnt_table.goal
		if cnt_table.goal > cnt_table.num then
			s = s.."- "..name.."\\n"
		else
			s = s.."+ "..name.."\\n"
		end
	end
	self.text = s
end

local function set_inventory_item_count(requested_items, item)
	local sect = item:section()
	for item_name in pairs (requested_items) do
		if item_name == sect then
			local cnt_table = requested_items[item_name]
			cnt_table.num = cnt_table.num + 1
			return
		end
	end
end

function CBringItemTask:give_task(community) -- called 5th (not on load)
	task_objects.CGeneralTask.give_task(self, community)
	self.squad.bring_item_inited_time = self.inited_time -- self.squad set by task_dialogs.give_squad_capture_task()
	db.actor:iterate_inventory(set_inventory_item_count, self.requested_items)
	self:set_task_text_for_bring_item()
end

function CBringItemTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 250

	local actor = db.actor

	if actor == nil then
		return
	end

	local commander_id = self.squad.commander_id -- self.squad set by task_dialogs.give_squad_capture_task() or CBringItemTask:load(), guaranteed valid
--[[
	-- This is implicitly checked in sim_board:remove_squad():

	local commander = sim:object(commander_id)
	if not commander or not commander:alive() then
		self.last_check_task = "reversed"
		return
	end
]]
	local commander = db.storage[commander_id]
	commander = commander and commander.object

	if commander and commander:general_goodwill(actor) <= -1000 then
		self.last_check_task = "reversed"
		return
	end

	if self:has_requested_items(actor) then
		self.state = "have_item"
	else
		self.state = "started"
	end

	if self.target ~= commander_id then
		self.target = commander_id
		self.t:change_map_location(self.spot, commander_id)
	end
end

function CBringItemTask:has_requested_items(actor)

	local t = self.t

	if t == nil then
		t = actor:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CBringItemTask:has_requested_items]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	local c = 0

	for k, cnt_table in pairs (self.requested_items) do
		c = c + (cnt_table.num < cnt_table.goal and cnt_table.num or cnt_table.goal)
	end

	if self.auto_faction then
		t:set_description(self.community_name..".\\n"..self.text)
	else
		t:set_description(self.text)
	end

	if c < self.ri_counter then
		t:set_title(trans("sim_bring_item").." "..c.." ("..self.ri_counter..")")
		return false
	else
		t:set_title("sim_bring_item_text")
		return true
	end
end

function CBringItemTask:on_item_take(item)
	local cnt_table = self.requested_items[item:section()]
	if cnt_table then
		cnt_table.num = cnt_table.num + 1
	end
	self:set_task_text_for_bring_item()
end

function CBringItemTask:on_item_drop(item)
	local cnt_table = self.requested_items[item:section()]
	if cnt_table then
		cnt_table.num = cnt_table.num - 1
	end
	self:set_task_text_for_bring_item()
end

function CBringItemTask:on_load(actor)
	actor:iterate_inventory(set_inventory_item_count, self.requested_items)
end

local function transfer_non_slotted_items(task, item)
	local item_sect = item:section()
	for item_name, cnt_table in pairs (task.requested_items) do
		if item_sect == item_name then
			if cnt_table.xferd < cnt_table.goal then
				db.actor:transfer_item(item, task.npc)
				cnt_table.xferd = cnt_table.xferd + 1
			end
			return
		end
	end
end

function CBringItemTask:transfer_items_looking_for(npc)
	self.npc = npc
	self.state = "finished"
	db.actor:iterate_inventory(transfer_non_slotted_items, self)
	self.last_check_task = "complete"
end

function CBringItemTask:deactivate_task() -- called 7th
	task_objects.CGeneralTask.deactivate_task(self)
	local squad = self.squad
	if squad then
		squad.random_tasks[4] = nil
	end
end

function CBringItemTask:save(package)

	set_save_marker(package, "save", false, "CBringItemTask")

	task_objects.CGeneralTask.save(self, package)

	package:w_u8(self.ri_counter)
	package:w_stringZ(self.squad_id or "nil")

	local n = 0
	for item_name in pairs (self.requested_items) do
		n = n + 1
	end

	package:w_u8(n)

	for item_name, cnt_table in pairs (self.requested_items) do
		package:w_stringZ(item_name)
		package:w_u8(cnt_table.goal)
	end

	set_save_marker(package, "save", true, "CBringItemTask")
end

function CBringItemTask:load(reader) -- called 0.5th (only on load)

	set_save_marker(reader, "load", false, "CBringItemTask")

	task_objects.CGeneralTask.load(self, reader)

	self.ri_counter = reader:r_u8()

	local n = reader:r_stringZ()

	if n ~= "nil" then
		self.squad_id = n
	end

	self.squad = self.board.squads[self.squad_id]

	-- If tasker squad doesn't exist (it always should), cancel:
	if self.squad == nil then
		self.last_check_task = "reversed"
	end

	self.spot = "secondary_task_location_complex_bring_item"

	self.requested_items = {}

	n = reader:r_u8()
	for i = 1, n do
		local item_name = reader:r_stringZ()
		local goal = reader:r_u8()
		self.requested_items[item_name] = {num = 0, goal = goal, xferd = 0}
	end

	set_save_marker(reader, "load", true, "CBringItemTask")
end

------------------------------------------------------------------------------------------------

class "CRecoverItemTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CRecoverItemTask:__init(task_ini, section, type) super(task_ini, section, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "false"))
	self.target_npc_or_box_table = utils.parse_names(utils.cfg_get_string(task_ini, section, "target_npc_or_box_name", nil, true, ""))
	self.requested_item = task_ini:r_string(section, "requested_items")
	self.requested_item_inv_name = trans(system_ini():r_string(self.requested_item, "inv_name")) -- SRP
end

function CRecoverItemTask:check_target(squad_id, faction) -- called 1st (not on load)

	if self.faction_target and self.faction_target ~= faction then
		return false
	end

	local squad = self.board.squads[squad_id]

	if squad == nil then
		return false
	end

	local t = xr_logic.pick_section_from_condlist(db.actor, db.storage[squad.commander_id].object, self.target_cond)

	if t == "true" then
		local inited_time = squad.recover_item_inited_time
		if inited_time then
			if math.floor(get_game_time():diffSec(inited_time)) < 86400 then -- 60*60*24 = seconds in one day
				return false
			end
		end
		return true
	end

	return false
end

function CRecoverItemTask:get_inited_task(squad_id, entity_id) -- called 2nd (not on load)
	local task = CRecoverItemTask(self.task_ini, self.section, self.type) -- calls CGeneralTask:__init() and CRecoverItemTask:__init()
	task:init_task(squad_id)
	task.entity_id = entity_id
	return task
end

function CRecoverItemTask:init_task(squad_id) -- called 4th (not on load)
	self.squad_id = squad_id
	self.target = nil
	self.target_obj_id = nil
	self.state = "started"
end

function CRecoverItemTask:give_task(community) -- called 5th (not on load)
	self:spawn_recoveritem()
	task_objects.CGeneralTask.give_task(self, community)
	self.squad.recover_item_inited_time = self.inited_time -- self.squad set by task_dialogs.give_squad_capture_task()
end

function CRecoverItemTask:spawn_recoveritem()
	local index = math.random(1, #self.target_npc_or_box_table)
	local target_npc_or_box = sim:object(self.target_npc_or_box_table[index])
	if not target_npc_or_box then
		abort("[task_objects.CRecoverItemTask:spawn_recoveritem]: There is no such target npc or box: '%s'.", tostring(self.target_npc_or_box_table[index]))
	end
	local container_id = target_npc_or_box.id
	local container_pos = target_npc_or_box.position
	local container_lvx = target_npc_or_box.m_level_vertex_id
	local container_gvx = target_npc_or_box.m_game_vertex_id
	self.target_obj_id = sim:create(self.requested_item, container_pos, container_lvx, container_gvx, container_id).id
	self.target = container_id
end

function CRecoverItemTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 250

	local actor = db.actor

	if actor == nil then
		return
	end

	local commander_id = self.squad.commander_id -- self.squad set by task_dialogs.give_squad_capture_task() or CRecoverItemTask:load(), guaranteed valid
--[[
	-- This is implicitly checked in sim_board:remove_squad():

	local commander = sim:object(commander_id)
	if not commander or not commander:alive() then
		self.last_check_task = "reversed"
		return
	end
]]
	local commander = db.storage[commander_id]
	commander = commander and commander.object

	if commander and commander:general_goodwill(actor) <= -1000 then
		self.last_check_task = "reversed"
		return
	end

	if self:has_requested_item(actor) then
		self.state = "have_item"
		if self.target ~= commander_id then
			self.target = commander_id
			self.t:change_map_location(self.spot, commander_id)
		end
	else
		self.state = "started"
		local target_obj_id = self.target_obj_id
		if self.target ~= target_obj_id then
			self.target = target_obj_id
			self.t:change_map_location(self.spot, target_obj_id)
		end
	end
end

function CRecoverItemTask:has_requested_item(actor)

	local t = self.t

	if t == nil then
		t = actor:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CRecoverItemTask:has_requested_item]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	local has_requested_item = false
	local s = ""

	if actor:object(self.requested_item) ~= nil then
		s = "+ "
		has_requested_item = true
	else
		s = "- "
	end

	local description = self.text.."\\n"..s..self.requested_item_inv_name

	if self.auto_faction then
		t:set_description(self.community_name..".\\n"..description)
	else
		t:set_description(description)
	end

	return has_requested_item
end

function CRecoverItemTask:transfer_items_looking_for(npc) -- called 7th
	dialogs.relocate_item_section(npc, self.requested_item, "out")
	self.state = "finished"
	self.last_check_task = "complete"
end

function CRecoverItemTask:deactivate_task() -- called 8th
	task_objects.CGeneralTask.deactivate_task(self)
	local squad = self.squad
	if squad then
		squad.random_tasks[3] = nil
	end
end

function CRecoverItemTask:save(package)
	set_save_marker(package, "save", false, "CRecoverItemTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_stringZ(self.squad_id or "nil")
	package:w_u16(self.target_obj_id or -1)
	set_save_marker(package, "save", true, "CRecoverItemTask")
end

function CRecoverItemTask:load(reader) -- called 0.5th (only on load)

	set_save_marker(reader, "load", false, "CRecoverItemTask")

	task_objects.CGeneralTask.load(self, reader)

	local n = reader:r_stringZ()
	if n ~= "nil" then
		self.squad_id = n
	end

	self.squad = self.board.squads[self.squad_id]

	-- If tasker squad doesn't exist (it always should), cancel:
	if self.squad == nil then
		self.last_check_task = "reversed"
	end

	self.spot = "secondary_task_location_complex_recover_item"

	n = reader:r_u16()
	if n ~= 65535 then
		self.target_obj_id = n
	end

	set_save_marker(reader, "load", true, "CRecoverItemTask")
end

------------------------------------------------------------------------------------------------

class "CHideFromSurgeTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CHideFromSurgeTask:__init(task_ini, section, type) super(task_ini, section, type)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "true"))
end

function CHideFromSurgeTask:check_target()
	local actor = db.actor
	return xr_logic.pick_section_from_condlist(actor, actor, self.target_cond) == "true"
end

function CHideFromSurgeTask:get_inited_task(nearest_hide_zone_id, entity_id)
	local task = CHideFromSurgeTask(self.task_ini, self.section, self.type)
	task:init_task(nearest_hide_zone_id)
	task.entity_id = entity_id
	return task
end

function CHideFromSurgeTask:init_task(nearest_hide_zone_id)
	self.target = nearest_hide_zone_id
	self.disable_ui = false
	self.kill_em_all = false
	self.effector_started_time = -1
	self.wait_time = 0
	self.blowout_rumble_level = 0
	self.hide_tbl = {}
	local board = self.board
	local n = 0
	for k, v in pairs (board.smarts) do
		if v.smrt.actor_hides ~= nil then
			for kk, vv in pairs (v.smrt.actor_hides) do
				local obj = sim:object(vv)
				if obj then
					n = n + 1
					self.hide_tbl[n] = obj
				end
			end
		end
	end
end

function CHideFromSurgeTask:check_task(tm)

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 250

	local tbl = self.hide_tbl
	local nearest_cover_dist = 0
	local act = db.actor
	local gg, lid, act_pos = game_graph(), sim:level_id(), act:position()

	if gg:vertex(tbl[1].m_game_vertex_id):level_id() ~= lid then
		nearest_cover_dist = 10000
	else
		nearest_cover_dist = tbl[1].position:distance_to(act_pos)
	end

	local target, dist = tbl[1].id, 0
	for i = 2, #tbl do

		if gg:vertex(tbl[i].m_game_vertex_id):level_id() ~= lid then
			dist = 10000
		else
			dist = tbl[i].position:distance_to(act_pos)
		end

		if dist < nearest_cover_dist then
			nearest_cover_dist = dist
			target = tbl[i].id
		end
	end

	function blowout_hit_with_pp_and_cam_effectors(blowout_hit, cam_effector_id, pp_effector_id)
		xr_sound.set_sound_play(0, blowout_hit) -- 0 = actor ID
		level.add_cam_effector("camera_effects\\shell_shock.anm", cam_effector_id, false, "")
		level.add_pp_effector("snd_shock.ppe", pp_effector_id, false)
		level.set_pp_effector_factor(pp_effector_id, 0, 1.5)
	end

	function end_surge(last_check_task)
		self.last_check_task = last_check_task
		xr_surge_hide.surge_finished = true
		xr_surge_hide.start_surge = false
		xr_surge_hide.phase = 0
		xr_surge_hide.surge_activated = false
	end

	local t = self.t

	if t == nil then
		t = act and act:get_task(tostring(self.entity_id), false) -- "true" used to search only for not finished tasks
		if t == nil then
			abort("[task_objects.CHideFromSurgeTask:check_task]: Task with entity ID '%s' is nil.", tostring(self.entity_id))
		end
		self.t = t
	end

	if target ~= self.target then
		self.target = target
		t:change_map_location(self.spot, self.target)
	end

	local diff_sec = math.ceil(get_game_time():diffSec(self.inited_time) / level.get_time_factor())
	local surge_time = self.wait_time / 10 - 40

	if diff_sec >= surge_time then
		local _delta = global_time - self.effector_started_time
		if(self.effector_started_time==-1) then
			level.set_weather_fx("fx_surge_day_3")
			level.add_pp_effector("blink.ppe", 200210, false)
			level.add_pp_effector("snd_shock.ppe", 200208, true)
			level.set_pp_effector_factor(200208, 0, 10)
			self.effector_started_time = 0
		elseif(self.effector_started_time==0) then
			self.effector_started_time = global_time
			level.set_pp_effector_factor(200208, 1, 0.0075)
			level.add_cam_effector("camera_effects\\earthquake.anm", 200209, true, "")
			xr_sound.play_sound_looped(0, "surge_earthquake_sound") -- 0 = actor ID
		elseif not(self.disable_ui) and (_delta>=15000) then
			level.set_weather("[default]", false)
			xr_surge_hide.weather_surge = true
			xr_surge_hide.start_surge = false
			local sr = db.storage[self.target]
			if not(sr and sr.object:inside(act_pos)) then
				xr_effects.disable_ui(act)
				level.add_pp_effector("mar_surge.ppe", 200211, false)
			end
			self:kill_unhided_npc()
			self.disable_ui = true
		elseif not(self.kill_em_all) and (_delta>=20000) then
			self.kill_em_all = true
			local sr = db.storage[self.target]
			if not(sr and sr.object:inside(act_pos)) then
				if level.name()=="marsh" or level.name()=="marsh_nvidia" then
					level.remove_pp_effector(200208)
					level.remove_cam_effector(200209)
					xr_sound.stop_sound_looped(0) -- 0 = actor ID
					end_surge("reversed")
				else
					act:kill(act)
					end_surge("fail")
				end
			end
		elseif(_delta>=35000) then
			xr_effects.enable_ui()
			level.remove_pp_effector(200208)
			xr_sound.stop_sound_looped(0) -- 0 = actor ID
			end_surge("complete")
		elseif(_delta>=32500) then
			level.remove_cam_effector(200209)
			level.add_cam_effector("camera_effects\\earthquake.anm", 200209, false, "")
			level.set_pp_effector_factor(200208, 0.001, 0.8)
		end
	elseif(diff_sec==7) and (surge_time>13) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_1", 20080502, 20080402)
	elseif(diff_sec==13) and (surge_time>19) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_2", 20080503, 20080403)
	elseif(diff_sec==19) and (surge_time>31) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_3", 20080504, 20080404)
		level.set_weather_fx("fx_surge_day_2")
	elseif(diff_sec==31) and (surge_time>35) then
		blowout_hit_with_pp_and_cam_effectors("blowout_hit_1", 20080505, 20080405)
	elseif(diff_sec==35) and (surge_time>39) then
		blowout_hit_with_pp_and_cam_effectors("blowout_hit_2", 20080506, 20080406)
	elseif(diff_sec==39) and (surge_time>44) then
		blowout_hit_with_pp_and_cam_effectors("blowout_hit_1", 20080507, 20080407)
	elseif(diff_sec==44) and (surge_time>57) then
		blowout_hit_with_pp_and_cam_effectors("blowout_hit_3", 20080511, 20080411)
		level.add_pp_effector("agr_u_fade.ppe", 20080601, false)
		xr_surge_hide.phase = 4
	elseif(diff_sec==57) and (surge_time>65) then
		xr_surge_hide.phase = 5
	elseif(diff_sec==65) and (surge_time>71) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_1", 20080508, 20080408)
	elseif(diff_sec==71) and (surge_time>77) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_2", 20080509, 20080409)
	elseif(diff_sec==77) then
		blowout_hit_with_pp_and_cam_effectors("blowout_wave_3", 20080510, 20080410)
	end

	function blowout_hit_with_pp_and_cam_effectors(blowout_hit, cam_effector_id, pp_effector_id)
		xr_sound.set_sound_play(0, blowout_hit) -- 0 = actor ID
		level.add_cam_effector("camera_effects\\shell_shock.anm", cam_effector_id, false, "")
		level.add_pp_effector("snd_shock.ppe", pp_effector_id, false)
		level.set_pp_effector_factor(pp_effector_id, 0, 1.5)
	end

	function end_surge(last_check_task)
		self.last_check_task = last_check_task
		xr_surge_hide.surge_finished = true
		xr_surge_hide.start_surge = false
		xr_surge_hide.phase = 0
		xr_surge_hide.surge_activated = false
	end

	if (self.blowout_rumble_level < 1) and (xr_surge_hide.phase > 1) and (xr_surge_hide.phase < 4 or xr_surge_hide.phase == 5) then
		self.blowout_rumble_level = self.blowout_rumble_level + 0.015
		xr_sound.set_volume_sound_looped(0, "blowout_rumble", self.blowout_rumble_level) -- 0 = actor ID
	elseif self.blowout_rumble_level > 0 and xr_surge_hide.phase == 4 then
		self.blowout_rumble_level = self.blowout_rumble_level - 0.11
		xr_sound.set_volume_sound_looped(0, "blowout_rumble", self.blowout_rumble_level) -- 0 = actor ID
	end

	local stt = db.storage[self.target]
	if stt and stt.object:inside(act_pos) then
		if self.name == "hide_from_surge_name" then
			t:set_title(trans("hide_from_surge_name2"))
		end
	else
		if self.name == "hide_from_surge_name" then
			t:set_title(trans("hide_from_surge_name"))
		end
	end
end

function CHideFromSurgeTask:give_task(community)
	xr_sound.play_sound_looped(0, "blowout_rumble") -- 0 = actor ID
	xr_sound.set_volume_sound_looped(0, "blowout_rumble", self.blowout_rumble_level) -- 0 = actor ID
	task_objects.CGeneralTask.give_task(self, community)
end

function CHideFromSurgeTask:kill_unhided_npc()
	local h = hit()
	h.type = hit.fire_wound
	h.power = 0.9
	h.impulse = 0
	h.direction = vector():set(0, 0, 1)
	h.draftsman = db.actor
	for _, crow in pairs (bind_crow.crow_storage) do
		if crow and crow:alive() then
			crow:hit(h)
		end
	end
end

function CHideFromSurgeTask:save(package)

	set_save_marker(package, "save", false, "CHideFromSurgeTask")

	task_objects.CGeneralTask.save(self, package)

	package:w_u16(self.target or -1)
	package:w_u16(self.wait_time or -1)

	if self.effector_started_time == -1 or self.effector_started_time == 0 then
		package:w_s16(self.effector_started_time)
	else
		package:w_s16(time_global() - self.effector_started_time)
	end

	set_save_marker(package, "save", true, "CHideFromSurgeTask")
end

function CHideFromSurgeTask:load(reader)

	set_save_marker(reader, "load", false, "CHideFromSurgeTask")

	task_objects.CGeneralTask.load(self, reader)

	local val = reader:r_u16()
	if val ~= 65535 then
		self.target = val
	end

	val = reader:r_u16()
	if val ~= 65535 then
		self.wait_time = val
	end

	self.hide_tbl = {}

	local n = 0
	for k, v in pairs (self.board.smarts) do
		if v.smrt.actor_hides ~= nil then
			for kk, vv in pairs (v.smrt.actor_hides) do
				n = n + 1
				self.hide_tbl[n] = sim:object(vv)
			end
		end
	end

	local t = reader:r_s16()
	if t == 0 or t == -1 then
		self.effector_started_time = t
	else
		self.effector_started_time = time_global() + t
	end

	self.blowout_rumble_level = 0

	set_save_marker(reader, "load", true, "CHideFromSurgeTask")
end
--[=[
------------------------------------------------------------------------------------------------

class "CEliminateSquadTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CEliminateSquadTask:__init(task_ini, section, type) super(task_ini, section, type)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "true"))
	self.src_obj = nil
end

function CEliminateSquadTask:check_target(squad, faction)
	if self.faction_target and self.faction_target ~= faction then
		return false
	end
	return xr_logic.pick_section_from_condlist(db.actor, squad, self.target_cond) == "true"
end

function CEliminateSquadTask:get_inited_task(squad, entity_id)
	local task = CEliminateSquadTask(self.task_ini, self.section, self.type)
	task:init_task(squad)
	task.entity_id = entity_id
	return task
end

function CEliminateSquadTask:init_task(squad)
	self.target = squad.commander_id
	self.target_obj = squad.squad_id
end

function CEliminateSquadTask:give_task(community)
	task_objects.CGeneralTask.give_task(self, community)
end

function CEliminateSquadTask:check_task(tm)

	if self.last_check_task ~= nil then
		return
	end

	if self.board.squads[self.target_obj] == nil then
		self.last_check_task = "complete"
	end
end

function CEliminateSquadTask:deactivate_task()
	task_objects.CGeneralTask.deactivate_task(self)
	if self.src_obj ~= nil then
		local squad_obj = self.board.squads[self.src_obj]
		if squad_obj ~= nil then
			for k, v in pairs (squad_obj.random_tasks) do
				if v == self.entity_id then
					squad_obj.random_tasks[k] = nil
				end
			end
		end
	end
end

function CEliminateSquadTask:save(package)
	set_save_marker(package, "save", false, "CEliminateSquadTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	package:w_stringZ(tostring(self.src_obj))
	set_save_marker(package, "save", true, "CEliminateSquadTask")
end

function CEliminateSquadTask:load(reader)
	set_save_marker(reader, "load", false, "CEliminateSquadTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	self.src_obj = reader:r_stringZ()
	if self.src_obj == "nil" then
		self.src_obj = nil
	end
	set_save_marker(reader, "load", true, "CEliminateSquadTask")
end
]=]
------------------------------------------------------------------------------------------------

class "CFindUpgradeTask" (task_objects.CGeneralTask)

------------------------------------------------------------------------------------------------

function CFindUpgradeTask:__init(task_ini, section, type) super(task_ini, section, type) -- called 0th (on load), 0th and 3rd (otherwise)
	self.target_cond = xr_logic.parse_condlist(nil, nil, nil, utils.cfg_get_string(task_ini, section, "target_cond", nil, false, "", "false"))
	self.requested_item = utils.cfg_get_string(task_ini, section, "requested_item", nil, false, "")
	self.requested_item_inv_name = trans(system_ini():r_string(self.requested_item, "inv_name"))
	self.cost = utils.cfg_get_number(task_ini, section, "cost", nil, true)
	local item_section = utils.parse_target(utils.cfg_get_string(task_ini, section, "reward_upgr", nil, true, ""))
	local item_name = trans(system_ini():r_string(item_section, "inv_name"))
	local task_name = trans(self.name)
	self.item_for_reward = item_name..". "..task_name..": "..tostring(self.cost).." "..trans("st_rubles")
end

function CFindUpgradeTask:check_target(npc, faction) -- called 1st (not on load)
	if self.faction_target and self.faction_target ~= faction then
		return false
	end
	return xr_logic.pick_section_from_condlist(db.actor, npc, self.target_cond) == "true"
end

function CFindUpgradeTask:get_inited_task(npc_id, entity_id) -- called 2nd (not on load)
	local task = CFindUpgradeTask(self.task_ini, self.section, self.type) -- calls CGeneralTask:__init() and CFindUpgradeTask:__init()
	task:init_task(npc_id)
	task.entity_id = entity_id
	return task
end

function CFindUpgradeTask:init_task(npc_id) -- called 4th (not on load)
	self.target = npc_id
	self.state = "started"
end

function CFindUpgradeTask:give_task(community) -- called 5th (not on load)
	task_objects.CGeneralTask.give_task(self, community)
end

function CFindUpgradeTask:check_task(tm) -- called 6th

	if self.last_check_task ~= nil then
		return
	end

	local global_time = time_global()

	if global_time <= self.check_time then
		return
	end

	self.check_time = global_time + 250

	local actor = db.actor

	if actor == nil then
		return
	end

	local tasker_id = self.target -- self.target set by CFindUpgradeTask:init_task() or CRecoverItemTask:load(), guaranteed valid
	local tasker = sim:object(tasker_id)

	if not tasker or not tasker:alive() then
		self.last_check_task = "reversed"
		return
	end

	tasker = db.storage[tasker_id]
	tasker = tasker and tasker.object

	if tasker and tasker:general_goodwill(actor) <= -1000 then
		self.last_check_task = "reversed"
		return
	end

	if self:has_requested_item(actor) then
		self.state = "have_item"
	else
		self.state = "started"
	end

	for _, condlist in pairs (self.condlist) do
		local status = xr_logic.pick_section_from_condlist(actor, actor, condlist)
		if status ~= nil then
			if not valid_values[status] then
				abort("[task_objects.CFindUpgradeTask:check_task]: Invalid task status '%s' for task '%s'.", tostring(status), tostring(self.name))
			end
			self.last_check_task = status
			break
		end
	end
end

function CFindUpgradeTask:has_requested_item(actor)
	return task_objects.CRecoverItemTask.has_requested_item(self, actor)
end

function CFindUpgradeTask:transfer_items_looking_for(npc) -- called 7th
	dialogs.relocate_item_section(npc, self.requested_item, "out")
	dialogs.relocate_money(npc, self.cost, "in")
	self.state = "finished"
	self.last_check_task = "complete"
end

function CFindUpgradeTask:deactivate_task() -- called 8th
	task_objects.CGeneralTask.deactivate_task(self)
end

function CFindUpgradeTask:save(package)
	set_save_marker(package, "save", false, "CFindUpgradeTask")
	task_objects.CGeneralTask.save(self, package)
	package:w_u16(self.target)
	set_save_marker(package, "save", true, "CFindUpgradeTask")
end

function CFindUpgradeTask:load(reader) -- called 0.5th (only on load)
	set_save_marker(reader, "load", false, "CFindUpgradeTask")
	task_objects.CGeneralTask.load(self, reader)
	self.target = reader:r_u16()
	set_save_marker(reader, "load", true, "CFindUpgradeTask")
end