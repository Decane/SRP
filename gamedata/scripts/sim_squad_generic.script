local sim = _G.sim

local monster_resource_by_level =
{
	marsh      = {0,3},
	escape     = {1,3},
	garbage    = {1,4},
	darkvalley = {1,5},
	agroprom   = {1,5},
	yantar     = {3,6},
	red_forest = {3,4},
	military   = {1,5}
}

local monster_num_by_resource =
{
	[0] = {1,1},
	[1] = {4,5},
	[2] = {4,5},
	[3] = {4,5},
	[4] = {1,3},
	[5] = {1,2},
	[6] = {1,1}
}

local get_game_time          = game.get_game_time
local trans                  = game.translate_string

local map_add_object_spot    = level.map_add_object_spot
local map_has_object_spot    = level.map_has_object_spot
local map_change_spot_hint   = level.map_change_spot_hint
local map_remove_object_spot = level.map_remove_object_spot
local get_level_name         = level.name
local get_time_hours         = level.get_time_hours

local table_remove           = table.remove

local math_random            = math.random
local math_ceil              = math.ceil

local PLAYER_HELP_MAX_RADIUS = 150*150

class "sim_squad_generic"

function sim_squad_generic:__init(sim_board, player_id, squad_id)
	self.name = "sim_squad_generic"
	self.player_id = player_id
	self.squad_id = squad_id
	self.smart_id = nil
	self.board = sim_board
	self.squad_npc = {}
	self.commander_id = nil
	self.current_spot_id = nil
	self.npc_count = 0
	self.online_object = {}
	self.online_counter = 0
	self.random_tasks = {}
--	self.squad_alive = true
	self.squad_online = false
	self.current_action = nil
	self.sim_combat_id = nil
	self.last_action_timer = get_game_time()
	self.squad_power = 0
	self.squad_attack_power = 0
	self.entered_smart = nil
	self.sound_manager = sound_manager.get_sound_manager("squad_"..squad_id)
	self.show_disabled = false
	self.box_items = nil
	self.items_spawned = false
	self.failed_assignments = {}
end

-- function sim_squad_generic:init_squad() -- smart)
--	self.box_items = self:init_box_items(smart)
-- end

function sim_squad_generic:init_box_items(smart)
	local spawn_items = death_manager.item_by_community[self.player_id]
	if spawn_items == nil then
		return nil
	end
	local count_by_level = death_manager.count_by_level
	local squad_level = "default"
	if smart ~= nil then
		local smart_level = smart.smart_level
		if count_by_level[smart_level] then
			squad_level = smart_level
		end
	end
	local count_by_cur_level = count_by_level[squad_level]
	local items_to_spawn = {ammo = {}, not_ammo = {}}
	local ammo_sections = ammo_section
	local ammo_table = items_to_spawn.ammo
	local non_ammo_table = items_to_spawn.not_ammo
	for item_name, spawn_prob in pairs (spawn_items) do
		local count_data = count_by_cur_level[item_name]
		if count_data == nil then
			abort("[sim_squad_generic.init_box_items]: Missing count data for item '%s' for level '%s' in item spawn table of faction '%s' of squad with ID '%s'.", item_name, squad_level, self.player_id, tostring(self.squad_id))
			return nil
		end
		local units = math_ceil(math_random(count_data.min, count_data.max))
		if units > 0 then
			if ammo_sections[item_name] then
				ammo_table[item_name] = units
			else
				for i = units, 1, -1 do
					if math_random(100) <= spawn_prob then
						non_ammo_table[item_name] = i
						break
					end
				end
--[[			-- a more sophisticated alternative, but wasted in vanilla:
				local c = 0
				for i = 1, units do
					if math_random(100) <= spawn_prob then
						c = c + 1
					end
				end
				if c > 0 then
					items_to_spawn.not_ammo[item_name] = c
				end
]]
			end
		end
	end
	return items_to_spawn
end

function sim_squad_generic:spawn_box_items(smart_id)

	local smart = self.board.smarts[smart_id].smrt

	if smart.smart_level ~= get_level_name() then
--		self.items_spawned = true
		return
	end

	local smart_name = smart:name()
--	local sim = alife()
	local box = sim:object(smart_name.."_box")

	if not box then
		self.items_spawned = true
		return
	end

	if self.current_action ~= nil and self.current_action.name ~= "stay_point" then
		return
	end

	local box_id = box.id
	local box_object = db.storage[box_id]
	box_object = box_object and box_object.object

	if not box_object then
		return
	end

	local commander_object = db.storage[self.commander_id]
	commander_object = commander_object and commander_object.object

	if not commander_object then
--		self.items_spawned = true
		return
	end

	local box_items = self.box_items

	if box_items == nil then
		box_items = self:init_box_items(smart)
		if box_items == nil then
			self.items_spawned = true
			return
		end
		self.box_items = box_items
	end

	local vec = vector()
	local ini = system_ini()

	for section, units in pairs (box_items.ammo) do
		if death_manager.check_item_dependence(commander_object, section) then -- in vanilla, the first argument is not guaranteed to be non-nil, which can crash the game
--			se_respawn.create_ammo(section, vec, 0, 0, box_id, units) -- because method :object() is applied to it in death_manager.check_item_dependence
			local num_in_box = ini:r_u32(section, "box_size")
			local rounds = units
			while rounds > num_in_box do
				sim:create_ammo(section, vec, 0, 0, box_id, num_in_box)
				rounds = rounds - num_in_box
			end
			sim:create_ammo(section, vec, 0, 0, box_id, rounds)
		else
			box_items.ammo[section] = nil
		end
	end

	for section in pairs (box_items.not_ammo) do
		sim:create(section, vec, 0, 0, box_id)
	end

	self.items_spawned = true
end

function sim_squad_generic:create_npc(spawn_smart)

	self.squad_power = 0

	local spawn_point = spawn_smart.spawn_point
	local base_spawn_position, base_lvi, base_gvi

	if spawn_point ~= nil then
		base_spawn_position = patrol(spawn_point):point(0)
		base_lvi = patrol(spawn_point):level_vertex_id(0)
		base_gvi = patrol(spawn_point):game_vertex_id(0)
	else
		base_spawn_position = spawn_smart.position
		base_lvi = spawn_smart.m_level_vertex_id
		base_gvi = spawn_smart.m_game_vertex_id
	end

	local custom_resource = nil
	local min_npc, max_npc = 3, 5
	local spawn_level = spawn_smart.smart_level

	if self.player_id == "monster" then

		local min, max = 0, 5
		local monster_resource = monster_resource_by_level[spawn_level]

		if monster_resource ~= nil then
			min = monster_resource[1]
			max = monster_resource[2]
		end

		custom_resource = math_random(min, max)

		local monster_num = monster_num_by_resource[custom_resource]
		min_npc = monster_num[1]
		max_npc = monster_num[2]
	end

--	local sim = alife()
	local faction = self.board.players[self.player_id]

	for i = 1, math_random(min_npc, max_npc) do

		local position = base_spawn_position
		position.x = position.x + math_random(-2, 2)
		position.z = position.z + math_random(-2, 2)

		local spawn_section = faction:get_spawn_section(spawn_level, custom_resource)
		local obj = sim:create(spawn_section, position, base_lvi, base_gvi)
		local obj_id = obj.id

		obj.squad_id = self.squad_id
		self.squad_npc[obj_id] = obj_id

		self.sound_manager:register_npc(obj_id)

		if self.commander_id == nil then
			self.commander_id = obj_id
		end

		self.npc_count = self.npc_count + 1
		self.squad_power = self.squad_power + 5 * obj:rank() / 1000
	end

--	self.smart_id = spawn_smart.id -- done in sim_board:assign_squad_to_smart() after this func called

--	self:refresh() -- done after sim_board:create_squad() after this func called

	if self.squad_power > 25 then
		abort("[sim_squad_generic.create_npc]: Squad power ('%s') cannot exceed 25!", tostring(self.squad_power))
	end
end

function sim_squad_generic:clear_npc()
--	local sim = alife()
	for k in pairs (self.squad_npc) do
		sim:release(sim:object(k), true)
	end
	self.squad_npc = {}
	self.online_object = {}
	self.online_counter = 0
end

function sim_squad_generic:remove_npc(npc_id)
--	local sim = alife()
	local npc = sim:object(npc_id)
	self:on_npc_death(npc)
	sim:release(npc, true)
end

function sim_squad_generic:on_npc_death(npc, killer_id)

	local npc_id = npc.id

	self.squad_npc[npc_id] = nil
	self.npc_count = self.npc_count - 1
	self.squad_power = self.squad_power - 5 * npc:rank() / 1000

	if self.online_object[npc_id] ~= nil then
		self.online_object[npc_id] = nil
		self.online_counter = self.online_counter - 1
	end

	if self.commander_id == npc_id then
		for k in pairs (self.squad_npc) do
			self.commander_id = k
			break
		end
	end

	self.sound_manager:unregister_npc(npc_id)

	npc.squad_id = nil

	local st_npc = db.storage[npc_id]

	if st_npc ~= nil then
		if killer_id == 0 then -- 0 = actor ID
			local task
			if self.delayed_attack_task then
				task = task_manager.get_task_manager():get_task_by_entity_id(self.delayed_attack_task)
			else
				local combat_smart_id = nil
				local victim_action = self.current_action
				if victim_action and victim_action.name == "attack_point" then
					combat_smart_id = victim_action.dest_smrt_id
				else
					combat_smart_id = self.smart_id
				end
				task = task_manager.get_task_manager():get_tasks_by_smart(combat_smart_id)
			end
			if task then
				task:actor_hit(self.player_id)
			end
		end
		st_npc.squad_obj = nil
	end

	if self.npc_count == 0 then
--[[
		-- The block below has been moved into sim_board:remove_squad():

		local tm = task_manager.get_task_manager()
		for k, entity_id in pairs (self.random_tasks) do
			local task = tm:get_task_by_entity_id(entity_id)
			if task == nil then
				self.random_tasks[k] = nil
			else
				if task.status == "selected" then
					local task_type = task.type
					if task_type == "recover_item" or task_type == "bring_item" then
						if task.squad_id == self.squad_id then
							task.last_check_task = "reversed"
						else
							self.random_tasks[k] = nil
						end
					elseif task_type == "capture_smart" then
						task.last_check_task = "fail"
					end
				end
			end
		end
]]
		if self.current_action ~= nil then
			self.current_action:finalize()
			self.current_action = nil
		end
		if self.death_condlist ~= nil then
			xr_logic.pick_section_from_condlist(db.actor, self, self.death_condlist)
		end
		self.board:remove_squad(self, self.board.smarts[self.smart_id].smrt)
		self.commander_id = nil
		return
	end

	self:refresh()
end

local faction_activity =
{
	csky = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 00, [05] = 00,
		[06] = 00, [07] = 00, [08] = 00, [09] = 01, [10] = 01, [11] = 01,
		[12] = 01, [13] = 01, [14] = 01, [15] = 01, [16] = 01, [17] = 01,
		[18] = 01, [19] = 01, [20] = 00, [21] = 00, [22] = 00, [23] = 00},

	dolg = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 01, [05] = 01,
		[06] = 01, [07] = 01, [08] = 01, [09] = 01, [10] = 01, [11] = 01,
		[12] = 01, [13] = 01, [14] = 01, [15] = 01, [16] = 01, [17] = 01,
		[18] = 01, [19] = 01, [20] = 01, [21] = 01, [22] = 00, [23] = 00},

	freedom = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 01, [05] = 01,
		[06] = 01, [07] = 01, [08] = 01, [09] = 01, [10] = 01, [11] = 01,
		[12] = 01, [13] = 01, [14] = 01, [15] = 01, [16] = 01, [17] = 01,
		[18] = 01, [19] = 01, [20] = 01, [21] = 01, [22] = 00, [23] = 00},

	stalker = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 01, [05] = 01,
		[06] = 01, [07] = 01, [08] = 01, [09] = 01, [10] = 01, [11] = 01,
		[12] = 01, [13] = 01, [14] = 01, [15] = 01, [16] = 01, [17] = 01,
		[18] = 01, [19] = 01, [20] = 01, [21] = 01, [22] = 00, [23] = 00},

	bandit = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 00, [05] = 00,
		[06] = 00, [07] = 00, [08] = 00, [09] = 00, [10] = 01, [11] = 00,
		[12] = 01, [13] = 01, [14] = 01, [15] = 01, [16] = 01, [17] = 01,
		[18] = 01, [19] = 01, [20] = 01, [21] = 01, [22] = 00, [23] = 00},

	renegade = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 00, [05] = 00,
		[06] = 00, [07] = 00, [08] = 00, [09] = 00, [10] = 01, [11] = 01,
		[12] = 01, [13] = 01, [14] = 01, [15] = 01, [16] = 01, [17] = 01,
		[18] = 01, [19] = 01, [20] = 00, [21] = 00, [22] = 00, [23] = 00},

	army = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 00, [05] = 00,
		[06] = 00, [07] = 00, [08] = 00, [09] = 00, [10] = 00, [11] = 00,
		[12] = 00, [13] = 00, [14] = 00, [15] = 00, [16] = 00, [17] = 00,
		[18] = 00, [19] = 00, [20] = 00, [21] = 00, [22] = 00, [23] = 00},

	killer = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 00, [05] = 00,
		[06] = 00, [07] = 00, [08] = 00, [09] = 00, [10] = 00, [11] = 00,
		[12] = 00, [13] = 00, [14] = 00, [15] = 00, [16] = 00, [17] = 00,
		[18] = 00, [19] = 00, [20] = 00, [21] = 00, [22] = 00, [23] = 00},

	monolith = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 00, [05] = 00,
		[06] = 00, [07] = 00, [08] = 00, [09] = 00, [10] = 00, [11] = 00,
		[12] = 00, [13] = 00, [14] = 00, [15] = 00, [16] = 00, [17] = 00,
		[18] = 00, [19] = 00, [20] = 00, [21] = 00, [22] = 00, [23] = 00},

	zombied = {

		[00] = 00, [01] = 00, [02] = 00, [03] = 00, [04] = 00, [05] = 00,
		[06] = 00, [07] = 00, [08] = 00, [09] = 00, [10] = 00, [11] = 00,
		[12] = 00, [13] = 00, [14] = 00, [15] = 00, [16] = 00, [17] = 00,
		[18] = 00, [19] = 00, [20] = 00, [21] = 00, [22] = 00, [23] = 00},

	monster = {

		[00] = 01, [01] = 01, [02] = 01, [03] = 01, [04] = 01, [05] = 01,
		[06] = 01, [07] = 01, [08] = 01, [09] = 01, [10] = 01, [11] = 01,
		[12] = 01, [13] = 01, [14] = 01, [15] = 01, [16] = 01, [17] = 01,
		[18] = 01, [19] = 01, [20] = 01, [21] = 01, [22] = 01, [23] = 01}
}

function sim_squad_generic:calculate_attack_power()
	local faction_time_activity = faction_activity[self.player_id]
	if faction_time_activity == nil then
		abort("[sim_squad_generic.calculate_attack_power]: Faction time activity does not exist for faction '%s'.", tostring(self.player_id))
	end
	local game_time = get_game_time()
	local additional_power = faction_time_activity[get_time_hours()] * game_time:diffSec(self.last_action_timer) / 3600
	self.squad_attack_power = self.squad_attack_power + additional_power
	if self.squad_attack_power > 100 then
		self.squad_attack_power = 100
	end
	self.last_action_timer = game_time
end

function sim_squad_generic:update()

	self.sound_manager:update()

	if self.current_action ~= nil then
		if not self.current_action:is_finished() then
--			if self.player_id ~= "monster" then -- our relationship with mutants won't change, but their squad status might
				self:refresh()
--			end
			return
		end
		if self.current_action ~= nil then
			self.current_action:finalize()
			self.current_action = nil
		end
	end

	self:find_target()
	self:get_next_action()
--	self:refresh() -- already called by make() called by get_next_action()

	if not self.items_spawned and self.smart_id ~= nil then
		self:spawn_box_items(self.smart_id)
	end
end

local function pave_way_off_smart(board, front, archive)
	local num_front = #front
	for i = 1, num_front do
		local front_smart = front[i]
		local front_smart_owner = front_smart.owner
		for neighbor_smart_id, neighbor_smart in pairs (board:get_nearest_smarts(front_smart.smart)) do
			if archive[neighbor_smart_id] == nil and sim_board.is_point_avail(neighbor_smart, front_smart_owner) then
				archive[neighbor_smart_id] = true
				local neighbor_smart_owner = neighbor_smart.player_name
				local friends_at_neighbor
				if neighbor_smart_owner == "none" or game_relations.is_factions_enemies(front_smart_owner, neighbor_smart_owner) then
					friends_at_neighbor = board:get_smart_squad_quantity(neighbor_smart, board.players[front_smart_owner])
				elseif neighbor_smart_owner == front_smart_owner then
					friends_at_neighbor = board:get_smart_squad_quantity(neighbor_smart, board.players[front_smart_owner]) + board:get_smart_population(neighbor_smart)
				end
				if friends_at_neighbor ~= nil then
					if friends_at_neighbor < neighbor_smart.squad_capacity then
						local step, step_target_id, step_target = front_smart, neighbor_smart_id, neighbor_smart
						local sim_avail_table = {}
						while step ~= nil do
							local step_squad = step.squad
							local step_smart = step.smart
							sim_avail_table[step.smart_id] = {step_smart, step_smart.sim_avail}
--							dbglog("Booting squad '%s' from smart '%s' with population %d, friendly movers %d, and sim_avail [%s] to smart '%s' with population %d and friendly movers %d", step_squad.squad_id, smart_names.get_smart_terrain_name(step_smart), board:get_smart_population(step_smart), board:get_smart_squad_quantity(step_smart, board.players[step_squad.player_id]), tostring(step_smart.sim_avail), smart_names.get_smart_terrain_name(step_target), board:get_smart_population(step_target), board:get_smart_squad_quantity(step_target, board.players[step_squad.player_id]))
							step_smart.sim_avail = {{section = "false", infop_check = {}, infop_set = {}}} -- pseudo-hack to temporarily make the smart left by step_squad unavailable for unwanted visitors in case a race condition would otherwise send them there
--[[
							-- TODO: Is this necessary? Maybe e.g. if step_squad is in combat when booted off their smart...
							-- Update: Nope. Combat manager unregistration is done in sim_attack_point:make() if necessary, and step_squad.current_action is guaranteed to be nil or sim_stay_point, which doesn't need finalization. TODO: Check: Also, not necessary to set current_action to nil from sim_stay_point.
							if step_squad.sim_combat_id ~= nil then
								board.smarts[step_squad.sim_combat_id].smrt.combat_manager:unregister_squad(step_squad)
							end
							if step_squad.current_action ~= nil then
								step_squad.current_action:finalize()
								step_squad.current_action = nil
							end
]]
							step_squad.current_action = sim_attack_point(step_squad, step_target_id, true)
							step_squad.current_action:make()
							step, step_target_id, step_target = step.prev, step.smart_id, step_smart
						end
						for k, smart_data in pairs (sim_avail_table) do
--							dbglog("Reinstating sim_avail setting for smart '%s' to [%s]", smart_names.get_smart_terrain_name(smart_data[1]), tostring(smart_data[2]))
							smart_data[1].sim_avail = smart_data[2] -- undo the pseudo-hack above by reinstating for each disabled smart its former sim_avail setting (this might be nil)
						end
						return true
					end
					for k, neighbor_squad in pairs (board.smarts[neighbor_smart_id].squads) do
						local neighbor_squad_action = neighbor_squad.current_action
						-- Only if at least one neighbor_squad is stationary does it make sense to add neighbor_smart to front:
						if (neighbor_squad_action == nil or neighbor_squad_action.name == "stay_point") and not neighbor_squad:get_script_target() then
							front[#front + 1] = {smart = neighbor_smart, smart_id = neighbor_smart_id, owner = neighbor_smart_owner, squad = neighbor_squad, prev = front_smart}
							break
						end
					end
				end
			end
		end
	end
	for i = 1, num_front do
		table_remove(front, 1)
	end
	if #front == 0 then
--		dbglog("Algorithm failed to unblock faction war!")
		return false
	end
	return pave_way_off_smart(board, front, archive)
end

function sim_squad_generic:get_next_action()

	local board = self.board

	-- If simulation not started for us, stay.

	if db.actor and not board.simulation_started then
		self.current_action = sim_stay_point(self, true)
		self.current_action:make()
		return
	end

	-- If we are delay attacking or our smart is being attacked, stay.

	local smart_id = self.smart_id
	local smart = board.smarts[smart_id].smrt

	if self.delayed_attack_task ~= nil or smart.combat_manager:point_under_attack() then
		if self.squad_id ~= "gar_digger_messenger_dogs" then -- except (verb) Vasyan's dogs
			self.current_action = sim_stay_point(self, true)
			self.current_action:make()
			return
		end
	end

	-- If our smart is the target of an active defend task, stay. -- test

	local tm = task_manager.get_task_manager()
	local current_smart_task = tm:get_tasks_by_smart(smart_id)

	if current_smart_task ~= nil then
		local current_smart_task_type = current_smart_task.type
		if current_smart_task_type == "defend_smart" or current_smart_task_type == "defend_smart_delay" then
			if current_smart_task.status == "selected" then
				self.current_action = sim_stay_point(self)
				self.current_action:make()
				return
			end
		end
	end

	-- If we are forbidden from this smart, try to leave.

	local squad_faction = self.player_id

	if sim_board.is_point_avail(smart, squad_faction) == nil then
		if not self:get_script_target() then
			-- get_next_action() is called only when self.current_action = nil, so squad_faction is definitely smart's owner
			local front = {{smart = smart, smart_id = smart_id, owner = squad_faction, squad = self}}
			local archive = {[smart_id] = true}
--			dbglog("Squad '%s' forbidden from smart '%s' - about to attempt to boot off", self.squad_id, smart_names.get_smart_terrain_name(smart))
			if pave_way_off_smart(board, front, archive) == true then
				return
			end
		end
	end

	-- If we have been assigned a target smart, 'target_smart_id' is initially set to it.
	-- But if we are the squad joining the player in an active 'capture' task received via
	-- dialog, 'target_smart_id' is set to the task target instead.

	local target_smart_id = self.assigned_target_smart_id -- may be nil

	for k, task in pairs (tm.task_info) do
		if task.src_obj == self.squad_id then
			target_smart_id = task.target
			break
		end
	end

	-- If we have neither a faction target nor dialog capture target, stay.
	-- If our faction target or dialog capture target is our current smart, stay.

	if target_smart_id == nil or target_smart_id == smart_id then
		self.current_action = sim_stay_point(self)
		self.current_action:make()
		return
	end

	local clear_path = board:find_path(smart_id, target_smart_id, self)
	local next_point = clear_path[#clear_path]

	self.attacking_by_quest = nil

	local attack_threshold = self.squad_power + self.squad_attack_power
	local task = tm:get_tasks_by_smart(next_point.id)

	if task ~= nil then
		if task.support_attack == true and task.community == self.player_id then
--			if task.target == next_point.id then -- guaranteed
				self.attacking_by_quest = task.entity_id
				attack_threshold = 999
--			end
		end
	end

	if next_point.value == 0 then -- should never happen with the SRP

		self.current_action = sim_stay_point(self)

	elseif next_point.value < attack_threshold then

		local exist_task_type = task and task.type

		if exist_task_type == "defend_smart_delay" then
			self.current_action = sim_stay_point(self)
		elseif exist_task_type == "capture_smart" and task.community ~= squad_faction then
			self.current_action = sim_stay_point(self)
		else
			local faction = board.players[squad_faction]
			local next_smart_owner = board.smarts[next_point.id].smrt.player_name

			if faction.brain.use_delay_attack == true and next_smart_owner ~= "none" and next_smart_owner ~= squad_faction and exist_task_type == nil then

				local delay_attack_defender = nil

				for kk, vv in pairs (board.smarts[next_point.id].squads) do
					if vv.squad_online == true then
--						if not game_relations.is_squad_enemy_to_actor(vv.squad_id) then
						if not game_relations.check_all_squad_members(vv.squad_id, "enemy") then
							delay_attack_defender = vv.player_id
							break
						end
					end
				end

				if delay_attack_defender then
					self.current_action = sim_stay_point(self)
					self.current_action.delay_attack_id = next_point.id
					self.current_action.delay_attack_defender = delay_attack_defender
					self.current_action.next_point_id = next_point.id
				else
					self.current_action = sim_attack_point(self, next_point.id, false) --, self.attacking_by_quest ~= nil) -- self.attacking_by_quest is always nil here
--					self.current_action.target_power_value = next_point.value
					for k, squad in pairs (faction.squads) do
						squad.failed_assignments[target_smart_id] = nil
					end
				end
			else
				self.current_action = sim_attack_point(self, next_point.id, self.attacking_by_quest ~= nil)
--				self.current_action.target_power_value = next_point.value
				for k, squad in pairs (faction.squads) do
					squad.failed_assignments[target_smart_id] = nil
				end
			end
		end
	else
		self.failed_assignments[target_smart_id] = true
		self.current_action = sim_stay_point(self)
		self.current_action.next_point_id = next_point.id
		self:calculate_attack_power()
	end

	self.current_action:make()
end

function sim_squad_generic:get_script_target()
	return nil
end

function sim_squad_generic:find_target()
	local board = self.board
	local player = board.players[self.player_id]
	local cache_target_id = player:find_target(self)
	if cache_target_id ~= nil then
--		self.assigned_target_smart_id = board.smarts[cache_target_id].smrt.id
		self.assigned_target_smart_id = cache_target_id
	end
end

local function smart_under_attack(owner_faction, faction_table, smart_id)
	for checked_faction_name, checked_faction in pairs (faction_table) do
		if checked_faction_name ~= owner_faction then
			local checked_faction_attackers = checked_faction.current_attack_quantity[smart_id] or 0
			if checked_faction_attackers > 0 then
				return true
			end
		end
	end
	return false
end

function sim_squad_generic:init_squad_task()

	local board = self.board
	local tm = task_manager.get_task_manager()
	local squad_faction_name = self.player_id
	local random_tasks = self.random_tasks
	local recover_task = random_tasks[3]
	local squad_smart_id = self.smart_id
	local squad_smart = board.smarts[squad_smart_id].smrt
	local board_factions = board.players
	local task

	random_tasks = {}
	self.random_tasks = random_tasks

	if board:get_smart_population(squad_smart) > 1 or (board_factions[squad_faction_name].precondition_targets[squad_smart_id] == nil and smart_under_attack(squad_faction_name, board_factions, squad_smart_id) == false) then
		if self:get_script_target() == nil then
			local level_cluster = sim_board.sim_level_cluster
			local squad_smart_cluster = level_cluster[squad_smart.smart_level]
			for neighbor_smart_id, neighbor_smart in pairs (board:get_nearest_smarts(squad_smart)) do
				if level_cluster[neighbor_smart.smart_level] == squad_smart_cluster then
					if sim_board.is_point_avail(neighbor_smart, squad_faction_name) then
						local neighbor_faction_name = neighbor_smart.player_name
						if neighbor_faction_name ~= "none" then
							if game_relations.is_factions_enemies(squad_faction_name, neighbor_faction_name) then
								if smart_under_attack(neighbor_faction_name, board_factions, neighbor_smart_id) == false then
									local neighbor_smart_task = tm:get_tasks_by_smart(neighbor_smart_id)
									if not neighbor_smart_task or neighbor_smart_task.base_prior == 3 then
										task = tm:select_task("capture_smart", neighbor_smart, squad_faction_name)
										task.src_obj = self.squad_id
										if random_tasks[1] == nil then
											random_tasks[1] = task.entity_id
										elseif random_tasks[2] == nil then
											random_tasks[2] = task.entity_id
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end

	task = tm:select_task("recover_item", self.squad_id, squad_faction_name)
	if task ~= nil then
		random_tasks[3] = task.entity_id
	elseif recover_task ~= nil then
		random_tasks[3] = recover_task
	end

--	task = tm:select_task("bring_item", self.commander_id, squad_faction_name)
	task = tm:select_task("bring_item", self.squad_id, squad_faction_name)
	if task ~= nil then
		random_tasks[4] = task.entity_id
	end
end

function sim_squad_generic:give_squad_task(target_smart_id)
	local ktask = task_manager.get_task_manager():get_tasks_by_smart(target_smart_id)
	if ktask ~= nil then
		if ktask.type == "eliminate_smart" then
			ktask.last_check_task = "reversed_silent"
			bind_stalker.task_update = true
		else
			ktask:reverse_task()
		end
	end
	if self.current_action == nil then
		abort("[sim_squad_generic.give_squad_task]: self.current_action = nil but vanilla code presupposes the opposite.")
	end
	self.current_action:finalize()
	self.current_action = nil
end

function sim_squad_generic:cover_attack()

	if self.sim_combat_id == nil then
		return false
	end

	local board = self.board

	if board.players[self.player_id].brain.use_cover_attack ~= true then
		return false
	end

	local sim_combat = board.smarts[self.sim_combat_id].smrt.combat_manager
	local my_enemy = sim_combat:get_squad_enemy(self)

	if my_enemy == nil then
		return false
	end

	if board.players[my_enemy.player_id].brain.use_cover_attack ~= true then
		return false
	end

	local my_squad_stage = sim_combat:get_squad_stage(self)
	local enemy_squad_stage = sim_combat:get_squad_stage(my_enemy)

	if sim_combat.combat_quest == "capture" then
		if my_squad_stage == "defence" then
			return true
		else
			if enemy_squad_stage == "defence" then
				self:issue_order("alife_we_spoted")
				return true
			else
				return false
			end
		end
	else
		return (my_squad_stage == "wait") or (my_squad_stage == "defence" and enemy_squad_stage == "wait")
--[[
		if my_squad_stage == "wait" then
			return true
		elseif my_squad_stage == "defence" and enemy_squad_stage == "wait" then
			return true
		end
		return false
]]
	end
end

function sim_squad_generic:issue_order(order)

--	if self.npc_count <= 1 then
--		return false
--	end

	if self.board.players[self.player_id].brain.use_issue_order ~= true then
		return false
	end

	local actor = db.actor
	local commander_id = self.commander_id
	local commander = db.storage[commander_id]
	commander = commander and commander.object

	if actor == nil or commander == nil or commander:general_goodwill(actor) <= -1000 then
		return false
	end

--	local sim = alife()
	local com_pos = sim:object(commander_id).m_game_vertex_id

	if utils.graph_distance(sim:actor().m_game_vertex_id, com_pos) > 150 then
		return false
	end

	if order == "attack" then
		xr_sound.set_sound_play(commander_id, "alife_start_attack")
	elseif order == "battlecry" then
		xr_sound.set_sound_play(commander_id, "alife_battlecry")
	elseif order == "prepare" then
		if self.attacking_by_quest ~= nil then
			self.sound_manager:set_storyteller(commander_id)
			self.sound_manager:set_story("squad_prepare_attack")
			return true
		else
			self.sound_manager:set_story("squad_prepare_attack_self")
			return false
		end
	elseif order == "wait_again_signal" then
		xr_sound.set_sound_play(commander_id, "alife_wait_actor_signal", self.player_id, self.current_action.dest_smrt_id)
	elseif order == "alife_we_spoted" then
		if self.spoted_shouted == false then
			local target_id = self.current_action.dest_smrt_id
			local dist_to_target = utils.graph_distance(sim:object(target_id).m_game_vertex_id, com_pos)
			if dist_to_target > 40 then
				local dist_to_origin = utils.graph_distance(sim:object(self.smart_id).m_game_vertex_id, com_pos)
				xr_sound.set_sound_play(commander_id, "alife_we_spoted_now", self.player_id, dist_to_target > dist_to_origin and self.smart_id or target_id)
			end
			self.spoted_shouted = true
		end
	elseif order == "counter_attack_spotted" then
		xr_sound.set_sound_play(commander_id, "alife_see_counter", self.player_id, self.smart_id)
	elseif order == "defend_sos_monster" then
		xr_sound.set_sound_play(commander_id, "alife_defence_vs_mutant", self.player_id, self.smart_id)
	elseif order == "defend_sos_bandit" then
		xr_sound.set_sound_play(commander_id, "alife_defence_vs_bandit", self.player_id, self.smart_id)
	elseif order == "defend_sos_army" then
		xr_sound.set_sound_play(commander_id, "alife_defence_vs_army", self.player_id, self.smart_id)
--	elseif order == "defend_sos_monolith" then
--		xr_sound.set_sound_play(commander_id, "alife_defence_vs_zombied", self.player_id, self.smart_id)
	elseif order == "defend_sos_zombied" then
		xr_sound.set_sound_play(commander_id, "alife_defence_vs_zombied", self.player_id, self.smart_id)
	elseif order == "defend_sos_renegade" then
		xr_sound.set_sound_play(commander_id, "alife_defence_vs_bandit", self.player_id, self.smart_id)
	elseif order == "defend_sos_stalker" then
		xr_sound.set_sound_play(commander_id, "alife_defence_vs_stalker", self.player_id, self.smart_id)
	elseif order == "defend_sos_dolg" then
		xr_sound.set_sound_play(commander_id, "alife_defence_vs_dolg", self.player_id, self.smart_id)
	elseif order == "defend_sos_freedom" then
		xr_sound.set_sound_play(commander_id, "alife_defence_vs_freedom", self.player_id, self.smart_id)
	elseif order == "defend_wait" then
		xr_sound.set_sound_play(commander_id, "alife_defence_wait_help", self.player_id, self.smart_id)
	elseif order == "defend_actor_come" then
		xr_sound.set_sound_play(commander_id, "alife_defence_actor_come", self.player_id, self.smart_id)
--	elseif order == "defend_actor_ignore" then
--		xr_sound.set_sound_play(commander_id, "alife_defence_actor_ignore", self.player_id, self.smart_id)
	elseif order == "defend_actor_help" then
		xr_sound.set_sound_play(commander_id, "alife_defence_actor_help", self.player_id, self.smart_id)
	elseif order == "combat_done" then
		local squad_action = self.current_action
		if squad_action ~= nil and squad_action.name == "attack_point" then
			if utils.graph_distance(sim:object(squad_action.dest_smrt_id).m_game_vertex_id, com_pos) < 40 then
				xr_sound.set_sound_play(commander_id, "alife_attack_done", self.player_id, squad_action.dest_smrt_id)
			elseif utils.graph_distance(sim:object(self.smart_id).m_game_vertex_id, com_pos) < 40 then
				xr_sound.set_sound_play(commander_id, "alife_attack_done", self.player_id, self.smart_id)
			end
		else
			xr_sound.set_sound_play(commander_id, "alife_defence_done", self.player_id, self.smart_id)
		end
	end
end

function sim_squad_generic:save(packet)

	set_save_marker(packet, "save", false, "sim_squad_generic")

	if self.smart_id == nil then
		packet:w_u16(-1)
	else
		packet:w_u16(self.smart_id)
	end

	if self.assigned_target_smart_id == nil then
		packet:w_u16(-1)
	else
		packet:w_u16(self.assigned_target_smart_id)
	end

	if self.sim_combat_id == nil then
		packet:w_u16(-1)
	else
		packet:w_u16(self.sim_combat_id)
	end

	if self.delayed_attack_task == nil then
		packet:w_u16(-1)
	else
		packet:w_u16(self.delayed_attack_task)
	end

	local n = 0
	for k in pairs (self.random_tasks) do
		n = n + 1
	end

	packet:w_u8(n)

	for k, v in pairs (self.random_tasks) do
		packet:w_u16(k)
		packet:w_u16(v)
	end

	packet:w_u8(self.npc_count)
	packet:w_float(self.squad_power)
	packet:w_u16(self.commander_id)
--[[
	n = 0
	for k in pairs (self.squad_npc) do
		n = n + 1
	end

	packet:w_u8(n)
]]
	for k, v in pairs (self.squad_npc) do
		packet:w_u16(v)
	end

	if self.spoted_shouted == true then
		packet:w_bool(true)
	else
		packet:w_bool(false)
	end

	utils.w_CTime(packet, self.last_action_timer)

	packet:w_u16(self.squad_attack_power)

	if self.current_action == nil then
		packet:w_bool(false)
	else
		packet:w_bool(true)
		if self.current_action.name == "attack_point" then
			packet:w_bool(true)
			packet:w_u16(self.current_action.dest_smrt_id)
		else
			packet:w_bool(false)
		end
		self.current_action:save(packet)
	end

	packet:w_bool(self.items_spawned == true)

	utils.w_CTime(packet, self.bring_item_inited_time)
	utils.w_CTime(packet, self.recover_item_inited_time)

	set_save_marker(packet, "save", true, "sim_squad_generic")
end

function sim_squad_generic:load(packet) --, registred)

	set_save_marker(packet, "load", false, "sim_squad_generic")

	local smart_id = packet:r_u16()
	if smart_id == 65535 then
		smart_id = nil
	end

	self.smart_id = smart_id
--[[
	if self.name == "sim_squad_generic" then
		local smart_info = smart_id and self.board.smarts[smart_id]
		self:init_squad(smart_info and smart_info.smrt) -- let's allow loaded generic squads to spawn box items, too
	end
]]
	self.assigned_target_smart_id = packet:r_u16()
	if self.assigned_target_smart_id == 65535 then
		self.assigned_target_smart_id = nil
	end

	self.sim_combat_id = packet:r_u16()
	if self.sim_combat_id == 65535 then
		self.sim_combat_id = nil
	end

	self.delayed_attack_task = packet:r_u16()
	if self.delayed_attack_task == 65535 then
		self.delayed_attack_task = nil
	end

--	self.random_tasks = {}
	local T = self.random_tasks

	local n = packet:r_u8()

	for i = 1, n do
		local k = packet:r_u16()
		local v = packet:r_u16()
		T[k] = v
	end

	self.npc_count = packet:r_u8()
	self.squad_power = packet:r_float()
	self.commander_id = packet:r_u16()

--	self.squad_npc = {}
	T = self.squad_npc

--	n = packet:r_u8()

	for i = 1, self.npc_count do
		local k = packet:r_u16()
		T[k] = k
		self.sound_manager:register_npc(k)
	end

	self.spoted_shouted = packet:r_bool()
	self.last_action_timer = utils.r_CTime(packet)
	self.squad_attack_power = packet:r_u16()

	local flag = packet:r_bool()
	if flag == true then
		local class = packet:r_bool()
		if class == true then
			local dest_smrt_id = packet:r_u16()
			self.current_action = sim_attack_point(self, dest_smrt_id)
		else
			self.current_action = sim_stay_point(self)
		end
		self.current_action:load(packet)
	end

	self.items_spawned = packet:r_bool()
	self.bring_item_inited_time = utils.r_CTime(packet)
	self.recover_item_inited_time = utils.r_CTime(packet)

	set_save_marker(packet, "load", true, "sim_squad_generic")
end

function sim_squad_generic:init_squad_on_load()
	local board = self.board
	local squad_smart_id = self.smart_id
	local squad_action = self.current_action
	board:assign_squad_to_smart(self, squad_smart_id) -- loaded attack_point squads, like non-loaded ones, get squad.smart_id = squad_smart_id but not board.smarts[squad_smart_id].squads[self.squad_id] = self
	if squad_action == nil or squad_action.name == "stay_point" then
		board:enter_smart(self, squad_smart_id, true)
	end
end

function sim_squad_generic:force_online(to_online)
--	local sim = alife()
	for npc_id in pairs (self.squad_npc) do
		local se_npc = sim:object(npc_id)
		if se_npc ~= nil then
			se_npc.sim_forced_online = to_online
		end
	end
end

function sim_squad_generic:switch_online(is_online, npc_id)
	if is_online then
		if self.online_object[npc_id] == nil then
			self.online_object[npc_id] = true
			self.online_counter = self.online_counter + 1
		end
		if self.squad_online == false then
			self.squad_online = true
			if self.sim_combat_id ~= nil then
				local sim_combat = self.board.smarts[self.sim_combat_id].smrt.combat_manager
				sim_combat:squad_go_online(self)
			end
		end
	else
		if self.online_object[npc_id] ~= nil then
--[[
			if npc_id == self.commander_id then
				local st_npc = db.storage[npc_id]
				if st_npc == nil then
					abort("[sim_squad_generic.switch_online]: db.storage[npc_id] = nil but vanilla code presupposes the opposite.")
				end
				local obj = st_npc.object
				if obj then
					local act = db.actor
					if act then
						local relation = obj:general_goodwill(act)
						if relation <= -1000 then
							db.goodwill.relations[npc_id] = -3000
						elseif relation >= 1000 then
							db.goodwill.relations[npc_id] = 9000
						else
							db.goodwill.relations[npc_id] = 0
						end
					end
				end
			end
]]
			self.online_object[npc_id] = nil
			self.online_counter = self.online_counter - 1
		end
		if self.squad_online == true then
			if self.online_counter > 0 then
				return
			end
			self.squad_online = false
			if self.sim_combat_id ~= nil then
				local sim_combat = self.board.smarts[self.sim_combat_id].smrt.combat_manager
				sim_combat:squad_go_offline(self)
			end
		end
	end
end

function sim_squad_generic:refresh()

	local commander_id = self.commander_id

	if commander_id == nil
	or self.show_disabled
	or map_has_object_spot(commander_id, "ui_pda2_trader_location") ~= 0
	or map_has_object_spot(commander_id, "ui_pda2_scout_location") ~= 0
	or map_has_object_spot(commander_id, "ui_pda2_quest_npc_location") ~= 0 then
		self:hide()
		return
	end

	if self.current_spot_id ~= commander_id then
		self:hide()
		self.current_spot_id = commander_id
	end

	local new_spot

	if self.player_id == "monster" then
		new_spot = "alife_presentation_squad_monster"
	else
		local relation
		local actor = db.actor
		local commander = db.storage[commander_id]
		commander = commander and commander.object

		if commander and actor then
			relation = commander:general_goodwill(actor)
		else
			local relationship = self.relationship
			if relationship == "enemy" then
				relation = -1000
			elseif relationship == "friend" then
				relation = 1000
--			elseif relationship == "neutral" then
--				relation = 0 -- needs to be calculated
			else
				local squad_faction = self.player_id
				local actor_faction = actor and actor:character_community() or sim:actor():community()
				relation = relation_registry.community_goodwill(squad_faction, actor_faction) + relation_registry.community_relation(squad_faction, actor_faction)
			end
		end

		if relation >= 1000 then
			new_spot = "alife_presentation_squad_friend"
		elseif relation <= -1000 then
			new_spot = "alife_presentation_squad_enemy"
		else
			new_spot = "alife_presentation_squad_neutral"
		end
	end

	if self.current_action and self.current_action.name == "attack_point" then
		if new_spot == "alife_presentation_squad_friend" then
			new_spot = "alife_presentation_friend_squad_attack_point"
		elseif new_spot == "alife_presentation_squad_neutral" then
			new_spot = "alife_presentation_neutral_squad_attack_point"
		else -- elseif new_spot == "alife_presentation_squad_enemy" then -- let's make mutant map spots change color as well
			new_spot = "alife_presentation_enemy_squad_attack_point"
		end
	end

	local orig_spot = self.spot_section

	if orig_spot == new_spot then
		if has_alife_info("ui_pda") then
			map_change_spot_hint(commander_id, orig_spot, self:get_squad_props()) -- update info string iff PDA is open
		end
	else
		if orig_spot ~= nil then
			map_remove_object_spot(commander_id, orig_spot)
		end
		map_add_object_spot(commander_id, new_spot, self:get_squad_props())
		self.spot_section = new_spot
	end
end

function sim_squad_generic:hide()
	if self.current_spot_id == nil or self.spot_section == nil then
		return
	end
	map_remove_object_spot(self.current_spot_id, self.spot_section)
	self.current_spot_id = nil
	self.spot_section = nil
end

local stage_name_table = {

--	idle        = "st_stage_idle",
--	move        = "st_stage_move",
	combat      = "st_stage_combat",
	post_combat = "st_stage_post_combat",
	defence     = "st_stage_defence",
	wait        = "st_stage_wait",
	prepare     = "st_stage_prepare"
}

function sim_squad_generic:get_squad_props()

	local str = self.player_id

	if str == "renegade" then
		str = "ui_st_name_bandit_2"
	elseif str == "bandit" then
		str = "ui_st_name_bandit"
	elseif str == "csky" then
		str = "ui_st_name_csky"
	elseif str == "dolg" then
		str = "ui_st_name_dolg"
	elseif str == "freedom" then
		str = "ui_st_name_freedom"
	elseif str == "stalker" then
		str = "ui_st_name_stalker"
	end

	str = trans(str)

	-----------------
	-- DEBUG INFO: --
	-----------------

--	str = str.." ["..self.squad_id.."]"

	-----------------
	-- /DEBUG INFO --
	-----------------

	local board = self.board
	local sim_combat_id = self.sim_combat_id
	local current_action = self.current_action

	if sim_combat_id ~= nil then
		local sim_combat = board.smarts[sim_combat_id].smrt.combat_manager
		if sim_combat ~= nil then
			local squad_stage = stage_name_table[sim_combat:get_squad_stage(self)]
			if squad_stage ~= nil then
				str = str.." "..trans(squad_stage)
			end
		end
	end

	if current_action and current_action.name == "attack_point" then
		local dest_smart_id = board.players[self.player_id].squad_target_cache[self.squad_id] or current_action.dest_smrt_id
		str = str.."\\n"..trans("st_target")..": "..smart_names.get_smart_terrain_name(board.smarts[dest_smart_id].smrt)
	end

	-----------------
	-- DEBUG INFO: --
	-----------------
--[[
	local board_smarts = board.smarts
	local squad_smart_id = self.smart_id
	local cache_target = board.players[self.player_id].squad_target_cache[self.squad_id]
	local assigned_target_id = self.assigned_target_smart_id

	str = str.."\\nFrom: "..(squad_smart_id ~= nil and smart_names.get_smart_terrain_name(board_smarts[squad_smart_id].smrt) or "")
	str = str.."\\nPath: "..((current_action and current_action.name == "attack_point") and smart_names.get_smart_terrain_name(board_smarts[current_action.dest_smrt_id].smrt) or "")
	str = str.."\\nNext: "..((current_action and current_action.next_point_id ~= nil) and smart_names.get_smart_terrain_name(board_smarts[current_action.next_point_id].smrt) or "")
	str = str.."\\nCache: "..(cache_target ~= nil and smart_names.get_smart_terrain_name(board_smarts[cache_target].smrt) or "")
	str = str.."\\nTo: "..(assigned_target_id ~= nil and smart_names.get_smart_terrain_name(board_smarts[assigned_target_id].smrt) or "")
]]
	-----------------
	-- /DEBUG INFO --
	-----------------

	return str
end

-- function sim_squad_generic:print()
-- end

-------------------------------------------

class "sim_attack_point"

function sim_attack_point:__init(squad, dest_smrt_id, major)
	self.name = "attack_point"
	self.squad = squad -- SRP
	self.board = squad.board
--	self.player_id = squad.player_id
--	self.squad_id = squad.squad_id
--	self.src_smrt_id = squad.smart_id
	self.dest_smrt_id = dest_smrt_id
	self.major = major
end

function sim_attack_point:save(packet)
	set_save_marker(packet, "save", false, "sim_attack_point")
	packet:w_bool(self.major)
--	if self.target_power_value == nil then
--		packet:w_u16(-1)
--	else
--		packet:w_u16(self.target_power_value)
--	end
	packet:w_bool(self.target_was_hostile == true)
	set_save_marker(packet, "save", true, "sim_attack_point")
end

function sim_attack_point:load(packet)
	set_save_marker(packet, "load", false, "sim_attack_point")
	self.major = packet:r_bool()
--	self.target_power_value = packet:r_u16()
--	if self.target_power_value == 65535 then
--		self.target_power_value = nil
--	end
	self.target_was_hostile = packet:r_bool()
	set_save_marker(packet, "load", true, "sim_attack_point")
end

function sim_attack_point:is_finished()

	local board = self.board
	local squad = self.squad
	local dest_smrt_id = self.dest_smrt_id
	local dest_smart = board.smarts[dest_smrt_id].smrt
	local squad_stage = dest_smart.combat_manager:get_squad_stage(squad)

	if squad_stage ~= "idle" and squad_stage ~= "defence" then
		return false
	end

	local commander = sim:object(squad.commander_id)

	if game_graph():vertex(commander.m_game_vertex_id):level_id() ~= dest_smart.level_id then
		return false
	end

	if squad.squad_online then
		local obj_pos = commander.position
		local dest_def_restr = db.zone_by_name[dest_smart.def_restr]
		if (dest_def_restr ~= nil and not dest_def_restr:inside(obj_pos) and dest_smart:name() ~= "mar_smart_terrain_5_12") or (dest_def_restr == nil and obj_pos:distance_to_sqr(dest_smart.position) > 900) then
			return false
		end
--	else
--		local dist = utils.graph_distance(dest_smart.m_game_vertex_id, commander.m_game_vertex_id)
--		if dist > 84 then
--			dbgmsg("Offline "..trans(squad.player_id).." squad is "..dist.."m away from "..smart_names.get_smart_terrain_name(dest_smart)..".")
--			return false
--		end
	end

	local dest_faction = dest_smart.player_name
	local squad_faction = squad.player_id

	if dest_faction ~= squad_faction then
		if dest_faction ~= "none" then
			return false
		else
			if self.target_was_hostile == true then
				xr_sound.set_sound_play(squad.commander_id, "alife_point_captured", squad_faction, dest_smrt_id)
			end
		end
	end

	dest_smart.combat_manager:unregister_squad(squad)

	board:assign_squad_to_smart(squad, dest_smrt_id)
	board:enter_smart(squad, dest_smrt_id)

--	dbgmsg(trans(squad_faction).." squad entered "..smart_names.get_smart_terrain_name(dest_smart)..".")

--	squad:refresh() -- done at call point

	return true
end

function sim_attack_point:make()

	local board = self.board
	local squad = self.squad
	local squad_faction_name = squad.player_id
	local cur_attack_quantity = board.players[squad_faction_name].current_attack_quantity
	local dest_smrt_id = self.dest_smrt_id

	if cur_attack_quantity[dest_smrt_id] == nil then
		cur_attack_quantity[dest_smrt_id] = 0
	end

	cur_attack_quantity[dest_smrt_id] = cur_attack_quantity[dest_smrt_id] + 1

	squad.failed_assignments = {}
	squad.spoted_shouted = false

	local board_smarts = board.smarts
	local dest_smart = board_smarts[dest_smrt_id].smrt
	local attack_smart_owner = dest_smart.player_name -- use this local instead of 'self.attack_smart_owner'

	if attack_smart_owner ~= "none" and attack_smart_owner ~= squad_faction_name then
		self.target_was_hostile = true
		squad.sound_manager:set_storyteller(squad.commander_id)
		squad.sound_manager:set_story("squad_begin_attack")
	end

	local src_smart = board_smarts[squad.smart_id].smrt

	if squad.sim_combat_id ~= nil then
		src_smart.combat_manager:unregister_squad(squad)
	end

	dest_smart.combat_manager:register_squad(squad)

	board:exit_smart(squad, src_smart)

--	squad.current_action = self -- superfluous

--	local sim = alife()

	for npc_id in pairs (squad.squad_npc) do
		local se_npc = sim:object(npc_id)
		board:setup_squad_and_group(se_npc)
		src_smart:update_jobs(se_npc)
	end

	squad.last_action_timer = get_game_time()
	squad.squad_attack_power = 0
	squad:refresh()

--	board.players[squad_faction_name]:refresh()
end

function sim_attack_point:finalize()
	local cur_attack_quantity = self.board.players[self.squad.player_id].current_attack_quantity
	local dest_smrt_id = self.dest_smrt_id
	cur_attack_quantity[dest_smrt_id] = cur_attack_quantity[dest_smrt_id] - 1
end

-- function sim_attack_point:print(space)
-- end

-------------------------------------------

class "sim_stay_point"

function sim_stay_point:__init(squad, stay_defended)
	self.name = "stay_point"
	self.squad = squad -- SRP
	self.board = squad.board
--	self.player_id = squad.player_id
--	self.squad_id = squad.squad_id
--	self.src_smrt_id = squad.smart_id
	self.stay_defended = stay_defended or false
end

function sim_stay_point:save(packet)
	set_save_marker(packet, "save", false, "sim_stay_point")
	packet:w_bool(self.stay_defended)
	if self.next_point_id == nil then
		packet:w_u16(-1)
	else
		packet:w_u16(self.next_point_id)
	end
	if self.begin_time == nil then
		packet:w_bool(false)
	else
		packet:w_bool(true)
		utils.w_CTime(packet, self.begin_time)
	end
	set_save_marker(packet, "save", true, "sim_stay_point")
end

function sim_stay_point:load(packet)
	set_save_marker(packet, "load", false, "sim_stay_point")
	self.stay_defended = packet:r_bool()
	self.next_point_id = packet:r_u16()
	if self.next_point_id == 65535 then
		self.next_point_id = nil
	end
	local flag = packet:r_bool()
	if flag then
		self.begin_time = utils.r_CTime(packet)
	end
	set_save_marker(packet, "load", true, "sim_stay_point")
end

function sim_stay_point:is_finished()

	local squad = self.squad
	local task_entity_id = squad.random_tasks[3]
	local tm = task_manager.get_task_manager()

	-- We can't leave smart if we've assigned the player a recover item task.

	if task_entity_id ~= nil then
		local task = tm:get_task_by_entity_id(task_entity_id)
		if task.status == "selected" then
			return false
		end
	end

	-- We can't leave smart if we've assigned the player a bring item task.

	task_entity_id = squad.random_tasks[4]

	if task_entity_id ~= nil then
		local task = tm:get_task_by_entity_id(task_entity_id)
		if task.status == "selected" then
			return false
		end
	end

	-- We can't leave smart if we are delay attacking.

	if squad.delayed_attack_task ~= nil then
--		dbgmsg("delayed_attack_task is not nil for "..trans(squad.player_id).." squad with ID "..tostring(squad.squad_id).." and npc count "..tostring(squad.npc_count)..".")
		return false
	end

	local src_smart = self.board.smarts[squad.smart_id].smrt

	if src_smart.combat_manager:get_squad_stage(squad) ~= "idle" then
		return false
	end

	if self.board.players[squad.player_id].squad_target_cache[squad.squad_id] ~= squad.assigned_target_smart_id then
		return true
	end

	if self.stay_defended == true then
		return true
	end

	-- We can't leave smart if we've stayed on it for less than 36 real seconds.

	if get_game_time():diffSec(self.begin_time) < 360 then
		return false
	end

	if squad.sim_combat_id ~= nil then
		src_smart.combat_manager:unregister_squad(squad)
	end

	self.begin_time = nil

	return true
end

function sim_stay_point:make()
	local squad = self.squad
--	if squad ~= nil then
--		squad.current_action = self -- superfluous
		local src_smart = self.board.smarts[squad.smart_id].smrt
		src_smart.combat_manager:register_squad(squad)
		self.begin_time = get_game_time()
		self:init_defend_smart_delay(squad)
		squad:refresh()
--	end
end

function sim_stay_point:init_defend_smart_delay(attack_squad)
	if self.delay_attack_id == nil then
		return
	end
	if attack_squad.delayed_attack_task ~= nil then -- if squad is already attacking
		return
	end
	local target_smart_obj = self.board.smarts[self.delay_attack_id].smrt
	if target_smart_obj.combat_manager:point_under_attack() then
		return
	end
	-- No existing tasks for this smart, guaranteed by get_next_action():
--	local tm = task_manager.get_task_manager()
--	if tm:get_tasks_by_smart(self.delay_attack_id) ~= nil then
--		return
--	end
	if db.actor:position():distance_to_sqr(target_smart_obj.position) <= PLAYER_HELP_MAX_RADIUS then
		local tm = task_manager.get_task_manager()
		for k, task in pairs (tm.task_info) do
			local task_type = task.type
			if task_type == "defend_smart" or task_type == "defend_smart_delay" then
				return
			end
		end
		local task = tm:select_task("defend_smart_delay", target_smart_obj, self.delay_attack_defender)
		if task.status ~= "selected" then
			attack_squad.delayed_attack_task = task.entity_id
			task.src_squad_id = attack_squad.squad_id
			task:give_task(self.delay_attack_defender)
		end
	end
end

-- function sim_stay_point:print(space)
-- end

function sim_stay_point:finalize()
end