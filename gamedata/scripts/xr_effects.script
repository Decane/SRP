local sim = _G.sim

--'------------------------------------------------------
--' UI functions
--'------------------------------------------------------

function disable_ui_elements(actor, npc, p)
--	local i, v = 0, 0
	for i, v in pairs (p) do
		if v == "all" then
			actor:hide_weapon()
			level.disable_input()
			level.hide_indicators_safe()
			break
		elseif v == "weapon" then
			actor:hide_weapon()
		elseif v == "input" then
			level.disable_input()
		elseif v == "hud" then
			level.hide_indicators_safe()
		end
	end
end

function disable_ui(actor)
--	local actor = db.actor
	if actor:is_talking() then
		actor:stop_talk()
	end
	level.show_weapon(false)
	level.disable_input()
	level.hide_indicators_safe()
	local hud = get_hud()
	hud:HideActorMenu()
	hud:HidePdaMenu()
end

function enable_ui()
	level.show_weapon(true)
	level.enable_input()
	level.show_indicators()
end

local cam_effector_playing_object_id = nil

function run_cam_effector(actor, npc, p)
	local effector_name = p[1]
	if effector_name then
		local num = tonumber(p[2])
		if not num or num <= 0 then
			num = 1000 + math.random(100)
		end
		local loop = p[3] == "true"
		level.add_cam_effector("camera_effects\\" .. effector_name .. ".anm", num, loop, "xr_effects.cam_effector_callback")
		cam_effector_playing_object_id = npc:id()
	else
		abort("[xr_effects.run_cam_effector]: Parameter missing.")
	end
end

function stop_cam_effector(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local num = tonumber(p1)
		if num and num > 0 then
			level.remove_cam_effector(num)
		end
	else
		abort("[xr_effects.stop_cam_effector]: Parameter missing.")
	end
end

function run_cam_effector_global(actor, npc, p)
	local effector_name = p[1]
	if effector_name then
		local num = tonumber(p[2])
		if not num or num <= 0 then
			num = 1000 + math.random(100)
		end
		level.add_cam_effector2("camera_effects\\" .. effector_name .. ".anm", num, false, "xr_effects.cam_effector_callback")
		cam_effector_playing_object_id = npc:id()
	else
		abort("[xr_effects.run_cam_effector_global]: Parameter missing.")
	end
end

function cam_effector_callback()
	if cam_effector_playing_object_id == nil then
		return
	end
	local obj_st = db.storage[cam_effector_playing_object_id]
	if obj_st == nil or obj_st.active_scheme == nil then
		return
	end
	if obj_st[obj_st.active_scheme].signals == nil then
		return
	end
	obj_st[obj_st.active_scheme].signals["cameff_end"] = true
end

function run_postprocess(actor, npc, p)
	local ppe_name = p[1]
	if ppe_name then
		local num = tonumber(p[2])
		if not num or num <= 0 then
			num = 2000 + math.random(100)
		end
		local loop = p[3] == "true"
		level.add_pp_effector(ppe_name .. ".ppe", num, loop)
	else
		abort("[xr_effects.run_postprocess]: Parameter missing.")
	end
end

function run_tutorial(actor, npc, p)
	game.start_tutorial(p[1])
end

function teleport_actor(actor, npc, p)
--	local actor = db.actor
	local point, look = patrol(p[1]), patrol(p[2])
	actor:set_actor_position(point:point(0))
	local dir = look:point(0):sub(point:point(0))
	actor:set_actor_direction(-dir:getH())
end

function add_custom_static(actor, npc, p)
	local p1, p2 = p[1], p[2]
	if p1 and p2 then
		local cs = get_hud():AddCustomStatic(p1, true)
		cs:wnd():SetTextST(p2)
	else
		abort("[xr_effects.add_custom_static]: Parameter(s) missing.")
	end
end

function remove_custom_static(actor, npc, p)
	local p1 = p[1]
	if p1 then
		get_hud():RemoveCustomStatic(p1)
	else
		abort("[xr_effects.remove_custom_static]: Parameter missing.")
	end
end

function add_cs_text(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local hud = get_hud()
		local cs_text = hud:GetCustomStatic("text_on_screen_center")
		if cs_text then
			hud:RemoveCustomStatic("text_on_screen_center")
		end
		cs_text = hud:AddCustomStatic("text_on_screen_center", true)
		cs_text:wnd():SetTextST(game.translate_string(p1))
	else
		abort("[xr_effects.add_cs_text]: Parameter missing.")
	end
end

function del_cs_text()
	local hud = get_hud()
	local cs_text = hud:GetCustomStatic("text_on_screen_center") -- unlocalized in vanilla
	if cs_text then
		hud:RemoveCustomStatic("text_on_screen_center")
	end
end

--[[

function enable_ui_elements(actor, npc, p)
--	local i, v = 0, 0
	for i, v in pairs (p) do
		if v == "all" then
			level.show_indicators()
			level.enable_input()
			actor:restore_weapon()
			break
		elseif v == "weapon" then
			actor:restore_weapon()
		elseif v == "input" then
			level.enable_input()
		elseif v == "hud" then
			level.show_indicators()
		end
	end
end

function stop_postprocess(actor, npc, p)
	local num = tonumber(p[1])
	if num and num > 0 then
		level.remove_pp_effector(num)
	end
end

function run_tutorial_if_newbie(actor, npc, p)
	if has_alife_info("esc_trader_newbie") then
		game.start_tutorial(p[1])
	end
end

function run_cf(cf_name)
	local motion = "camera_effects\\" .. cf_name.. ".anm"
	level.add_cam_effector2(motion, 123, false, "")
end

]]

--'------------------------------------------------------
--' Inventory functions
--'------------------------------------------------------

function relocate_actor_inventory_to_box(actor, npc, p)
	local inv_box_1 = level_object_by_sid(p[1]) -- unlocalized in vanilla
	local function transfer_object_item(item)
		local sect = item:section()
		if sect ~= "wpn_binoc" and sect ~= "wpn_knife" and sect ~= "device_torch" then
			actor:transfer_item(item, inv_box_1)
		end
	end
	actor:inventory_for_each(transfer_object_item)
end

function take_money(actor, npc, p)
--	local actor = db.actor
	local num = p[1]
	local act_mon = actor:money()
	if num == "all" or act_mon < num then
		num = act_mon
	end
	actor:give_money(-num)
--	game_stats.money_quest_update(-num)
	xr_statistic.inc_spent_money_counter(num)
	news_manager.relocate_money(actor, "out", num)
end

function give_actor(actor, npc, p)
--	local sim = alife()
	local vec = vector()
	for k, v in pairs (p) do
		sim:create(v, vec, 0, 0, 0)
	end
end

function give_items(actor, npc, p)
--	local sim = alife()
	local vec = vector()
	local npc_id = npc:id()
	for i, v in pairs (p) do
		sim:create(v, vec, 0, 0, npc_id)
	end
end

--[[

function relocate_money_to(actor, npc, p)
	dialogs.relocate_money(level_object_by_sid(p[1]), p[2], "out")
end

local drop_point, drop_object = 0, 0

local function drop_object_item(item)
	drop_object:drop_item_and_teleport(item, drop_point)
end

function drop_actor_inventory(actor, npc, p)
	local p1 = p[1]
	if p1 then
		drop_point = patrol(p1):point(0)
		drop_object = actor
		actor:inventory_for_each(drop_object_item)
	end
end

function drop_npc_inventory(actor, npc, p) -- FIXME: drop_npc_inventory doesn't work
	local p1 = p[1]
	if p1 then
		drop_point = patrol(p1):point(0)
		drop_object = npc
		npc:inventory_for_each(drop_object_item)
	end
end

function drop_npc_item(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local item = npc:object(p1)
		if item then
			npc:drop_item(item)
		end
	end
end

function drop_npc_items(actor, npc, p)
	local item
	for i, v in pairs (p) do
		item = npc:object(v)
		if item then
			npc:drop_item(item)
		end
	end
end

function play_particle_on_path(actor, npc, p)
	local name, path = p[1], p[2]
	if name == nil or path == nil then
		return
	end

	local point_prob = p[3]
	if point_prob == nil then
		point_prob = 100
	end

	local path = patrol(path)
	local count, rand, particle = path:count(), math.random
	for a = 0, count - 1 , 1 do
		if rand(100) <= point_prob then
			particle = particles_object(name)
			particle:play_at_pos(path:point(a))
		end
	end
end

]]

--'------------------------------------------------------
--' NPC/actor state functions
--'------------------------------------------------------

function kill_actor(actor)
--	local actor = db.actor
	actor:kill(actor)
end

function hit_npc(actor, npc, p)
	local p1, h = p[1], hit()
	h.draftsman = npc
	h.type = hit.wound
	if type(p1) == 'number' then
		local hitter = level_object_by_sid(p1)
		if not hitter then
			return
		end
		local p5 = p[5]
		if p5 and p5 == 'true' then
			h.draftsman = hitter
			h.direction = hitter:position():sub(npc:position())
		else
			h.direction = npc:position():sub(hitter:position())
		end
	else
		local p5 = p[5]
		if p5 and p5 == 'true' then
			h.draftsman = nil
			h.direction = npc:position():sub(patrol(p1):point(0))
		else
			h.direction = patrol(p1):point(0):sub(npc:position())
		end
	end
	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]
	npc:hit(h)
end

function hit_obj_chemical(actor, npc, p)
	local obj = level_object_by_sid(p[1])
	if not obj then
		return
	end
	local h = hit()
	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]
	local p5, sid = p[5], nil
	if p5 then
		sid = tonumber(p5)
		if sid then
			sid = level_object_by_sid(sid)
			if sid then
				h.direction = vector():sub(sid:position(), obj:position())
			end
		else
			h.direction = vector():sub(patrol(p5):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end
	h.draftsman = sid or npc
	h.type = hit.chemical_burn
	obj:hit(h)
end

function hit_obj_fire_wound(actor, npc, p)
	local obj = level_object_by_sid(p[1])
	if not obj then
		return
	end
	local h = hit()
	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]
	local p5, sid = p[5], nil
	if p5 then
		sid = tonumber(p5)
		if sid then
			sid = level_object_by_sid(sid)
			if sid then
				h.direction = vector():sub(sid:position(), obj:position())
			end
		else
			h.direction = vector():sub(patrol(p5):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end
	h.draftsman = sid or npc
	h.type = hit.fire_wound
	obj:hit(h)
end

function hit_npc_from_actor(actor, npc, p)
	local h = hit()
	local sid = nil
	h.draftsman = actor
	h.type = hit.wound
	local p1 = p[1]
	if p1 then
		sid = tonumber(p1)
		if sid then
			sid = level_object_by_sid(sid)
			if sid then
				h.direction = actor:position():sub(sid:position())
			end
		else
			h.direction = actor:position():sub(npc:position())
		end
	else
		sid = npc
	end
	h:bone("bip01_spine")
	h.power = 0.001
	h.impulse = 0.001
	sid:hit(h)
end

function hit_actor(actor, npc, p)
	local h = hit()
	h.direction = vector():set(0, 0, 0)
	h.draftsman = actor
	h.type = hit.shock
	h:bone("bip01_spine")
	h.power = tonumber(p[1]) or 0.001
	h.impulse = 0.001
	actor:hit(h)
end

function restore_health(actor, npc)
	npc:wounded(false) -- SRP
	npc.health = 1
end

function kill_npc(actor, npc, p)
	local n = npc
	local p1 = p[1]
	if p1 then
		n = level_object_by_sid(tonumber(p1))
	end
	if n ~= nil then
		if n:alive() then
			n:kill(n)
		end
	end
end

--[[

function hit_obj(actor, npc, p)
	local obj = level_object_by_sid(p[1])
	if not obj then
		return
	end
	local h = hit()
	h:bone(p[2])
	h.power = p[3]
	h.impulse = p[4]
	local p5, sid = p[5], nil
	if p5 then
		sid = tonumber(p5)
		if sid then
			sid = level_object_by_sid(sid)
			if sid then
				h.direction = vector():sub(sid:position(), obj:position())
			end
		else
			h.direction = vector():sub(patrol(p5):point(0), obj:position())
		end
	else
		h.direction = vector():sub(npc:position(), obj:position())
	end
	h.draftsman = sid or npc
	h.type = hit.wound
	obj:hit(h)
end

function hit_by_killer(actor, npc, p)
	local n = npc
	if not n then
		return
	end
	local t = db.storage[n:id()].death
	if t == nil or t.killer == -1 then
		return
	end
	local killer = db.storage[t.killer]
	if killer == nil then
		return
	end
	local p1, p2, h = n:position(), killer:position(), hit()
	h.draftsman = n
	h.type = hit.wound
	h.direction = utils.vector_copy_by_val(p1):sub(p2)
	h.bone = p[1]
	h.power = p[2]
	h.impulse = p[3]
	n:hit(h)
end

function death_hit(actor, npc, p)
	local draftsman = level_object_by_sid(p[1])
	local hitted_obj = (p[2] ~= nil and level_object_by_sid(p[2])) or npc
	if draftsman == nil or hitted_obj == nil then
		return
	end
	local h = hit()
	h.power = 1000
	h.direction = hitted_obj:direction()
	h.draftsman = draftsman
	h.impulse = 1
	h.type = hit.wound
	hitted_obj:hit(h)
end

function sniper_fire_mode(actor, npc, p)
	if p[1] == "true" then
		npc:sniper_fire_mode(true)
	else
		npc:sniper_fire_mode(false)
	end
end

]]

--'------------------------------------------------------
--' Abuse functions
--'------------------------------------------------------

function actor_punch(npc)

	local act = db.actor
	if act:position():distance_to_sqr(npc:position()) > 4 then
		return
	end

	set_inactivate_input_time(30)
	level.add_cam_effector("camera_effects\\fusker.anm", 999, false, "")

	local active_slot = act:active_slot()
	if not (active_slot == 1 or active_slot == 2) then
		return
	end

	local active_item = act:active_item()
	if active_item then
		act:drop_item(active_item)
	end
end

function clearAbuse(npc)
	xr_abuse.clear_abuse(npc)
end

--'------------------------------------------------------
--' Counter functions
--'------------------------------------------------------

function inc_counter(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local inc_value = p[2] or 1
		local new_value = xr_logic.pstor_retrieve(actor, p1, 0) + inc_value
		xr_logic.pstor_store(actor, p1, new_value)
	else
		abort("[xr_effects.inc_counter]: Parameter missing.")
	end
end

function dec_counter(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local new_value = xr_logic.pstor_retrieve(actor, p1, 0) - 1
		local val = new_value >= 0 and new_value or 0 -- ensures counter not < 0
		xr_logic.pstor_store(actor, p1, val)
	else
		abort("[xr_effects.dec_counter]: Parameter missing.")
	end
end

function set_counter(actor, npc, p)
	local p1, p2 = p[1], p[2]
	if p1 and p2 then
		xr_logic.pstor_store(actor, p1, p2)
	else
		abort("[xr_effects.set_counter]: Parameter(s) missing.")
	end
end

--'------------------------------------------------------
--' Helicopter functions
--'------------------------------------------------------

function heli_die(actor, heli)
	bind_heli.heli_die(heli)
end

--[[

function heli_set_enemy_actor(actor, npc)
	local st = db.storage[npc:id()]
	if not st.combat.enemy_id then
		if actor:alive() then
			st.combat.enemy_id = actor:id()
			heli_snd.play_snd(st, heli_snd.snd_see_enemy, 1)
		end
	end
end

function heli_set_enemy(actor, npc, p)
	local st = db.storage[npc:id()]
	if not st.combat.enemy_id then
		local obj = level_object_by_sid(p[1])
		if obj:alive() then
			st.combat.enemy_id = obj:id()
			heli_snd.play_snd(st, heli_snd.snd_see_enemy, 1)
		end
	end
end

function heli_clear_enemy(actor, npc)
	db.storage[npc:id()].combat:forget_enemy()
end

function heli_start_flame(actor, npc)
	bind_heli.heli_start_flame(npc)
end

]]

--'------------------------------------------------------
--' Weather functions
--'------------------------------------------------------

function update_weather(actor, npc, p)
	local p1 = p[1]
	if p1 == "true" or p1 == nil then
		level_weathers.get_weather_manager():select_weather(true)
	elseif p1 == "false" then
		level_weathers.get_weather_manager():select_weather(false)
	end
end

--[[

function start_small_reject(actor, npc)
	level.set_weather_fx("fx_surge_day_3")
	level.add_pp_effector("vibros_p.ppe", 1974, false)
	this.aes_earthshake(npc)
end

function start_full_reject()
	level.set_weather_fx("fx_surge_day_3")
	level.remove_pp_effector(1974)
	level.remove_cam_effector(1975)
	level.add_cam_effector("camera_effects\\earthquake.anm", 1975, true, "")
end

function stop_full_reject()
	level.remove_pp_effector(1974)
	level.remove_cam_effector(1975)
end

function run_weather_pp(actor, npc, p)
	local weather_fx = p[1]
	if weather_fx == nil then
		weather_fx = "fx_surge_day_3"
	end
	level.set_weather_fx(weather_fx)
end

]]

--'------------------------------------------------------
--' Credits 'n' such
--'------------------------------------------------------

function exit_game()
	get_console():execute("quit")
end

function game_disconnect()
	local c = get_console()
	c:execute("disconnect")
	c:execute_deferred("main_menu off")
	c:execute_deferred("hide")
end

function game_credits()
	db.gameover_credits_started = true
	game.start_tutorial("credits_seq")
end

function after_credits()
	local c = get_console()
	c:execute("main_menu on")
end

function stop_sr_cutscene(actor, sr)
	local sr_st = db.storage[sr:id()]
	if sr_st.active_scheme ~= nil then
		sr_st[sr_st.active_scheme].signals["cam_effector_stop"] = true
	end
end

function start_marsh_intro() -- called from XML, so 'actor' not passed
	db.actor:give_info_portion("mar_intro_start")
end

function quit()
	get_console():execute("quit")
end

--[[

function game_over()
	if db.gameover_credits_started ~= true then
		return
	end
	local c = get_console()
	c:execute("main_menu on")
end

]]

function on_tutor_gameover_stop()
	local c = get_console()
	c:execute("main_menu on")
end

function on_tutor_gameover_quickload()
	local c = get_console()
	c:execute("load_last_save")
end

--'------------------------------------------------------
--' Spawn & destroy functions
--'------------------------------------------------------

function spawn_object(actor, obj, p)

	local spawn_sect, path_name = p[1], p[2]
	if spawn_sect == nil or path_name == nil then
		abort("[xr_effects.spawn_object]: Parameter(s) missing.")
	end

	if not level.patrol_path_exists(path_name) then
		abort("[xr_effects.spawn_object]: Path '%s' does not exist for object '%s'.", tostring(path_name), obj:name())
	end

	local ptr = patrol(path_name)
	local index = p[3] or 0
	local se_obj = sim:create(spawn_sect, ptr:point(index), ptr:level_vertex_id(0), ptr:game_vertex_id(0))

	if IsStalker(nil, se_obj:clsid()) then
		local yaw = p[4] or 0
		se_obj:o_torso().yaw = yaw * math.pi / 180
	end
end

function spawn_object_in(actor, obj, p)

	local spawn_sect, target_name = p[1], p[2]
	if spawn_sect == nil or target_name == nil then
		abort("[xr_effects.spawn_object_in]: Parameter(s) missing.")
	end

--	local sim = alife()
	local box = sim:object(target_name)
	if box == nil then
		abort("[xr_effects.spawn_object_in]: Box '%s' does not exist.", tostring(target_name))
	end

--	local obj = sim:create(spawn_sect, vector(), 0, 0, box.id)
	sim:create(spawn_sect, vector(), 0, 0, box.id)
end

function spawn_npc_in_zone(actor, obj, p)

	local spawn_sect, zone_name = p[1], p[2]
	if spawn_sect == nil or zone_name == nil then
		abort("[xr_effects.spawn_npc_in_zone]: Parameter(s) missing.")
	end

	local zone = db.zone_by_name[zone_name]
	if zone == nil then
		abort("[xr_effects.spawn_npc_in_zone]: Zone '%s' does not exist.", tostring(zone_name))
	end

	local spawned_obj = sim:create(spawn_sect, zone:position(), zone:level_vertex_id(), zone:game_vertex_id())

	spawned_obj.sim_forced_online = true
	spawned_obj.squad = 1 or p[3] -- always 1

	db.script_ids[spawned_obj.id] = zone_name
end

function destroy_object(actor, obj, p)

	local p1 = p[1]
--	local sim = alife()
	local sobj

	if p1 == nil then
		sobj = sim:object(obj:id())
	else
--		if p1 == nil then
--			abort("[xr_effects.destroy_object]: Parameter missing.")
--		end

		local sid = tonumber(p1)

		if sid then
			sobj = sim:story_object(sid)
--			if sobj == nil then
--				abort("[xr_effects.destroy_object]: Object with story_id '%s' does not exist.", tostring(sid))
--			end
		else
			local p2 = p[2]
			if p2 then
				local target_position, target_id, target_init = xr_remark.initialize_gulag_target(obj, p1..","..p2)
				sobj = sim:object(target_id)
			else
				abort("[xr_effects.destroy_object]: Second parameter missing.")
			end
		end
	end

	if sobj == nil then
		return
	end

	if sobj.squad_id == nil then
		sim:release(sobj, true)
	else
		sim_board.get_sim_board().squads[sobj.squad_id]:remove_npc(sobj.id)
	end
end

function barrel_explode(actor, npc, p)
	local expl_obj = level_object_by_sid(p[1])
	if expl_obj ~= nil then
		expl_obj:explode(0)
	end
end

--'------------------------------------------------------
--' Activation functions
--'------------------------------------------------------
--[=[
function turn_on_fire_zone(actor, npc, p)
	bind_campfire.fire_zones_table[p[1]]:turn_on()
end

function turn_off_fire_zone(actor, npc, p)
	bind_campfire.fire_zones_table[p[1]]:turn_off()
end
]=]
function enable_level_changer(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local obj = level_object_by_sid(tonumber(p1))
		if obj then
			local sobj = db.storage[obj:id()] and db.storage[obj:id()].s_obj
			if sobj then
				sobj.enabled = true
				sobj.hint = "level_changer_invitation"
			else
				return
			end
			obj:enable_level_changer(true)
			level_tasks.add_lchanger_location()
			obj:set_level_changer_invitation("level_changer_invitation")
		end
	else
		abort("[xr_effects.enable_level_changer]: Parameter missing.")
	end
end

function disable_level_changer(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local obj = level_object_by_sid(tonumber(p1))
		if obj then
			local sobj = db.storage[obj:id()] and db.storage[obj:id()].s_obj
			if not sobj then
				return
			end
			obj:enable_level_changer(false)
			level_tasks.del_lchanger_mapspot(tonumber(p1))
			sobj.enabled = false
			local p2 = p[2]
			if p2 == nil then
				obj:set_level_changer_invitation("level_changer_disabled")
				sobj.hint = "level_changer_disabled"
			else
				obj:set_level_changer_invitation(p2)
				sobj.hint = p2
			end
		end
	else
		abort("[xr_effects.disable_level_changer]: Parameter missing.")
	end
end

function enable_anomaly(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local obj = level_object_by_sid(p1)
		if not obj then
			abort("[xr_effects.enable_anomaly]: No anomaly corresponds to story_id '%s'.", tostring(p1))
		end
		obj:enable_anomaly()
	else
		abort("[xr_effects.enable_anomaly]: Parameter missing.")
	end
end

function disable_anomaly(actor, npc, p)
	local p1 = p[1]
	if p1 then
		local obj = level_object_by_sid(p1)
		if not obj then
			abort("[xr_effects.disable_anomaly]: Anomaly with story_id '%s' does not exist.", tostring(p1))
		end
		obj:disable_anomaly()
	else
		abort("[xr_effects.disable_anomaly]: Parameter missing.")
	end
end

function activate_weapon_slot(actor, npc, p)
	actor:activate_slot(p[1])
end

function bridge_down()
	db.bridge_by_name["red_bridge"]:anim_forward()
end

function bridge_up()
	db.bridge_by_name["red_bridge"]:anim_backward()
end

function bridge_stop()
	db.bridge_by_name["red_bridge"]:anim_stop()
end

function anim_obj_down(actor, npc, p)
	local p1 = p[1]
	if p1 then
		db.anim_obj_by_name[p1]:anim_forward()
	else
		abort("[xr_effects.anim_obj_down]: Parameter missing.")
	end
end

--[[

function turn_off(actor, npc, p)
	local obj = level_object_by_sid(p[1])
	if not obj then
		abort("TURN_OFF [%s]. Target object does not exist", npc:name())
--		return
	end
	obj:get_hanging_lamp():turn_off()
end

function turn_off_object(actor, npc)
	npc:get_hanging_lamp():turn_off()
end

function turn_on(actor, npc, p)
	local obj = level_object_by_sid(p[1])
	if not obj then
		abort("TURN_ON [%s]. Target object does not exist", npc:name())
--		return
	end
	obj:get_hanging_lamp():turn_on()
end

function turn_on_and_force(actor, npc, p)
	local obj = level_object_by_sid(p[1])
	if not obj then
		abort("TURN_ON_AND_FORCE. Target object does not exist")
--		return
	end
	local p2, p3 = p[2], p[3]
	if p2 == nil then
		p2 = 55
	end
	if p3 == nil then
		p3 = 14000
	end
	obj:set_const_force(vector():set(0,1,0), p2, p3)
	obj:start_particles("weapons\\light_signal", "link")
	obj:get_hanging_lamp():turn_on()
end

function turn_off_and_force(actor, npc, p)
	local obj = level_object_by_sid(p[1])
	if not obj then
		abort("TURN_OFF [%s]. Target object does not exist", npc:name())
--		return
	end
	obj:stop_particles("weapons\\light_signal", "link")
	obj:get_hanging_lamp():turn_off()
end

function turn_on_object(actor, npc)
	npc:get_hanging_lamp():turn_on()
end

function turn_off_object(actor, npc)
	npc:get_hanging_lamp():turn_off()
end

function anim_obj_up(actor, npc, p)
	local p1 = p[1]
	if p1 ~= nil then
		db.anim_obj_by_name[p1]:anim_backward()
	end
end

function anim_obj_stop(actor, npc, p)
	local p1 = p[1]
	if p1 ~= nil then
		db.anim_obj_by_name[p1]:anim_stop()
	end
end

]]

--'------------------------------------------------------
--' Sound functions
--'------------------------------------------------------

function play_sound(actor, obj, p)
	local p1 = p[1]
	if p1 then
		local p3 = p[3]
		local point = sim_board.get_sim_board().smarts_by_names[p3]
		point = point and point.id or p3 -- if p[3] == nil then point = nil; no problem, we don't need it - same goes for p[2]
		xr_sound.set_sound_play(obj:id(), p1, p[2], point)
	else
		abort("[xr_effects.play_sound]: Parameter missing.")
	end
end

function stop_sound(actor, npc)
	xr_sound.stop_sounds_by_id(npc:id())
end

function play_sound_looped(actor, obj, p)
--	local theme = p[1]
	xr_sound.play_sound_looped(obj:id(), p[1])
end

function stop_sound_looped(actor, obj)
	xr_sound.stop_sound_looped(obj:id())
end

--[[

function play_snd()
end

function play_snd_from_obj()
end

function play_snd_now()
end

]]

--'------------------------------------------------------
--' Alife & simulation functions
--'------------------------------------------------------

function get_stalker_for_new_job(actor, npc, p)
	xr_gulag.find_stalker_for_job(npc, p[1])
end

function switch_to_desired_job(actor, npc)
	xr_gulag.switch_to_desired_job(npc)
end

function start_sim()
	sim_board.get_sim_board():start_sim()
end

function stop_sim()
	sim_board.get_sim_board():stop_sim()
end

function update_faction_brain(actor, obj, p)
	local p1 = p[1]
	if p1 then
		local faction = sim_board.get_sim_board().players[p1]
		if faction == nil then
			abort("[xr_effects.update_faction_brain]: Faction with identifier '%s' does not exist.", tostring(p1))
		end
		faction.brain:calculate_current_expansion()
	else
		abort("[xr_effects.update_faction_brain]: Parameter missing.")
	end
end

function create_squad(actor, obj, p)

	local squad_id, smart_name = p[1], p[2]
	if squad_id == nil or smart_name == nil then
		abort("[xr_effects.create_squad]: Parameter(s) missing.")
	end

	local ltx = sim_board.squad_ltx
	if not ltx:section_exist(squad_id) then
		abort("[xr_effects.create_squad]: No squad corresponds to squad_id '%s'.", tostring(squad_id))
	end

	local player_name = utils.cfg_get_string(ltx, squad_id, "faction", self, true, "")
	local board = sim_board.get_sim_board()
	local player = board.players[player_name]

	if player == nil then
		abort("[xr_effects.create_squad]: Faction name '%s' does not match faction name of squad with squad_id '%s'.", tostring(player_name), tostring(squad_id))
	end

	local smart = board.smarts_by_names[smart_name]
	if smart == nil then
		abort("[xr_effects.create_squad]: No smart terrain corresponds to smart_name '%s'.", tostring(smart_name))
	end

	local smrt_faction = smart.player_name
	if smrt_faction ~= player_name and smrt_faction ~= "none" then
		return
	end

	local is_autogenerated_id, squad = utils.cfg_get_bool(ltx, squad_id, "auto_id", self, false, false)
	if is_autogenerated_id then
		squad = board:create_squad(player.player_name, sim_squad_scripted.sim_squad_scripted, smart, nil, squad_id)
	else
		squad = board:create_squad(player.player_name, sim_squad_scripted.sim_squad_scripted, smart, squad_id)
	end
--[[
	board:enter_smart(squad, smart.id) -- now done in create_squad()

	local sim = alife()
	for npc_id in pairs (squad.squad_npc) do -- already done in create_squad()
		local npc = sim:object(npc_id)
		board:setup_squad_and_group(npc)
	end
]]
	squad:update()
end

function remove_squad(actor, obj, p)

	local squad_id = p[1]
	if squad_id == nil then
		abort("[xr_effects.remove_squad]: Parameter missing.")
	end

	local board = sim_board.get_sim_board()
	local squad = board.squads[squad_id]

	if squad == nil then
--		abort("[xr_effects.remove_squad]: There is no squad with squad_id '%s'.", tostring(squad_id))
		return
	end

	if squad.current_action ~= nil then
		squad.current_action:finalize()
		squad.current_action = nil
	end

--	board:exit_smart(squad, squad.smart) -- squad.smart is always nil and remove_squad() calls exit_smart() anyway
	board:remove_squad(squad, board.smarts[squad.smart_id].smrt)
end

function kill_squad(actor, obj, p)

	local squad_id = p[1]
	if squad_id == nil then
		abort("[xr_effects.kill_squad]: Parameter missing.")
	end

--	local board = sim_board.get_sim_board()
	local squad = sim_board.get_sim_board().squads[squad_id]

	if squad == nil then
		return
	end

--	local sim = alife()
	for npc_id in pairs (squad.squad_npc) do
		local st_npc = db.storage[npc_id]
		local cl_obj = st_npc and st_npc.object
		if cl_obj == nil then
			sim:object(npc_id).health = 0
		else
			cl_obj:kill(cl_obj)
		end
	end
end

function update_squad(actor, obj, p)

	local squad_id = p[1]
	if squad_id == nil then
		abort("[xr_effects.update_squad]: Parameter missing.")
	end

--	local board = sim_board.get_sim_board()
	local squad = sim_board.get_sim_board().squads[squad_id]

	if squad == nil then
--		abort("[xr_effects.update_squad]: There is no squad with squad_id '%s'.", tostring(squad_id))
		return
	end

	squad:update()
end

function clear_smart_terrain(actor, obj, p)

	local smart_name = p[1]
	if smart_name == nil then
		abort("[xr_effects.clear_smart_terrain]: Parameter missing.")
	end

	local board = sim_board.get_sim_board()
	local smart = board.smarts_by_names[smart_name]

	if smart == nil then
		abort("[xr_effects.clear_smart_terrain]: No smart terrain corresponds to smart_name '%s'.", tostring(smart_name))
	end

	for k, squad in pairs (board.smarts[smart.id].squads) do
		if squad.current_action ~= nil then
			squad.current_action:finalize()
			squad.current_action = nil
		end
--		board:exit_smart(squad, smart) -- done in remove_squad()
		board:remove_squad(squad, smart)
	end
end

function request_current_squad_stage(actor, obj, p)

	local stage_name = p[1]
	if stage_name == nil then
		abort("[xr_effects.request_current_squad_stage]: Parameter missing.")
	end

	local squad = db.storage[obj:id()].squad_obj
	if squad == nil then
		return false
	end

	local current_action = squad.current_action
	if current_action == nil or current_action.name ~= "attack_point" then
		return false
	end

	local smrt = sim_board.get_sim_board().smarts[current_action.dest_smrt_id].smrt
	smrt.combat_manager:request_squad_stage(squad, stage_name)
end

function set_actor_faction(actor, obj, p)
	local p1 = p[1]
	if p1 then
		sim_board.get_sim_board():set_actor_community(p1)
	else
		abort("[xr_effects.set_actor_faction]: Parameter missing.")
	end
end

--[[

function disable_combat_handler(actor, npc)
	local st = db.storage[npc:id()]
	if st.combat then
		st.combat.enabled = false
	end
	if st.mob_combat then
		st.mob_combat.enabled = false
	end
end

function disable_combat_ignore_handler(actor, npc)
	local st = db.storage[npc:id()]
	if st.combat_ignore then
		st.combat_ignore.enabled = false
	end
end

]]

--'------------------------------------------------------
--' Quest support functions
--'------------------------------------------------------

function give_inited_task(actor, obj, p)

	local task_type, target_name, faction_name = p[1], p[2], p[3]
	if task_type == nil or target_name == nil or faction_name == nil then
		abort("[xr_effects.give_inited_task]: Parameter(s) missing.")
	end

	local target_obj
	if task_type == "storyline" then
		target_obj = target_name
	elseif task_type == "eliminate_smart" then
		target_obj = sim_board.get_sim_board().smarts_by_names[target_name]
	elseif task_type == "capture_smart" then
		target_obj = sim_board.get_sim_board().smarts_by_names[target_name]
	elseif task_type == "defend_smart" then
		target_obj = sim_board.get_sim_board().smarts_by_names[target_name]
--	elseif task_type == "eliminate_squad" then
--		target_obj = sim_board.get_sim_board().squads[target_name]
	end

	local task = task_manager.get_task_manager():select_task(task_type, target_obj, faction_name)
	task:give_task(faction_name)
end

--[[

function give_task(actor, obj, p)
	local p1 = p[1]
	if p1 then
		task_manager.get_task_manager():give_task(p1)
	else
		abort("[xr_effects.give_task]: Parameter missing.")
	end
end

]]

--'------------------------------------------------------
--' Relation functions
--'------------------------------------------------------

function actor_friend(actor, npc)
--	npc:set_relation(game_object.friend, actor) -- sometimes fails
	npc:set_goodwill(9000, actor) -- this will fail iff the NPC's community_goodwill + community_to_community < -8000, but this cannot happen with an unmodified SRP installation
end

function actor_neutral(actor, npc) -- not used, so no changes necessary
	npc:set_relation(game_object.neutral, actor)
end

function actor_enemy(actor, npc)
--	npc:set_relation(game_object.enemy, actor) -- sometimes fails
	npc:set_goodwill(-3000, actor) -- this will fail iff the NPC's community_goodwill + community_to_community > 2000, but 2000 is the maximum value of this sum with an unmodified SRP installation
end

function set_gulag_relation_actor(actor, npc, p)
	game_relations.set_gulag_relation_actor(p[1], p[2])
end

function set_factions_community(actor, npc, p)
	game_relations.set_factions_community(p[1], p[2], p[3])
end

function set_squad_goodwill(actor, npc, p)
	game_relations.set_squad_goodwill(p[1], p[2])
end

function set_squad_goodwill_to_npc(actor, npc, p)
	game_relations.set_squad_goodwill_to_npc(npc, p[1], p[2])
end

function set_squad_community_goodwill(actor, npc, p)
	game_relations.set_squad_community_goodwill(p[1], p[2], p[3])
end

function set_faction_community_to_actor(actor, npc, p) -- sets faction *goodwill* to player

	local faction, relation = p[1], p[2]
	if faction == nil or relation == nil then
		abort("[xr_effects.set_faction_community_to_actor]: Parameter(s) missing.")
	end

	local rel = 0
	if relation == "enemy" then
		rel = -3000
	elseif relation == "friend" then
		rel = 1000
	end

	actor:set_community_goodwill(faction, rel)

--	for k, squad in pairs (sim_board.get_sim_board().players[faction].squads) do
--		squad:refresh() -- update map icons
--	end
end

function set_level_faction_community(actor, npc, p) -- sets community_goodwill and personal_goodwill towards player of all faction members on a particular level

	local faction, map, relation = p[1], p[2], p[3]
	if faction == nil or map == nil or relation == nil then
		abort("[xr_effects.set_level_faction_community]: Parameter(s) missing.")
	end

	local goodwill = 0
	if relation == "enemy" then
		goodwill = -3000
	elseif relation == "friend" then
		goodwill = 9000 -- vanilla: 1000
	end

	relation_registry.set_community_goodwill(faction, 0, goodwill) -- 0 = actor ID

--	local sim = alife()
	local GG = game_graph()

	for k, squad in pairs (sim_board.get_sim_board().players[faction].squads) do
		local squad_commander = sim:object(squad.commander_id)
		local squad_level = squad_commander and sim:level_name(GG:vertex(squad_commander.m_game_vertex_id):level_id())
		if squad_level == map then
			game_relations.set_squad_goodwill(squad.squad_id, relation)
		end
	end
end

function reset_faction_goodwill(actor, obj, p)

	local faction = p[1]

	if faction == nil then
		abort("[xr_effects.reset_faction_goodwill]: Parameter missing.")
	end

	if sim_board.get_sim_board().players[faction] then
		actor:set_community_goodwill(faction, 0)
	end
end

--[[

function set_gulag_enemy_actor(actor, npc, p)
	local p1 = p[1]
	if p1 then
		xr_gulag.setGulagEnemy(p1, actor)
	end
end

function set_gulag_neutral_actor(actor, npc, p)
	local p1 = p[1]
	if p1 then
		xr_gulag.setGulagNeutral(p1, actor)
	end
end

function set_squad_neutral_to_actor(actor, npc, p)

	local squad_id = p[1]
	local squad = sim_board.get_sim_board().squads[squad_id]
	if squad == nil then
		abort("[xr_effects.set_squad_neutral_to_actor]: Squad ID '%s' is invalid.", tostring(squad_id))
	end

	for npc_id in pairs (squad.squad_npc) do
		local st_npc = db.storage[npc_id]
		local npc_obj = st_npc and st_npc.object
		if npc_obj ~= nil then
			npc_obj:set_relation(game_object.neutral, actor)
		end
	end

end

function set_friends(actor, npc, p)
	for i, v in pairs (p) do
		local npc1 = level_object_by_sid(v)
		if npc1 then
			if npc1:alive() then
				npc:set_relation(game_object.friend, npc1)
				npc1:set_relation(game_object.friend, npc)
			end
		end
	end
end

function set_enemies(actor, npc, p)
	for i, v in pairs (p) do
		local npc1 = level_object_by_sid(v)
		if npc1 then
			if npc1:alive() then
				npc:set_relation(game_object.enemy, npc1)
				npc1:set_relation(game_object.enemy, npc)
			end
		end
	end
end

function change_actor_community(actor, npc, p)
	local p1 = p[1]
	if p1 ~= nil then
		db.actor:set_character_community(p1, 0, 0)
	end
end

function set_npc_sympathy(actor, npc, p)
	local p1 = p[1]
	if p1 ~= nil then
		game_relations.set_npc_sympathy(npc, p1)
	end
end

]]

--'------------------------------------------------------
--' Treasure functions
--'------------------------------------------------------

function give_treasure(actor, npc, p)
	if p[1] == nil then
		abort("[xr_effects.give_treasure]: Parameter missing.")
	end
	for k, v in pairs (p) do
		treasure_manager.give_treasure(v)
	end
end

--'------------------------------------------------------
--' Arena functions
--'------------------------------------------------------

--[[

function purge_arena_items(actor, npc, name)
	xr_zones.purge_arena_items(name[1])
end

function arena_after_fight()
	db.actor:disable_info_portion("arena_first_battle_begin")
	level.add_pp_effector("agr_u_fade.ppe", 1974, false)
	disable_ui()
end

function arena_after_arena()
	get_console():execute("load arena")
end

function arena_camera_begin()
	db.actor:give_info_portion("arena_camera_begin")
	level.add_pp_effector("blink.ppe", 1974, false)
	get_console():execute("r2_dof -0.250000,1.400000,200.000000")
end

function dof_change()
	get_console():execute("r2_dof 0.1,0.2,0.3")
	level.hide_indicators()
end

local function release_object_item(release_item)
	local sim = alife()
	sim:release(sim:object(release_item:id()), true)
end

local arena_items =

{
	[1] = {"wpn_sig550","wpn_beretta","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","medkit","medkit","medkit"},
	[2] = {"wpn_sig550","wpn_beretta","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","medkit","medkit","medkit","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","grenade_f1","grenade_f1","grenade_f1","medkit"},
	[3] = {"wpn_sig550","wpn_beretta","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","medkit","medkit","medkit","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","grenade_f1","grenade_f1","grenade_f1","medkit"},
	[4] = {"wpn_sig550","wpn_beretta","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","medkit","medkit","medkit","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","grenade_f1","grenade_f1","grenade_f1","medkit"},
	[5] = {"wpn_sig550","wpn_beretta","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","medkit","medkit","medkit","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","ammo_9x19_fmj","ammo_5.56x45_ss190","grenade_f1","grenade_f1","grenade_f1","medkit"}
}

function release_actor_inventory1(actor)
	actor:inventory_for_each(release_object_item)
	local act = db.actor
	for k, v in pairs (arena_items[1]) do
		alife():create(v, act:position(), act:level_vertex_id(), act:game_vertex_id(), act:id())
	end
end

function release_actor_inventory2(actor)
	actor:inventory_for_each(release_object_item)
	local act = db.actor
	for k, v in pairs (arena_items[2]) do
		alife():create(v, act:position(), act:level_vertex_id(), act:game_vertex_id(), act:id())
	end
end

function release_actor_inventory3(actor)
	actor:inventory_for_each(release_object_item)
	local act = db.actor
	for k, v in pairs (arena_items[3]) do
		alife():create(v, act:position(), act:level_vertex_id(), act:game_vertex_id(), act:id())
	end
end

function release_actor_inventory4(actor)
	actor:inventory_for_each(release_object_item)
	local act = db.actor
	for k, v in pairs (arena_items[4]) do
		alife():create(v, act:position(), act:level_vertex_id(), act:game_vertex_id(), act:id())
	end
end

function release_actor_inventory5(actor)
	actor:inventory_for_each(release_object_item)
	local act = db.actor
	for k, v in pairs (arena_items[5]) do
		alife():create(v, act:position(), act:level_vertex_id(), act:game_vertex_id(), act:id())
	end
end

]]

--'------------------------------------------------------
--' Stancia functions
--'------------------------------------------------------

function stc_stop_particle_sounds()

	local particles_table =
	{
		[1] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
		[2] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
		[3] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
		[4] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
		[5] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")}
	}
	for i = 1, 5 do
		if particles_table[i].sound:playing() then
			particles_table[i].sound:stop()
		end
	end
end

function stc_activate_weapon(actor, npc, p)
	local object = actor:object(p[1])
	if object ~= nil then
		actor:make_item_active(object)
	end
end

function stc_create_some_csky_stalkers(actor, npc, p)
--	local sim = alife()
	local patrol_point = patrol(p[1])
	local rand = math.random
	local patrol_point_count = patrol_point:count()
	for i = 1, 5 do
		local rnd_point = ((patrol_point_count == 1) and 1) or rand(0, patrol_point_count - 1)
		local obj = sim:create(p[2], patrol_point:point(rnd_point), patrol_point:level_vertex_id(rnd_point), patrol_point:game_vertex_id(rnd_point))
		obj.sim_forced_online = true
	end
end

function stc_create_some_monolith_stalkers(actor, npc, p)

	local particles_table =
	{
		[1] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
		[2] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
		[3] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
		[4] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
		[5] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")}
	}
	local patrol_path = patrol(p[1])
	local used_points = {}
	for i = 1, patrol_path:count() do
		used_points[i] = i - 1
	end
--	local actor = db.actor
	local rand = math.random
	local rem = table.remove
--	local sim = alife()
	for i = 1, p[3] do
		local rnd_point = rand(1, #used_points)
		local patrol_point = used_points[rnd_point]
		local patrol_path_point = patrol_path:point(patrol_point)
		particles_table[i].particle:play_at_pos(patrol_path_point)
		particles_table[i].sound:play_at_pos(actor, patrol_path_point, 0, sound_object.s3d)
		local obj = sim:create(p[2], patrol_path_point, patrol_path:level_vertex_id(patrol_point), patrol_path:game_vertex_id(patrol_point))
		obj.sim_forced_online = true
		obj.squad = 1 or p[4] -- always 1
		rem(used_points, rnd_point)
	end
	stc_boom()
end

function stc_change_tsg(actor, npc, p)
	npc:change_team(p[1], p[2], p[3])
end

function stc_boom(actor, npc, p)
	local p1 = p and p[1]
	if p1 then
		xr_sound.set_sound_play(0, p1) -- 0 = actor ID
	else
		xr_sound.set_sound_play(0, "blowout_begin")
	end
	level.add_cam_effector("camera_effects\\shell_shock.anm", 20080501, false, "")
	level.add_cam_effector("camera_effects\\earthquake_00.anm", 203450545, false, "")
	level.add_pp_effector("snd_shock.ppe", 20080401, false)
	level.set_pp_effector_factor(20080401, 0, 1)
end

function activate_surge(actor, npc, p)
	local time = tonumber(p[1])
	if time ~= nil then
		xr_surge_hide.activate_surge(time)
	end
end

function start_surge_on_stancia_2(actor, npc, p)
	local fx = p[1] or "fx_surge_day_3_stancia"
	level.set_weather_fx(fx)
	xr_sound.set_sound_play(0, "blowout_begin") -- 0 = actor ID
	level.add_cam_effector("camera_effects\\earthquake.anm", 203450545, false, "")
	level.add_cam_effector("camera_effects\\shell_shock.anm", 20080701, false, "")
	level.add_pp_effector("snd_shock.ppe", 20080702, false)
	level.set_pp_effector_factor(20080702, 0, 1)
end

function continue_surge_on_stancia_2()
	xr_sound.play_sound_looped(0, "blowout_rumble") -- 0 = actor ID
	level.add_pp_effector("blink.ppe", 20080703, false)
	level.add_pp_effector("snd_shock.ppe", 20080704, true)
	level.set_pp_effector_factor(20080704, 0, 10)
	level.add_cam_effector("camera_effects\\earthquake.anm", 20080705, true, "")
end

--[[

function add_strelok_health_bar()
	local strelok = level_object_by_sid(1400)
	xr_motivator.cs_strelok_health(strelok)
end

function stc_strelok_particle()
end

function stc_surge()
	level.set_weather_fx("fx_surge_day_3_stancia")
	xr_sound.set_sound_play(0, "blowout_begin")
	level.add_cam_effector("camera_effects\\shell_shock.anm", 20080501, false, "")
	level.add_cam_effector("camera_effects\\earthquake_00.anm", 20080501, true, "")
	level.add_pp_effector("snd_shock.ppe", 20080401, false)
	level.set_pp_effector_factor(20080401, 0, 1)
end

local particles_table =

{
	[1] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
	[2] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
	[3] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
	[4] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")},
	[5] = {particle = particles_object("anomaly2\\teleport_out_00"), sound = sound_object("anomaly\\teleport_incoming")}
}

]]

--'------------------------------------------------------
--' Misc.
--'------------------------------------------------------

function make_actor_visible_to_npc(actor, npc)
	npc:make_object_visible_somewhen(actor)
end

function add_map_spot(actor, npc, p)

	local p1 = p[1]

	if p1 == nil then
		abort("[xr_effects.add_map_spot]: Parameter missing.")
	end

	local story_id = tonumber(p1)
	local id = id_by_sid(story_id)

	if id == nil then
		local obj = sim:object(p1)
		id = obj and obj.id
		if id == nil then
			abort("[xr_effects.add_map_spot]: Invalid story_id or name '%s'.", tostring(id))
		end
	end

	local p2 = p[2] or "primary_task_location"
	local p3 = p[3] or "default"

	if level.map_has_object_spot(id, p2) == 0 then
		level.map_add_object_spot_ser(id, p2, p3)
	end
end

function remove_map_spot(actor, npc, p)

	local p1 = p[1]

	if p1 == nil then
		abort("[xr_effects.remove_map_spot]: Parameter missing.")
	end

	local story_id = tonumber(p1)
	local id = id_by_sid(story_id)

	if id == nil then
		local obj = sim:object(p1)
		id = obj and obj.id
		if id == nil then
			abort("[xr_effects.remove_map_spot]: Invalid story_id or name '%s'.", tostring(id))
		end
	end

	local p2 = p[2] or "primary_task_location"

	if level.map_has_object_spot(id, p2) ~= 0 then
		level.map_remove_object_spot(id, p2)
	end
end

function launch_signal_rocket(actor, obj, p)
	local p1 = p[1]
	if p1 == nil then
		abort("[xr_effects.launch_signal_rocket]: Parameter missing.")
	end
	local dbsig = db.signal_light[p1]
	if not dbsig then
		abort("[xr_effects.launch_signal_rocket]: No signal rocket corresponds to name '%s'.", tostring(p1))
	end
	dbsig:launch()
end

function autosave_game()
--	get_console():execute("save "..user_name().."_autosave")
	local level_name = level.name()
	local level_prefix = string.sub(level_name, 1, 3)
--	if level_name == "agroprom_underground" then -- this function is used only for marsh
--		level_prefix = "agru"
--	end
	get_console():execute("save "..level_prefix.."_autosave_start")
end

function send_tip(actor, npc, p)
	news_manager.send_tip(actor, p[1], nil, p[2], nil, p[3])
end

--[[

function disable_collision(actor, npc)
	npc:wounded(true)
end

function enable_collision(actor, npc)
	npc:wounded(false)
end

function disable_actor_collision(actor)
	actor:wounded(true)
end

function enable_actor_collision(actor)
	actor:wounded(false)
end

function reset_dialog_end_signal(actor, npc)
	local st = db.storage[npc:id()]
	if st.active_scheme == nil then
		return
	end
	local sigs = st[st.active_scheme].signals
	if sigs == nil then
		return
	end
	sigs["dialog_end"] = nil
end

function start_katacomb_empty()
	local console = get_console()
	console:execute("load katacomb_empty")
end

]]

------------------------------------------------------------------------------------------
-- SRP functions:
------------------------------------------------------------------------------------------

function give_location_only(actor, npc, p)
	if p[1] == nil then
		abort("[xr_effects.give_location_only]: Parameter missing.")
	end
	for k, v in pairs (p) do
		treasure_manager.give_location_only(v)
	end
end

function release_npc_item(actor, npc, p)
	local item_name = p[1]
	if item_name == nil then
		abort("[xr_effects.release_npc_item]: Parameter missing.")
	end
	local item = npc:object(item_name)
	if item ~= nil then
--		local sim = alife()
		sim:release(sim:object(item:id()), true)
	end
end

function play_fake_explosion(actor)
	local actor_pos = vector():set(0,0,0)
	local mine_click_snd = sound_object("weapons\\mine_on")
	local explosion_snd = sound_object("weapons\\f1_explode")
	mine_click_snd:play_at_pos(actor, actor_pos, 0, sound_object.s2d)
	explosion_snd:play_at_pos(actor, actor_pos, 0, sound_object.s2d)
	level.add_cam_effector("camera_effects\\shell_shock.anm", 25, false, "")
	level.add_cam_effector("camera_effects\\head_shot.anm", 26, false, "")
--	level.add_cam_effector("camera_effects\\fusker.anm", 27, false, "")
	level.add_pp_effector("gar_ambush_hit.ppe", 500, false)
end

function freeplay()
	ogsm_freeplay.armagezdec()
end