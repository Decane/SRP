-- DC141130: Optimizations. Fixed (i) squads sometimes moving to their targets sluggishly and (ii) the excessively low guide job priority.
-- DC170601: Fixed both instances of "agressive" to "aggressive". Deleted the superfluous (but harmless) second argument (":3") from the single call to is_obj_on_job(). Further optimizations.

local function _precond_func_exclusive(se_obj, smart, precond_params)
	return xr_logic.pick_section_from_condlist(db.actor, se_obj, precond_params.condlist) ~= nil
end

local function _precond_func_commander(se_obj, smart)
	if se_obj.squad_id == nil then
		return false
	end
	local squad = smart.board.squads[se_obj.squad_id]
	return (squad ~= nil) and (squad.commander_id == se_obj.id) and task_manager.is_more_suitable(squad)
end

local function _precond_func_guard(se_obj, smart, precond_params, npc_info)
	return npc_info.need_job == precond_params.changing_job
end

local function _precond_func_sniper(se_obj, smart, precond_params)
	return combat_restrictor.accessible_job(se_obj, precond_params.way_name)
end

local function _precond_func_camper(se_obj, smart, precond_params)
	return combat_restrictor.accessible_job(se_obj, precond_params.way_name)
end

local function _precond_func_smartcover(se_obj, smart, precond_params)
	return combat_restrictor.accessible_job(se_obj, precond_params.way_name) and cover_manager.has_smart_cover(se_obj, smart)
end

local function _precond_func_cover(se_obj, smart, precond_params)
	return combat_restrictor.accessible_job(se_obj, precond_params.way_name) and cover_manager.has_cover(se_obj, smart)
end

local function add_exclusive_job(job_name, job_table, job_script)
--[[
	local job_script = utils.cfg_get_string(smart_ini, sect, job_name, nil, false, "")
	if job_script == nil then
		return
	end
]]
	local ini_path = "scripts\\"..job_script -- "\scripts\\"..job_script

	if getFS():exist("$game_config$", ini_path) == nil then
		abort("[gulag_general.add_exclusive_job]: There is no such configuration file: '%s'.", tostring(ini_path))
	end

	local work_section = "logic@"..job_name
	local job_ini = ini_file(ini_path)
	local job_online, new_prior, job_suitable, is_monster

	if job_ini:section_exist(work_section) then
		job_online   = job_ini:line_exist(work_section, "job_online") and job_ini:r_string(work_section, "job_online") or nil
		new_prior    = job_ini:line_exist(work_section, "prior") and job_ini:r_float(work_section, "prior") or 45
		job_suitable = job_ini:line_exist(work_section, "suitable") and job_ini:r_string(work_section, "suitable") or nil
		is_monster   = job_ini:line_exist(work_section, "monster_job") and job_ini:r_bool(work_section, "monster_job")
	else
		job_online   = nil
		new_prior    = 45
		job_suitable = nil
		is_monster   = false
	end

	if job_suitable == nil then
		job_table[#job_table + 1] =
		{
			_prior = new_prior,
			_precondition_is_monster = is_monster,
			job_id = {section = work_section, ini_path = ini_path, online = job_online, ini_file = job_ini}
		}
		return
	end

	job_table[#job_table + 1] =
	{
		_prior = new_prior,
		_precondition_is_monster = is_monster,
		job_id = {section = work_section, ini_path = ini_path, ini_file = job_ini, online = job_online},
		_precondition_params = {condlist = xr_logic.parse_condlist(smart, work_section, "suitable", job_suitable)},
		_precondition_function = _precond_func_exclusive
	}

	job_table[#job_table + 1] =
	{
		_prior = -1,
		_precondition_is_monster = is_monster,
		job_id = {section = work_section, ini_file = job_ini}
	}
end

local match = string.match
local table_concat = table.concat
local ltx

function load_job(smart)

	ltx = {

	-- 130 empty strings to minimize table rehash overhead - ltx always gets at least 130 non-empty strings in vanilla so this never wastes memory (strings are interned in Lua, so at most one empty string is actually created):

	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", ""

	}

	local gname = smart:name()
	local board = sim_board.get_sim_board()
--[[
	local danger_ltx = "danger = danger@ignore_day\n" -- not needed; see below

	ltx =

	"[meet@generic_lager_comander]\n"..
	"meet_state         = 30|hello_wpn|5|talk_default@meet_comander_wait\n"..
	"meet_state_wpn     = 30|hello_wpn|5|threat@meet_weapon_wait\n"..
	"victim             = 30|actor\n"..
	"victim_wpn         = 30|actor\n"..
	"sound_start        = meet_comander_start\n"..
	"sound_start_wpn    = meet_weapon_start\n"..
	"sound_stop         = meet_comander_stop\n"..
	"use                = true\n"..
	"use_wpn            = true\n"..
	"precond            = visibility\n"..
	"meet_only_at_path  = true\n"..

	"[meet@generic_lager_conductor]\n"..
	"meet_state         = 10|hello_wpn|5|talk_default@meet_general_wait\n"..
	"meet_state_wpn     = 10|hello_wpn|5|threat@meet_weapon_wait\n"..
	"victim             = 10|actor\n"..
	"victim_wpn         = 10|actor\n"..
	"sound_start        = meet_general_start\n"..
	"sound_start_wpn    = meet_weapon_start\n"..
	"sound_stop         = meet_general_stop\n"..
	"use                = true\n"..
	"use_wpn            = true\n"..
	"precond            = visibility\n"..
	"meet_only_at_path  = true\n"..

	"[meet@generic_lager_guard]\n"..
	"meet_state         = 3|guard@meet_general_wait\n"..
	"meet_state_wpn     = 3|threat@meet_weapon_wait\n"..
	"victim             = 3|actor\n"..
	"victim_wpn         = 3|actor\n"..
	"sound_start        = meet_general_start\n"..
	"sound_start_wpn    = meet_weapon_start\n"..
	"sound_stop         = meet_general_stop\n"..
	"use                = true\n"..
	"use_wpn            = false\n"..
	"precond            = visibility\n"..
	"meet_only_at_path  = true\n"..

	"[meet@generic_lager_patrol]\n"..
	"meet_state         = 2|guard@meet_general_wait\n"..
	"meet_state_wpn     = 2|threat@meet_weapon_wait\n"..
	"victim             = 2|actor\n"..
	"victim_wpn         = 2|actor\n"..
	"sound_start        = \n"..
	"sound_start_wpn    = \n"..
	"sound_stop         = \n"..
	"use                = true\n"..
	"use_wpn            = false\n"..
	"precond            = visibility\n"..

	"[meet@generic_lager]\n"..
	"meet_state         = 2|guard@meet_general_wait\n"..
	"meet_state_wpn     = 2|threat@meet_weapon_wait\n"..
	"victim             = 2|actor\n"..
	"victim_wpn         = 2|actor\n"..
	"sound_start        = \n"..
	"sound_start_wpn    = \n"..
	"sound_stop         = \n"..
	"use                = true\n"..
	"use_wpn            = false\n"..
	"precond            = visibility\n"..

	"[meet@attack]\n"..
	"meet_state         = 2|talk_default@meet_general_wait\n"..
	"meet_state_wpn     = 2|talk_default@meet_weapon_wait\n"..
	"victim             = 2|actor\n"..
	"victim_wpn         = 2|actor\n"..
	"sound_start        = meet_general_start\n"..
	"sound_start_wpn    = meet_weapon_start\n"..
	"sound_stop         = meet_general_stop\n"..
	"use                = true\n"..
	"use_wpn            = true\n"..
	"precond            = usability\n"..

	"[danger@ignore_day]\n"..
	"ignore_distance_corpse = 10\n"..  -- 10 is anyway the default if this section is missing, so pointless to include it explicitly - see xr_danger.script

	"[danger@ignore_night]\n"..        -- unused
	"ignore_distance_corpse = 10\n"..

	"[danger@attack]\n"..              -- ditto
	"ignore_distance_corpse = 10\n"..

	"[danger@defense]\n"..             -- ditto
	"ignore_distance_corpse = 10\n"
]]
	ltx[1] = "[meet@generic_lager_comander]\nmeet_state=30|hello_wpn|5|talk_default@meet_comander_wait\nmeet_state_wpn=30|hello_wpn|5|threat@meet_weapon_wait\nvictim=30|actor\nvictim_wpn=30|actor\nsound_start=meet_comander_start\nsound_start_wpn=meet_weapon_start\nsound_stop=meet_comander_stop\nuse=true\nuse_wpn=true\nprecond=visibility\nmeet_only_at_path=true\n[meet@generic_lager_conductor]\nmeet_state=10|hello_wpn|5|talk_default@meet_general_wait\nmeet_state_wpn=10|hello_wpn|5|threat@meet_weapon_wait\nvictim=10|actor\nvictim_wpn=10|actor\nsound_start=meet_general_start\nsound_start_wpn=meet_weapon_start\nsound_stop=meet_general_stop\nuse=true\nuse_wpn=true\nprecond=visibility\nmeet_only_at_path=true\n[meet@generic_lager_guard]\nmeet_state=3|guard@meet_general_wait\nmeet_state_wpn=3|threat@meet_weapon_wait\nvictim=3|actor\nvictim_wpn=3|actor\nsound_start=meet_general_start\nsound_start_wpn=meet_weapon_start\nsound_stop=meet_general_stop\nuse=true\nuse_wpn=false\nprecond=visibility\nmeet_only_at_path=true\n[meet@generic_lager_patrol]\nmeet_state=2|guard@meet_general_wait\nmeet_state_wpn=2|threat@meet_weapon_wait\nvictim=2|actor\nvictim_wpn=2|actor\nsound_start=\nsound_start_wpn=\nsound_stop=\nuse=true\nuse_wpn=false\nprecond=visibility\n[meet@generic_lager]\nmeet_state=2|guard@meet_general_wait\nmeet_state_wpn=2|threat@meet_weapon_wait\nvictim=2|actor\nvictim_wpn=2|actor\nsound_start=\nsound_start_wpn=\nsound_stop=\nuse=true\nuse_wpn=false\nprecond=visibility\n[meet@attack]\nmeet_state=2|talk_default@meet_general_wait\nmeet_state_wpn=2|talk_default@meet_weapon_wait\nvictim=2|actor\nvictim_wpn=2|actor\nsound_start=meet_general_start\nsound_start_wpn=meet_weapon_start\nsound_stop=meet_general_stop\nuse=true\nuse_wpn=true\nprecond=usability\n"

	--'========================================================================
	--'				Stalker jobs
	--'========================================================================

	local stalker_jobs = {_precondition_is_monster = false, _prior = 60, jobs = true}

	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--'				General jobs
	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	local stalker_general_jobs = {_prior = 40, jobs = {}}

	--'------------------------------------------------------------------------
	--'				KAMP
	--'------------------------------------------------------------------------

	local ltx_num = 1
	local path_exists = level.patrol_path_exists
	local smart_def_restr = smart.def_restr
	local smart_def_string

	if smart_def_restr then
		smart_def_string = "out_restr="..smart_def_restr.."\n"
	end

	local num = 0 -- #stalker_general_jobs.jobs
	local it = 1
	local way_name = gname.."_kamp_1"

	while path_exists(way_name) do
--[[
		local def_prior = 5
		local job_count = 5
		local ptr = patrol(way_name)
		local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
		local wp_prop_count = wp_prop.count

		if wp_prop_count ~= nil then
			job_count = wp_prop_count
		end
]]
		local job_count = match(patrol(way_name):name(0), "|count=(%d+)") or 5
		local logic_way_name = "logic@"..way_name
		local priority = 6 - it

		for i = 1, job_count do
			stalker_general_jobs.jobs[num + i] = {_prior = priority, job_id = {section = logic_way_name, reserve_job = true, campfire = way_name}}
		end

		num = num + job_count
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = kamp@"..way_name.."\n"..

		"[kamp@"..way_name.."]\n"..
		"center_point = kamp_"..it.."\n"..
		"soundgroup = "..way_name.."\n"
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=kamp@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[kamp@"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\ncenter_point=kamp_"
		ltx[ltx_num + 8] = it
		ltx[ltx_num + 9] = "\nsoundgroup="
		ltx[ltx_num + 10] = way_name
		ltx_num = ltx_num + 11
		ltx[ltx_num] = "\n"

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		it = it + 1
		way_name = gname.."_kamp_"..it
	end

	if it == 1 then
		abort("[gulag_general.load_job]: There is no 'kamp' path on smart with name '%s'.", tostring(gname))
	end

	--'------------------------------------------------------------------------
	--'				SLEEP
	--'------------------------------------------------------------------------

	it = 1
	way_name = gname.."_sleep_1"

	while path_exists(way_name) do

		num = num + 1
		stalker_general_jobs.jobs[num] = {_prior = 10, job_id = {section = "logic@"..way_name}}
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = sleeper@"..way_name.."\n"..

		"[sleeper@"..way_name.."]\n"..
		"path_main = sleep_"..it.."\n"
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=sleeper@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[sleeper@"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\npath_main=sleep_"
		ltx[ltx_num + 8] = it
		ltx_num = ltx_num + 9
		ltx[ltx_num] = "\n"

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		it = it + 1
		way_name = gname.."_sleep_"..it
	end

	--'------------------------------------------------------------------------
	--'				WALKER
	--'------------------------------------------------------------------------

	it = 1
	way_name = gname.."_walker_1_walk"

	while path_exists(way_name) do

		num = num + 1
		stalker_general_jobs.jobs[num] = {_prior = 15, job_id = {section = "logic@"..way_name}}
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = walker@"..way_name.."\n"..

		"[walker@"..way_name.."]\n"..
		"sound_idle = state\n"..
		"meet = meet@generic_lager\n"..
		"path_walk = walker_"..it.."_walk\n"..
		"def_state_standing = guard\n"..
		"def_state_moving = patrol\n"
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=walker@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[walker@"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\nsound_idle=state\nmeet=meet@generic_lager\npath_walk=walker_"
		ltx[ltx_num + 8] = it
		ltx_num = ltx_num + 9
		ltx[ltx_num] = "_walk\ndef_state_standing=guard\ndef_state_moving=patrol\n"

		if path_exists(gname.."_walker_"..it.."_look") then
			ltx[ltx_num + 1] = "path_look=walker_"
			ltx[ltx_num + 2] = it
			ltx_num = ltx_num + 3
			ltx[ltx_num] = "_look\n"
		end

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		it = it + 1
		way_name = gname.."_walker_"..it.."_walk"
	end

	--'------------------------------------------------------------------------
	--'				PATROL
	--'------------------------------------------------------------------------

	it = 1
	way_name = gname.."_patrol_1_walk"

	while path_exists(way_name) do
--[[
		local job_count = 3
		local ptr = patrol(way_name)
		local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
		local wp_prop_count = wp_prop.count

		if wp_prop_count ~= nil then
			job_count = wp_prop_count
		end
]]
		local job_count = match(patrol(way_name):name(0), "|count=(%d+)") or 3
		local logic_way_name = "logic@"..way_name

		for i = 1, job_count do
			stalker_general_jobs.jobs[num + i] = {_prior = 20, job_id = {section = logic_way_name}}
		end

		num = num + job_count
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = patrol@"..way_name.."\n"..

		"[patrol@"..way_name.."]\n"..
		"meet = meet@generic_lager_patrol\n"..
		"formation = back\n"..
		"path_walk = patrol_"..it.."_walk\n"..
		"on_signal = end| %=search_gulag_job%\n"
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=patrol@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[patrol@"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\nmeet=meet@generic_lager_patrol\nformation=back\npath_walk=patrol_"
		ltx[ltx_num + 8] = it
		ltx_num = ltx_num + 9
		ltx[ltx_num] = "_walk\non_signal=end|%=search_gulag_job%\n"

		if path_exists(gname.."_patrol_"..it.."_look") then
			ltx[ltx_num + 1] = "path_look=patrol_"
			ltx[ltx_num + 2] = it
			ltx_num = ltx_num + 3
			ltx[ltx_num] = "_look\n"
		end

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		it = it + 1
		way_name = gname.."_patrol_"..it.."_walk"
	end

	--'------------------------------------------------------------------------
	--'				COMMANDER
	--'------------------------------------------------------------------------

	way_name = gname.."_comander_walk"

	if path_exists(way_name) then

		num = num + 1
		stalker_general_jobs.jobs[num] =
		{
			_prior = 39,
			job_id = {section = "logic@"..way_name},
			_precondition_function = _precond_func_commander
		}
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = walker@"..way_name.."\n"..

		"[walker@"..way_name.."]\n"..
		"meet = meet@generic_lager_comander\n"..
		"path_walk = comander_walk\n"
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=walker@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[walker@"
		ltx[ltx_num + 6] = way_name
		ltx_num = ltx_num + 7
		ltx[ltx_num] = "]\nmeet=meet@generic_lager_comander\npath_walk=comander_walk\n"

		if path_exists(gname.."_comander_look") then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = "path_look=comander_look\n"
		end

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end
	end

	--'------------------------------------------------------------------------
	--'				GUIDE
	--'------------------------------------------------------------------------

	way_name = gname.."_conductor_walk"

	if path_exists(way_name) then

		num = num + 1
		stalker_general_jobs.jobs[num] = {_prior = 40, job_id = {section = "logic@"..way_name}}
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = walker@"..way_name.."\n"..
		"level_spot = guider\n"..

		"[walker@"..way_name.."]\n"..
		"meet = meet@generic_lager_conductor\n"..
		"path_walk = conductor_walk\n"
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=walker@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\nlevel_spot=guider\n[walker@"
		ltx[ltx_num + 6] = way_name
		ltx_num = ltx_num + 7
		ltx[ltx_num] = "]\nmeet=meet@generic_lager_conductor\npath_walk=conductor_walk\n"

		if path_exists(gname.."_conductor_look") then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = "path_look=conductor_look\n"
		end

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end
	end

	--'------------------------------------------------------------------------
	--'				GUARD
	--'------------------------------------------------------------------------

	it = 1
	way_name = gname.."_guard_1_walk"

	while path_exists(way_name) do

--		local guard_timeout = tostring(math.random(20, 21)) * 1000 -- probably not a good idea to multiply a string by 1000
		local guard_timeout = "20000" -- also, coercion is unnecessary here since concatenation coerces automatically, and randomizing between 20,000 and 21,000 is a waste

		num = num + 1
		stalker_general_jobs.jobs[num] = {_prior = 25, job_id = {section = "logic@"..way_name}}
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = walker@"..way_name.."\n"..

		"[walker@"..way_name.."]\n"..
		"meet = meet@generic_lager_guard\n"..
		"path_walk = guard_"..it.."_walk\n"..
		"path_look = guard_"..it.."_look\n"..
		"on_timer = "..guard_timeout.." | {!is_current_action_robbery} walker1@"..way_name.." %=get_stalker_for_new_job(logic@"..way_name..")%\n"

		if smart_def_restr then
			job_ltx = job_ltx .. smart_def_string
		end

		job_ltx = job_ltx .. danger_ltx

		local job1_ltx =

		"[walker1@"..way_name.."]\n"..
		"meet = meet@generic_lager_guard\n"..
		"path_walk = guard_"..it.."_walk\n"..
		"path_look = guard_"..it.."_look\n"..
		"def_state_standing = wait_na\n"..
		danger_ltx..
		"on_info = {!is_obj_on_job(logic@follower_"..way_name..":3)} walker@"..way_name.."\n"..
		"on_info2 = {=distance_to_obj_on_job_le(logic@follower_"..way_name..":3)} remark@"..way_name.."\n"

		if smart_def_restr then
			job1_ltx = job1_ltx .. smart_def_string
		end

		job1_ltx = job1_ltx ..
		danger_ltx .. -- danger_ltx has already been added to [walker1@"..way_name.."] in the local declaration for job1_ltx above - no need to do it again
		"[remark@"..way_name.."]\n"..
		"anim = wait_na\n"..
		"target = logic@follower_"..way_name.."\n"
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=walker@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[walker@"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\nmeet=meet@generic_lager_guard\npath_walk=guard_"
		ltx[ltx_num + 8] = it
		ltx[ltx_num + 9] = "_walk\npath_look=guard_"
		ltx[ltx_num + 10] = it
		ltx[ltx_num + 11] = "_look\non_timer="
		ltx[ltx_num + 12] = guard_timeout
		ltx[ltx_num + 13] = "|{!is_current_action_robbery}walker1@"
		ltx[ltx_num + 14] = way_name
		ltx[ltx_num + 15] = "%=get_stalker_for_new_job(logic@"
		ltx[ltx_num + 16] = way_name
		ltx_num = ltx_num + 17
		ltx[ltx_num] = ")%\n"

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		ltx[ltx_num + 1] = "[walker1@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nmeet=meet@generic_lager_guard\npath_walk=guard_"
		ltx[ltx_num + 4] = it
		ltx[ltx_num + 5] = "_walk\npath_look=guard_"
		ltx[ltx_num + 6] = it
		ltx[ltx_num + 7] = "_look\ndef_state_standing=wait_na\non_info={!is_obj_on_job(logic@follower_"
		ltx[ltx_num + 8] = way_name
		ltx[ltx_num + 9] = ")}walker@"
		ltx[ltx_num + 10] = way_name
		ltx[ltx_num + 11] = "\non_info2={=distance_to_obj_on_job_le(logic@follower_"
		ltx[ltx_num + 12] = way_name
		ltx[ltx_num + 13] = ":3)}remark@"
		ltx[ltx_num + 14] = way_name
		ltx_num = ltx_num + 15
		ltx[ltx_num] = "\n"

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		ltx[ltx_num + 1] = "[remark@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nanim=wait_na\ntarget=logic@follower_"
		ltx[ltx_num + 4] = way_name
		ltx_num = ltx_num + 5
		ltx[ltx_num] = "\n"

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		num = num + 1
		stalker_general_jobs.jobs[num] =
		{
			_prior = 24,
			job_id = {section = "logic@follower_"..way_name},
			_precondition_params = {changing_job = "logic@"..way_name},
			_precondition_function = _precond_func_guard
		}
--[[
		local follower_ltx =

		"[logic@follower_"..way_name.."]\n"..
		"active = walker@follow_"..way_name.."\n"..

		"[walker@follow_"..way_name.."]\n"..
		"meet = meet@generic_lager\n"..
		"path_walk = guard_"..it.."_walk\n"..
		"path_look = guard_"..it.."_look\n"..
		"on_info = {=distance_to_obj_on_job_le(logic@"..way_name..":3)} remark@follower_"..way_name.."\n"
]]
		ltx[ltx_num + 1] = "[logic@follower_"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=walker@follow_"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[walker@follow_"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\nmeet=meet@generic_lager\npath_walk=guard_"
		ltx[ltx_num + 8] = it
		ltx[ltx_num + 9] = "_walk\npath_look=guard_"
		ltx[ltx_num + 10] = it
		ltx[ltx_num + 11] = "_look\non_info={=distance_to_obj_on_job_le(logic@"
		ltx[ltx_num + 12] = way_name
		ltx[ltx_num + 13] = ":3)}remark@follower_"
		ltx[ltx_num + 14] = way_name
		ltx_num = ltx_num + 15
		ltx[ltx_num] = "\n"

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end
--[[
		follower_ltx =

		follower_ltx ..
		danger_ltx ..
		"[remark@follower_"..way_name.."]\n"..
		"anim = wait_na\n"..
		"target = logic@"..way_name.."\n"..
		"on_timer = 2000 | %=switch_to_desired_job%\n"
]]
		ltx[ltx_num + 1] = "[remark@follower_"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nanim=wait_na\ntarget=logic@"
		ltx[ltx_num + 4] = way_name
		ltx_num = ltx_num + 5
		ltx[ltx_num] = "\non_timer=2000|%=switch_to_desired_job%\n"

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		it = it + 1
		way_name = gname.."_guard_"..it.."_walk"
	end

	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--'				Attack jobs
	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	local stalker_attack_jobs = {_prior = 60, jobs = {}, _current_squad_action = "attack_point"}
	local attack_jobs_num = 0

	for k, target_smart_obj in pairs (board:get_nearest_smarts(smart)) do

		local target_smart = target_smart_obj:name()
		local stalker_attack_smart_jobs = {_prior = 60, jobs = {}, _current_squad_action = "attack_point", _squad_attack_point = target_smart}

	--'------------------------------------------------------------------------
	--'				RANGER
	--'------------------------------------------------------------------------

	-- There are no patrol paths in the game whose name contains "ranger", so the corresponding code has been removed.

	--'------------------------------------------------------------------------
	--'				GROUP ATTACK
	--'------------------------------------------------------------------------

		local att_restr = target_smart_obj.att_restr
		local def_restr = target_smart_obj.def_restr
		local att_string
		local def_string

		if att_restr then
			att_string = "out_restr="..att_restr.."\n"
		end

		if def_restr then
			def_string = "out_restr="..def_restr.."\n"
		end

		num = 0 -- #stalker_attack_smart_jobs.jobs
		it = 1
		way_name = gname.."_to_"..target_smart.."_patrol_1_walk"

		while path_exists(way_name) do

			local look_point_exists = false
			local path_look_string

			if path_exists(gname.."_to_"..target_smart.."_patrol_"..it.."_look") then
				look_point_exists = true
				path_look_string = "path_look=to_"..target_smart.."_patrol_"..it.."_look\n"
			end
--[[
			local job_count = 5
			local ptr = patrol(way_name)
			local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
			local wp_prop_count = wp_prop.count

			if wp_prop_count ~= nil then
				job_count = wp_prop_count
			end
]]
			local job_count = match(patrol(way_name):name(0), "|count=(%d+)") or 5

			for i = 1, job_count do

				local sect_name = gname.."_to_"..target_smart.."_patrol"..i.."_"..it.."_walk"

				stalker_attack_smart_jobs.jobs[num + i] = {_prior = 55, _attack_job = true, job_id = {section = "logic@"..sect_name}}
--[[
				local job_ltx =

				"[logic@"..sect_name.."]\n"..
				"active = patrol@"..sect_name.."\n"..

				"[patrol@"..sect_name.."]\n"..
				"meet = meet@attack\n"..
				"formation = around\n"..
				"def_state_moving = {=attacking_smart_captured} raid, rush\n"..
				"on_signal = arrive_to_wait|%=request_current_squad_stage(prepare)%\n"..
				"on_info = {=current_squad_stage(combat)} cover@"..sect_name.."_attack\n"..
				"path_walk = to_"..target_smart.."_patrol_"..it.."_walk\n"..
				danger_ltx
]]
				ltx[ltx_num + 1] = "[logic@"
				ltx[ltx_num + 2] = sect_name
				ltx[ltx_num + 3] = "]\nactive=patrol@"
				ltx[ltx_num + 4] = sect_name
				ltx[ltx_num + 5] = "\n[patrol@"
				ltx[ltx_num + 6] = sect_name
				ltx[ltx_num + 7] = "]\nmeet=meet@attack\nformation=around\ndef_state_moving={=attacking_smart_captured}raid,rush\non_signal=arrive_to_wait|%=request_current_squad_stage(prepare)%\non_info={=current_squad_stage(combat)}cover@"
				ltx[ltx_num + 8] = sect_name
				ltx[ltx_num + 9] = "_attack\npath_walk=to_"
				ltx[ltx_num + 10] = target_smart
				ltx[ltx_num + 11] = "_patrol_"
				ltx[ltx_num + 12] = it
				ltx_num = ltx_num + 13
				ltx[ltx_num] = "_walk\n"

				if look_point_exists then
					ltx_num = ltx_num + 1
					ltx[ltx_num] = path_look_string
				end

				if se_smart_cover.registered_smartcovers[gname.."_to_"..target_smart.."_patrol_"..it.."_wait_"..i.."_smartcover"] ~= nil then
--[[
					job_ltx = job_ltx ..

					"on_info2 = {=current_squad_stage(prepare:wait) =smart_cover_suitable("..string..it.."_wait_"..i.."_smartcover)} smartcover@"..sect_name.."\n"..
					"on_info3 = {=current_squad_stage(prepare:wait)} remark@"..sect_name.."\n"..

					"[smartcover@"..sect_name.."]\n"..
					"meet = no_meet\n"..
					danger_ltx..
					"on_info = {=current_squad_stage(combat:post_combat:idle)} cover@"..sect_name.."_attack\n"..
					"cover_state = default_behaviour\n"..
					"def_state_moving = sneak_run\n"..
					"cover_name = "..string..it.."_wait_"..i.."_smartcover\n"..
					"target_path = {=cover_attack} "..target_smart.."_kamp_1\n"..

					"[remark@"..sect_name.."]\n"..
					"meet = no_meet\n"..
					"on_info = {=current_squad_stage(combat:post_combat:idle)} cover@"..sect_name.."_attack\n"..
					"target = "..target_smart.."_kamp_1\n"..
					"anim = hide\n"..
					danger_ltx
]]
					ltx[ltx_num + 1] = "on_info2={=current_squad_stage(prepare:wait)=smart_cover_suitable("
					ltx[ltx_num + 2] = gname
					ltx[ltx_num + 3] = "_to_"
					ltx[ltx_num + 4] = target_smart
					ltx[ltx_num + 5] = "_patrol_"
					ltx[ltx_num + 6] = it
					ltx[ltx_num + 7] = "_wait_"
					ltx[ltx_num + 8] = i
					ltx[ltx_num + 9] = "_smartcover)}smartcover@"
					ltx[ltx_num + 10] = sect_name
					ltx[ltx_num + 11] = "\non_info3={=current_squad_stage(prepare:wait)}remark@"
					ltx[ltx_num + 12] = sect_name
					ltx[ltx_num + 13] = "\n[smartcover@"
					ltx[ltx_num + 14] = sect_name
					ltx[ltx_num + 15] = "]\nmeet=no_meet\non_info={=current_squad_stage(combat:post_combat:idle)}cover@"
					ltx[ltx_num + 16] = sect_name
					ltx[ltx_num + 17] = "_attack\ncover_state=default_behaviour\ndef_state_moving=sneak_run\ncover_name="
					ltx[ltx_num + 18] = gname
					ltx[ltx_num + 19] = "_to_"
					ltx[ltx_num + 20] = target_smart
					ltx[ltx_num + 21] = "_patrol_"
					ltx[ltx_num + 22] = it
					ltx[ltx_num + 23] = "_wait_"
					ltx[ltx_num + 24] = i
					ltx[ltx_num + 25] = "_smartcover\ntarget_path={=cover_attack}"
					ltx[ltx_num + 26] = target_smart
					ltx[ltx_num + 27] = "_kamp_1\n[remark@"
					ltx[ltx_num + 28] = sect_name
					ltx[ltx_num + 29] = "]\nmeet=no_meet\non_info={=current_squad_stage(combat:post_combat:idle)}cover@"
					ltx[ltx_num + 30] = sect_name
					ltx[ltx_num + 31] = "_attack\ntarget="
					ltx[ltx_num + 32] = target_smart
					ltx_num = ltx_num + 33
					ltx[ltx_num] = "_kamp_1\nanim=hide\n"
				else
--[[
					job_ltx = job_ltx ..

					"on_info2 = {=current_squad_stage(prepare:wait)} remark@"..sect_name.."\n"..

					"[remark@"..sect_name.."]\n"..
					"meet = no_meet\n"..
					"on_info = {=current_squad_stage(combat:post_combat:idle)} cover@"..sect_name.."_attack\n"..
					"target = "..target_smart.."_kamp_1\n"..
					"anim = hide\n"..
					danger_ltx
]]
					ltx[ltx_num + 1] = "on_info2={=current_squad_stage(prepare:wait)}remark@"
					ltx[ltx_num + 2] = sect_name
					ltx[ltx_num + 3] = "\n[remark@"
					ltx[ltx_num + 4] = sect_name
					ltx[ltx_num + 5] = "]\nmeet=no_meet\non_info={=current_squad_stage(combat:post_combat:idle)}cover@"
					ltx[ltx_num + 6] = sect_name
					ltx[ltx_num + 7] = "_attack\ntarget="
					ltx[ltx_num + 8] = target_smart
					ltx_num = ltx_num + 9
					ltx[ltx_num] = "_kamp_1\nanim=hide\n"
				end
--[[
				job_ltx = job_ltx ..

				"[cover@"..sect_name.."_attack]\n"..
				"use_attack_direction = false\n"..
				"on_info = {!current_squad_stage(combat)} cover@"..sect_name.."_after_attack\n"..
				"smart = "..target_smart.."\n"..
				danger_ltx
]]
				ltx[ltx_num + 1] = "[cover@"
				ltx[ltx_num + 2] = sect_name
				ltx[ltx_num + 3] = "_attack]\nuse_attack_direction=false\non_info={!current_squad_stage(combat)}cover@"
				ltx[ltx_num + 4] = sect_name
				ltx[ltx_num + 5] = "_after_attack\nsmart="
				ltx[ltx_num + 6] = target_smart
				ltx_num = ltx_num + 7
				ltx[ltx_num] = "\n"

				if att_restr ~= nil then
					ltx_num = ltx_num + 1
					ltx[ltx_num] = att_string
				end
--[[
				job_ltx = job_ltx ..

				"[cover@"..sect_name.."_after_attack]\n"..
				"use_attack_direction = false\n"..
				"smart = "..target_smart.."\n"..
				danger_ltx
]]
				ltx[ltx_num + 1] = "[cover@"
				ltx[ltx_num + 2] = sect_name
				ltx[ltx_num + 3] = "_after_attack]\nuse_attack_direction=false\nsmart="
				ltx[ltx_num + 4] = target_smart
				ltx_num = ltx_num + 5
				ltx[ltx_num] = "\n"

				if def_restr ~= nil then
					ltx_num = ltx_num + 1
					ltx[ltx_num] = def_string
				end
			end

			num = num + job_count
			it = it + 1
			way_name = gname.."_to_"..target_smart.."_patrol_"..it.."_walk"
		end

	--'------------------------------------------------------------------------
	--'				AutoGenerated Attack
	--'------------------------------------------------------------------------

		it = 1
		way_name = target_smart.."_kamp_1_task"

		while path_exists(way_name) do

			local job_count = 5

			for i = 1, job_count do

				local sect_name = gname.."_to_"..target_smart.."_kamp"..i.."_"..it

				stalker_attack_smart_jobs.jobs[num + i] = {_prior = 50, _attack_job = true, job_id = {section = "logic@"..sect_name, prefix_name = target_smart}}
--[[
				local job_ltx =

				"[logic@"..sect_name.."]\n"..
				"active = patrol@"..sect_name.."\n"..

				"[patrol@"..sect_name.."]\n"..
				"formation = around\n"..
--				"def_state_moving = {=attacking_smart_captured} raid, patrol\n".. -- use 'rush' instead of 'patrol' if target smart not captured by enemies to prevent sluggish movement to it
				"def_state_moving = {=attacking_smart_captured} raid, rush\n"..
				"on_info = {!current_squad_stage(move:prepare:wait)} cover@"..sect_name.."_attack, {=npc_to_smart_dist("..target_smart..":30)} %=request_current_squad_stage(prepare)%\n"..
				"path_walk = kamp_"..it.."_task\n"..
				danger_ltx
]]
				ltx[ltx_num + 1] = "[logic@"
				ltx[ltx_num + 2] = sect_name
				ltx[ltx_num + 3] = "]\nactive=patrol@"
				ltx[ltx_num + 4] = sect_name
				ltx[ltx_num + 5] = "\n[patrol@"
				ltx[ltx_num + 6] = sect_name
				ltx[ltx_num + 7] = "]\nformation=around\ndef_state_moving={=attacking_smart_captured}raid,rush\non_info={!current_squad_stage(move:prepare:wait)}cover@"
				ltx[ltx_num + 8] = sect_name
				ltx[ltx_num + 9] = "_attack,{=npc_to_smart_dist("
				ltx[ltx_num + 10] = target_smart
				ltx[ltx_num + 11] = ":30)}%=request_current_squad_stage(prepare)%\npath_walk=kamp_"
				ltx[ltx_num + 12] = it
				ltx_num = ltx_num + 13
				ltx[ltx_num] = "_task\n"

				if path_exists(target_smart.."_wait_"..i.."_walk") then
--[[
					job_ltx = job_ltx ..

					"on_info2 = {=current_squad_stage(prepare:wait)} walker@"..sect_name.."\n"..

					"[walker@"..sect_name.."]\n"..
					"meet = no_meet\n"..
					danger_ltx..
					"on_info = {=current_squad_stage(combat:post_combat:idle)} cover@"..sect_name.."_attack\n"..
					"def_state_standing = {=cover_attack} hide_fire, hide\n"..
					"def_state_moving = sneak\n"..
					"path_walk = wait_"..i.."_walk\n"
]]
					ltx[ltx_num + 1] = "on_info2={=current_squad_stage(prepare:wait)}walker@"
					ltx[ltx_num + 2] = sect_name
					ltx[ltx_num + 3] = "\n[walker@"
					ltx[ltx_num + 4] = sect_name
					ltx[ltx_num + 5] = "]\nmeet=no_meet\non_info={=current_squad_stage(combat:post_combat:idle)}cover@"
					ltx[ltx_num + 6] = sect_name
					ltx[ltx_num + 7] = "_attack\ndef_state_standing={=cover_attack}hide_fire,hide\ndef_state_moving=sneak\npath_walk=wait_"
					ltx[ltx_num + 8] = i
					ltx_num = ltx_num + 9
					ltx[ltx_num] = "_walk\n"

					if path_exists(target_smart.."_wait_"..i.."_look") then
						ltx[ltx_num + 1] = "path_look=wait_"
						ltx[ltx_num + 2] = i
						ltx_num = ltx_num + 3
						ltx[ltx_num] = "_look\n"
					end
				else
--[[
					job_ltx = job_ltx ..

					"on_info2 = {=current_squad_stage(prepare:wait)} remark@"..sect_name.."\n"..

					"[remark@"..sect_name.."]\n"..
					"meet = no_meet\n"..
					"on_info = {=current_squad_stage(combat:post_combat:idle)} cover@"..sect_name.."_attack\n"..
					"anim = hide\n"..
					danger_ltx
]]
					ltx[ltx_num + 1] = "on_info2={=current_squad_stage(prepare:wait)}remark@"
					ltx[ltx_num + 2] = sect_name
					ltx[ltx_num + 3] = "\n[remark@"
					ltx[ltx_num + 4] = sect_name
					ltx[ltx_num + 5] = "]\nmeet=no_meet\non_info={=current_squad_stage(combat:post_combat:idle)}cover@"
					ltx[ltx_num + 6] = sect_name
					ltx_num = ltx_num + 7
					ltx[ltx_num] = "_attack\nanim=hide\n"
				end
--[[
				job_ltx = job_ltx ..

				"[cover@"..sect_name.."_attack]\n"..
				"meet = no_meet\n"..
				"use_attack_direction = false\n"..
				"smart = "..target_smart.."\n"..
				danger_ltx
]]
				ltx[ltx_num + 1] = "[cover@"
				ltx[ltx_num + 2] = sect_name
				ltx[ltx_num + 3] = "_attack]\nmeet=no_meet\nuse_attack_direction=false\nsmart="
				ltx[ltx_num + 4] = target_smart
				ltx_num = ltx_num + 5
				ltx[ltx_num] = "\n"

				if att_restr ~= nil then
					ltx_num = ltx_num + 1
					ltx[ltx_num] = att_string
				end
			end

			num = num + job_count
			it = it + 1
			way_name = target_smart.."_kamp_"..it.."_task"
		end

		attack_jobs_num = attack_jobs_num + 1
		stalker_attack_jobs.jobs[attack_jobs_num] = stalker_attack_smart_jobs
	end

	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--'				Defense jobs
	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	local stalker_defence_jobs =
	{
		_prior = 45,
		jobs = {},
		_precondition_function = xr_gulag.defending_smart

--		function(se_obj, smart)
--			return xr_gulag.defending_smart(se_obj, smart)
--		end
	}

	--'------------------------------------------------------------------------
	--'				SNIPER
	--'------------------------------------------------------------------------

	local smart_def_string_no_newline

	if smart_def_restr then
		smart_def_string_no_newline = "out_restr="..smart_def_restr
	end

	num = 0 -- #stalker_defence_jobs.jobs
	it = 1
	way_name = gname.."_sniper_1_walk"

	while path_exists(way_name) do
--[[
		local state = "hide"
		local ptr = patrol(way_name)
		local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
		local wp_prop_state = wp_prop.state

		if wp_prop_state ~= nil then
			if wp_prop_state == "stand" then
				state = "threat"
			end
		end
]]
		local state = match(patrol(way_name):name(0), "|state=(%l+)") == "stand" and "threat" or "hide"

		num = num + 1
		stalker_defence_jobs.jobs[num] =
		{
			_prior = 30,
			job_id = {section = "logic@"..way_name},
			_precondition_params = {way_name = way_name},
			_precondition_function = _precond_func_sniper
		}
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = camper@"..way_name.."\n"..

		"[camper@"..way_name.."]\n"..
		"meet = meet@generic_lager\n"..
		"path_walk = sniper_"..it.."_walk\n"..
		"path_look = sniper_"..it.."_look\n"..
		"sniper = true\n"..
		"def_state_campering ="..state.."\n"..
		"def_state_campering_fire ="..state.."_fire\n"
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=camper@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[camper@"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\nmeet=meet@generic_lager\npath_walk=sniper_"
		ltx[ltx_num + 8] = it
		ltx[ltx_num + 9] = "_walk\npath_look=sniper_"
		ltx[ltx_num + 10] = it
		ltx[ltx_num + 11] = "_look\nsniper=true\ndef_state_campering="
		ltx[ltx_num + 12] = state
		ltx[ltx_num + 13] = "\ndef_state_campering_fire="
		ltx[ltx_num + 14] = state
		ltx_num = ltx_num + 15
		ltx[ltx_num] = "_fire\n"

		if smart_def_restr then
			ltx[ltx_num + 1] = smart_def_string_no_newline
			ltx[ltx_num + 2] = combat_restrictor.get_job_restrictor(way_name)
			ltx_num = ltx_num + 3
			ltx[ltx_num] = "\n"
		end

		it = it + 1
		way_name = gname.."_sniper_"..it.."_walk"
	end

	--'------------------------------------------------------------------------
	--'				CAMPER
	--'------------------------------------------------------------------------

	it = 1
	way_name = gname.."_camper_1_walk"

	while path_exists(way_name) do

		local radius = "0"
--[[
		local state = "hide"
		local ptr = patrol(way_name)
		local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
		local wp_prop_state = wp_prop.state
		local wp_prop_radius = wp_prop.radius -- no 'radius' parameter used in any vanilla waypoint name line

		if wp_prop_state ~= nil then
			if wp_prop_state == "stand" then
				state = "threat"
			end
		end

		if wp_prop_radius ~= nil then
			radius = wp_prop_radius
		end
]]
		local state = match(patrol(way_name):name(0), "|state=(%l+)") == "stand" and "threat" or "hide"

		num = num + 1
		stalker_defence_jobs.jobs[num] =
		{
			_prior = 45,
			job_id = {section = "logic@"..way_name},
			_precondition_params = {way_name = way_name},
			_precondition_function = _precond_func_camper
		}
--[[
		local job_ltx =

		"[logic@"..way_name.."]\n"..
		"active = camper@"..way_name.."\n"..

		"[camper@"..way_name.."]\n"..
		"meet = meet@generic_lager\n"..
		"radius = "..tostring(radius).."\n"..
		"path_walk = camper_"..it.."_walk\n"..
		"def_state_moving = rush\n"..
		"def_state_campering ="..state.."\n"..
		"def_state_campering_fire ="..state.."_fire\n"..
		danger_ltx
]]
		ltx[ltx_num + 1] = "[logic@"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=camper@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[camper@"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\nmeet=meet@generic_lager\nradius="
		ltx[ltx_num + 8] = radius
		ltx[ltx_num + 9] = "\npath_walk=camper_"
		ltx[ltx_num + 10] = it
		ltx[ltx_num + 11] = "_walk\ndef_state_moving=rush\ndef_state_campering="
		ltx[ltx_num + 12] = state
		ltx[ltx_num + 13] = "\ndef_state_campering_fire="
		ltx[ltx_num + 14] = state
		ltx_num = ltx_num + 15
		ltx[ltx_num] = "_fire\n"

		if path_exists(gname.."_camper_"..it.."_look") then
			ltx[ltx_num + 1] = "path_look=camper_"
			ltx[ltx_num + 2] = it
			ltx_num = ltx_num + 3
			ltx[ltx_num] = "_look\n"
		end

		if smart_def_restr then
			ltx[ltx_num + 1] = smart_def_string_no_newline
			ltx[ltx_num + 2] = combat_restrictor.get_job_restrictor(way_name)
			ltx_num = ltx_num + 3
			ltx[ltx_num] = "\n"
		end

		it = it + 1
		way_name = gname.."_camper_"..it.."_walk"
	end

	--'------------------------------------------------------------------------
	--'				GENERIC COVERS
	--'------------------------------------------------------------------------

	it = 1
	local path = gname.."_kamp_1"

	while path_exists(path) do

		way_name = gname.."_kamp_"..it.."_task"
--[[
		local job_count = 5
		local ptr = patrol(way_name)
		local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
		local wp_prop_count = wp_prop.count

		if wp_prop_count ~= nil then
			job_count = wp_prop_count
		end
]]
		local job_count = match(patrol(way_name):name(0), "|count=(%d+)") or 5
		local log_gen_def_smrtcov = "logic@general_defend_smartcover_"..way_name
		local log_gen_def_cov = "logic@general_defend_cover_"..way_name

		for i = 1, job_count do

			num = num + 1
			stalker_defence_jobs.jobs[num] =
			{
				_prior = 43,
				job_id = {section = log_gen_def_smrtcov},
				_precondition_params = {way_name = way_name},
				_precondition_function = _precond_func_smartcover
			}

			num = num + 1
			stalker_defence_jobs.jobs[num] =
			{
				_prior = 43,
				job_id = {section = log_gen_def_cov},
				_precondition_params = {way_name = way_name},
				_precondition_function = _precond_func_cover
			}
		end
--[[
		local job_ltx =

		"[logic@general_defend_smartcover_"..way_name.."]\n"..
		"active = smartcover@"..way_name.."\n"..

		"[smartcover@"..way_name.."]\n"..
		"path_walk = kamp_"..it.."_task\n"..
		"meet = no_meet\n"..
		"cover_state = {=cover_attack ~50} fire_target,{=cover_attack} fire_no_lookout_target, default_behaviour\n"..
		"def_state_moving = sneak_run\n"..
		"sound_idle = post_combat_wait_long\n"..
		"use_precalc_cover = true\n"..
		danger_ltx.. -- we need a danger section reference for this section, too

		"[logic@general_defend_cover_"..way_name.."]\n"..
		"active = cover@"..way_name.."\n"..

		"[cover@"..way_name.."]\n"..
		"path_walk = kamp_"..it.."_task\n"..
		"meet = no_meet\n"..
		"anim = {=cover_attack} hide_fire, hide\n"..
		"smart = "..gname.."\n"..
		"sound_idle = post_combat_wait_long\n"..
		"use_attack_direction = false\n"..
		"use_precalc_cover = true\n"..
		danger_ltx
]]
		ltx[ltx_num + 1] = "[logic@general_defend_smartcover_"
		ltx[ltx_num + 2] = way_name
		ltx[ltx_num + 3] = "]\nactive=smartcover@"
		ltx[ltx_num + 4] = way_name
		ltx[ltx_num + 5] = "\n[smartcover@"
		ltx[ltx_num + 6] = way_name
		ltx[ltx_num + 7] = "]\npath_walk=kamp_"
		ltx[ltx_num + 8] = it
		ltx[ltx_num + 9] = "_task\nmeet=no_meet\ncover_state={=cover_attack~50}fire_target,{=cover_attack}fire_no_lookout_target,default_behaviour\ndef_state_moving=sneak_run\nsound_idle=post_combat_wait_long\nuse_precalc_cover=true\n[logic@general_defend_cover_"
		ltx[ltx_num + 10] = way_name
		ltx[ltx_num + 11] = "]\nactive=cover@"
		ltx[ltx_num + 12] = way_name
		ltx[ltx_num + 13] = "\n[cover@"
		ltx[ltx_num + 14] = way_name
		ltx[ltx_num + 15] = "]\npath_walk=kamp_"
		ltx[ltx_num + 16] = it
		ltx[ltx_num + 17] = "_task\nmeet=no_meet\nanim={=cover_attack}hide_fire,hide\nsmart="
		ltx[ltx_num + 18] = gname
		ltx_num = ltx_num + 19
		ltx[ltx_num] = "\nsound_idle=post_combat_wait_long\nuse_attack_direction=false\nuse_precalc_cover=true\n"

		if smart_def_restr then
			ltx[ltx_num + 1] = smart_def_string_no_newline
			ltx[ltx_num + 2] = combat_restrictor.get_job_restrictor(way_name)
			ltx_num = ltx_num + 3
			ltx[ltx_num] = "\n"
		end

		it = it + 1
		path = gname.."_kamp_"..it
	end

	stalker_jobs.jobs = {stalker_general_jobs, stalker_attack_jobs, stalker_defence_jobs}

	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--'				Emission jobs
	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	--'------------------------------------------------------------------------
	--'				HIDE FROM SURGE
	--'------------------------------------------------------------------------

	if smart.surge_hide_avaliable then

		local stalker_surge_jobs =
		{
			_prior = 100,
			jobs = {},
			_precondition_function = xr_conditions.is_surge_activated

--			function()
--				return xr_conditions.is_surge_activated()
--			end
		}

		num = 0 -- #stalker_surge_jobs.jobs
		it = 1
		way_name = gname.."_surge_hide_1"

		local priority = 101

		while path_exists(way_name) do
--[[
			local def_prior = 100
			local job_count = 5
			local ptr = patrol(way_name)
			local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
			local wp_prop_count = wp_prop.count

			if wp_prop_count ~= nil then
				job_count = wp_prop_count
			end
]]
			local job_count = match(patrol(way_name):name(0), "|count=(%d+)") or 5
			local logic_way_name = "logic@"..way_name

			priority = priority - it -- e.g. _surge_hide_1 gets 100, _surge_hide_2 gets 99, etc.

			for i = 1, job_count do
				stalker_surge_jobs.jobs[num + i] = {_prior = priority, job_id = {section = logic_way_name}}
			end

			num = num + job_count
--[[
			local job_ltx =

			"[logic@"..way_name.."]\n"..
			"active = surge_hide@"..way_name.."\n"..

			"[surge_hide@"..way_name.."]\n"..
			"path_walk = surge_hide_"..it.."\n"..
			"on_info = {=is_surge_complete} walker@"..way_name.."\n"..

			"[walker@"..way_name.."]\n"..
			"path_walk = surge_hide_"..it.."\n"
]]
			ltx[ltx_num + 1] = "[logic@"
			ltx[ltx_num + 2] = way_name
			ltx[ltx_num + 3] = "]\nactive=surge_hide@"
			ltx[ltx_num + 4] = way_name
			ltx[ltx_num + 5] = "\n[surge_hide@"
			ltx[ltx_num + 6] = way_name
			ltx[ltx_num + 7] = "]\npath_walk=surge_hide_"
			ltx[ltx_num + 8] = it
			ltx[ltx_num + 9] = "\non_info={=is_surge_complete}walker@"
			ltx[ltx_num + 10] = way_name
			ltx[ltx_num + 11] = "\n[walker@"
			ltx[ltx_num + 12] = way_name
			ltx[ltx_num + 13] = "]\npath_walk=surge_hide_"
			ltx[ltx_num + 14] = it
			ltx_num = ltx_num + 15
			ltx[ltx_num] = "\n"

			it = it + 1
			way_name = gname.."_surge_hide_"..it
		end

		if it <= smart.squad_capacity then -- if insufficiently many surge_hide way points on smart to accommodate all its possible squads, make all its kamp points available for surge_hide logic

			it = 1
			way_name = gname.."_kamp_"..it

			while path_exists(way_name) do
--[[
				local def_prior = 100
				local job_count = 5
				local ptr = patrol(way_name)
				local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
				local wp_prop_count = wp_prop.count

				if wp_prop_count ~= nil then
					job_count = wp_prop_count
				end
]]
				local job_count = match(patrol(way_name):name(0), "|count=(%d+)") or 5
				local log_surge_hide_way = "logic@surge_hide_"..way_name

				priority = priority - it

				for i = 1, job_count do
					stalker_surge_jobs.jobs[num + i] = {_prior = priority, job_id = {section = log_surge_hide_way}}
				end

				num = num + job_count
--[[
				local job_ltx =

				"[logic@surge_hide_"..way_name.."]\n"..
				"active = surge_hide@"..way_name.."\n"..

				"[surge_hide@"..way_name.."]\n"..
				"path_walk = kamp_"..it.."_task\n"..
				"on_info = {=is_surge_complete} walker@"..way_name.."\n"..

				"[walker@"..way_name.."]\n"..
				"path_walk = kamp_"..it.."_task\n"
]]
				ltx[ltx_num + 1] = "[logic@surge_hide_"
				ltx[ltx_num + 2] = way_name
				ltx[ltx_num + 3] = "]\nactive=surge_hide@"
				ltx[ltx_num + 4] = way_name
				ltx[ltx_num + 5] = "\n[surge_hide@"
				ltx[ltx_num + 6] = way_name
				ltx[ltx_num + 7] = "]\npath_walk=kamp_"
				ltx[ltx_num + 8] = it
				ltx[ltx_num + 9] = "_task\non_info={=is_surge_complete}walker@"
				ltx[ltx_num + 10] = way_name
				ltx[ltx_num + 11] = "\n[walker@"
				ltx[ltx_num + 12] = way_name
				ltx[ltx_num + 13] = "]\npath_walk=kamp_"
				ltx[ltx_num + 14] = it
				ltx_num = ltx_num + 15
				ltx[ltx_num] = "_task\n"

				it = it + 1
				way_name = gname.."_kamp_"..it
			end
		end

		stalker_jobs.jobs[4] = stalker_surge_jobs -- #stalker_jobs.jobs + 1 = 4
	end

	--'========================================================================
	--'				Monster jobs
	--'========================================================================

	local monster_jobs = {_precondition_is_monster = true, _prior = 50, jobs = true}

	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--'				General jobs
	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	local monster_general_jobs = {_prior = 40, jobs = {}}

	--'------------------------------------------------------------------------
	--'				MOB HOME
	--'------------------------------------------------------------------------

	num = 0 -- #monster_general_jobs.jobs
	it = 1
	way_name = gname.."_kamp_1_task"

	while path_exists(way_name) do

		local job_count = 10
		local home_min_radius = "15"
		local home_max_radius = "30"
--[[
		local ptr = patrol(way_name)
		local wp_prop = utils.parse_waypoint_data(way_name, ptr:flags(0), ptr:name(0))
		local wp_prop_m_count = wp_prop.m_count -- no 'm_count' parameter used in any vanilla waypoint name line
		local wp_prop_min = wp_prop.min -- ditto 'min'
		local wp_prop_max = wp_prop.max -- ditto 'max'

		if wp_prop_m_count ~= nil then
			job_count = wp_prop_m_count
		end

		if wp_prop_min ~= nil then
			home_min_radius = wp_prop_min
		end

		if wp_prop_max ~= nil then
			home_max_radius = wp_prop_max
		end

		local gname_home_it = gname.."_home_"..it
]]
		local log_gname_home_it = "logic@"..gname.."_home_"..it

		for i = 1, job_count do
			monster_general_jobs.jobs[num + i] = {_prior = 40, job_id = {section = log_gname_home_it}}
		end

		num = num + job_count
--[[
		local job_ltx =

		"["..log_gname_home_it.."]\n"..
		"active = mob_home@"..gname_home_it.."\n"..

		"[mob_home@"..gname_home_it.."]\n"..
		"path_home = kamp_"..it.."_task\n"..
		"home_min_radius = "..home_min_radius.."\n"..
		"home_max_radius = "..home_max_radius.."\n"
]]
		ltx[ltx_num + 1] = "["
		ltx[ltx_num + 2] = log_gname_home_it
		ltx[ltx_num + 3] = "]\nactive=mob_home@"
		ltx[ltx_num + 4] = gname
		ltx[ltx_num + 5] = "_home_"
		ltx[ltx_num + 6] = it
		ltx[ltx_num + 7] = "\n[mob_home@"
		ltx[ltx_num + 8] = gname
		ltx[ltx_num + 9] = "_home_"
		ltx[ltx_num + 10] = it
		ltx[ltx_num + 11] = "]\npath_home=kamp_"
		ltx[ltx_num + 12] = it
		ltx[ltx_num + 13] = "_task\nhome_min_radius="
		ltx[ltx_num + 14] = home_min_radius
		ltx[ltx_num + 15] = "\nhome_max_radius="
		ltx[ltx_num + 16] = home_max_radius
		ltx_num = ltx_num + 17
		ltx[ltx_num] = "\n"

		if smart_def_restr then
			ltx_num = ltx_num + 1
			ltx[ltx_num] = smart_def_string
		end

		it = it + 1
		way_name = gname.."_kamp_"..it.."_task"
	end

	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	--'				Attack jobs
	--'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	local monster_attack_jobs = {_prior = 50, jobs = {}, _current_squad_action = "attack_point"}

	attack_jobs_num = 0 -- re-used from stalker_attack_jobs

	for k, target_smart_obj in pairs (board:get_nearest_smarts(smart)) do

		local target_smart = target_smart_obj:name()
		local monster_attack_smart_jobs = {_prior = 50, jobs = {}, _current_squad_action = "attack_point", _squad_attack_point = target_smart}

	--'------------------------------------------------------------------------
	--'				MONSTER ATTACK
	--'------------------------------------------------------------------------

		local att_restr = target_smart_obj.att_restr

		if att_restr then
			att_restr = "out_restr="..att_restr.."\n"
		end

		num = 0 -- #monster_attack_smart_jobs.jobs
		it = 1

		while path_exists(target_smart.."_kamp_"..it.."_task") do

			local job_count = 10
			local home_min_radius = "15"
			local home_max_radius = "30"

			for i = 1, job_count do

				local sect_name = gname.."_to_"..target_smart.."_monster_attack_"..i.."_"..it

				monster_attack_smart_jobs.jobs[num + i] = {_prior = 50, _attack_job = true, job_id = {section = "logic@"..sect_name, prefix_name = target_smart}}
--[[
				local job_ltx =

				"[logic@"..sect_name.."]\n"..
				"active = mob_home@"..sect_name.."\n"..

				"[mob_home@"..sect_name.."]\n"..
				"agressive = true\n"..
				"path_home = kamp_"..it.."_task\n"..
				"home_min_radius = "..home_min_radius.."\n"..
				"home_max_radius = "..home_max_radius.."\n"..
				"on_info = {=npc_to_smart_dist("..target_smart..":50)} mob_home@"..sect_name.."_arrived %=request_current_squad_stage(combat)%\n"..

				"[mob_home@"..sect_name.."_arrived]\n"..
				"agressive = true\n"..
				"path_home = kamp_"..it.."_task\n"..
				"home_min_radius = "..home_min_radius.."\n"..
				"home_max_radius = "..home_max_radius.."\n"
]]
				ltx[ltx_num + 1] = "[logic@"
				ltx[ltx_num + 2] = sect_name
				ltx[ltx_num + 3] = "]\nactive=mob_home@"
				ltx[ltx_num + 4] = sect_name
				ltx[ltx_num + 5] = "\n[mob_home@"
				ltx[ltx_num + 6] = sect_name
				ltx[ltx_num + 7] = "]\naggressive=true\npath_home=kamp_"
				ltx[ltx_num + 8] = it
				ltx[ltx_num + 9] = "_task\nhome_min_radius="
				ltx[ltx_num + 10] = home_min_radius
				ltx[ltx_num + 11] = "\nhome_max_radius="
				ltx[ltx_num + 12] = home_max_radius
				ltx[ltx_num + 13] = "\non_info={=npc_to_smart_dist("
				ltx[ltx_num + 14] = target_smart
				ltx[ltx_num + 15] = ":50)}mob_home@"
				ltx[ltx_num + 16] = sect_name
				ltx[ltx_num + 17] = "_arrived%=request_current_squad_stage(combat)%\n[mob_home@"
				ltx[ltx_num + 18] = sect_name
				ltx[ltx_num + 19] = "_arrived]\naggressive=true\npath_home=kamp_"
				ltx[ltx_num + 20] = it
				ltx[ltx_num + 21] = "_task\nhome_min_radius="
				ltx[ltx_num + 22] = home_min_radius
				ltx[ltx_num + 23] = "\nhome_max_radius="
				ltx[ltx_num + 24] = home_max_radius
				ltx_num = ltx_num + 25
				ltx[ltx_num] = "\n"

				if att_restr ~= nil then
					ltx_num = ltx_num + 1
					ltx[ltx_num] = att_restr
				end
			end

			num = num + job_count
			it = it + 1
		end

		attack_jobs_num = attack_jobs_num + 1
		monster_attack_jobs.jobs[attack_jobs_num] = monster_attack_smart_jobs
	end

	monster_jobs.jobs = {monster_general_jobs, monster_attack_jobs}
	local job_table = {stalker_jobs, monster_jobs}

	--'========================================================================
	--'				Exclusive jobs
	--'========================================================================

	local smart_ini = smart:spawn_ini()
	if smart_ini:section_exist("smart_terrain") then
		if smart_ini:section_exist("exclusive") then
			local n = smart_ini:line_count("exclusive")
			for i = 0, n - 1 do
				local found, job_name, job_script = smart_ini:r_line("exclusive", i, "", "")
				if job_script ~= "" then
					add_exclusive_job(job_name, job_table, job_script)
				end
			end
		else
			num = 1
			local job_name = "work"..num
			while smart_ini:line_exist("smart_terrain", job_name) do
				local job_script = smart_ini:r_string("smart_terrain", job_name)
				if job_script ~= nil then
					add_exclusive_job(job_name, job_table, job_script)
				end
				num = num + 1
				job_name = "work"..num
			end
		end
	end

	return job_table
end

--------------------------------------------------------------------------
-- Dynamic ltx
--------------------------------------------------------------------------

function load_ltx()
--	dbglog(ltx and #ltx)
	local dyn_ltx = ltx and table_concat(ltx)
	ltx = nil
--[[
	local a, b = 1, 1800
	local sub = string.sub
	local substring = sub(dyn_ltx, a, b)
	while (substring ~= "") do
		error_log("\n"..substring)
		a = b + 1
		b = b + 1800
		substring = sub(dyn_ltx, a, b)
	end
--	get_console():execute("flush")
]]
	return dyn_ltx
end